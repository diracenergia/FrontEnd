// src/components/kpi/shared/PumpPowerChart.tsx
import React, { useMemo } from "react";
import {
  ResponsiveContainer, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend,
} from "recharts";

export type TimeWindow = "24h" | "7d" | "30d";

export type PumpTS = {
  timestamps: string[];   // ISO
  is_on?: boolean[];      // preferido
  power_kw?: number[];    // fallback: >0 => encendida
};

type Props = {
  /** Para compat con tu vista actual (una sola bomba) */
  ts?: PumpTS;
  /** Para contar varias bombas a la vez (recomendado) */
  fleet?: Record<string, PumpTS>;
  /** Ventana para la agregación (hora o día) */
  windowSel?: TimeWindow;
  /** Título opcional */
  title?: string;
};

function fmtHourKey(iso: string) {
  const d = new Date(iso);
  // key tipo 2025-09-17 13 (hora)
  return `${d.toISOString().slice(0,10)} ${String(d.getHours()).padStart(2,"0")}`;
}
function fmtHourLabelFromKey(key: string) {
  // key -> HH:00
  const hh = key.slice(11,13);
  return `${hh}:00`;
}
function fmtDayKey(iso: string) {
  // YYYY-MM-DD
  return iso.slice(0, 10);
}

/**
 * Reglas de agregación:
 * - 24h: por HORA -> cuántas bombas estuvieron encendidas al menos una vez en esa hora.
 * - 7d / 30d: por DÍA -> cuántas bombas estuvieron encendidas al menos una vez en ese día.
 * Importante: por bomba y bucket contamos a lo sumo 1, aunque tenga múltiples muestras ON en ese bucket.
 */
function aggregateFleet(fleet: Record<string, PumpTS>, win: TimeWindow) {
  const useDaily = win !== "24h";
  const totals = new Map<string, number>(); // bucket -> count bombas ON (única por bomba)

  Object.values(fleet).forEach((ts) => {
    const n = ts.timestamps?.length ?? 0;
    // set de buckets en los que ESTA bomba estuvo ON al menos una vez
    const bucketsOn = new Set<string>();
    for (let i = 0; i < n; i++) {
      const iso = ts.timestamps[i];
      const on = (ts.is_on && ts.is_on[i] === true) || (!!ts.power_kw && (ts.power_kw[i] ?? 0) > 0);
      if (!on) continue;
      const key = useDaily ? fmtDayKey(iso) : fmtHourKey(iso);
      bucketsOn.add(key);
    }
    // sumamos 1 por cada bucket donde esta bomba estuvo ON
    bucketsOn.forEach((key) => {
      totals.set(key, (totals.get(key) ?? 0) + 1);
    });
  });

  // orden cronológico por key
  const entries = Array.from(totals.entries()).sort((a, b) => (a[0] < b[0] ? -1 : 1));
  return entries.map(([key, count]) => ({
    label: useDaily ? key : fmtHourLabelFromKey(key),
    uso_bombas_un: count,
  }));
}

function aggregateSingle(ts: PumpTS, win: TimeWindow) {
  // Igual que fleet pero con 1 sola bomba => resultado 0/1 por bucket
  return aggregateFleet({ single: ts }, win);
}

export default function PumpPowerChart({
  ts,
  fleet,
  windowSel = "24h",
  title = "Uso de bombas (un)",
}: Props) {
  const data = useMemo(() => {
    if (fleet && Object.keys(fleet).length) return aggregateFleet(fleet, windowSel);
    if (ts) return aggregateSingle(ts, windowSel);
    return [];
  }, [fleet, ts, windowSel]);

  return (
    <div className="rounded-2xl border bg-white p-3">
      <div className="text-base font-semibold text-gray-700 mb-2">
        {title} {windowSel === "24h" ? "(por hora)" : "(por día)"}
      </div>
      <div className="h-56">
        <ResponsiveContainer width="100%" height="100%">
          <BarChart data={data} margin={{ top: 5, right: 20, left: 0, bottom: 5 }}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="label" />
            <YAxis allowDecimals={false} tickFormatter={(v)=>`${v}`} />
            <Tooltip formatter={(v: any) => [`${v} un`, "Uso de bombas"]} />
            <Legend />
            {/* Barras verticales, igual formato que antes */}
            <Bar name="Uso de bombas (un)" dataKey="uso_bombas_un" />
          </BarChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
}
