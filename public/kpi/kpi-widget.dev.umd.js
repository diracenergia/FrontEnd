(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("react"), require("react-dom/client"), require("react-dom")) : typeof define === "function" && define.amd ? define(["exports", "react", "react-dom/client", "react-dom"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.KpiWidget = {}, global.React, global.ReactDOMClient, global.ReactDOM));
})(this, function(exports2, React, ReactDOM, reactDom) {
  "use strict";var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  function _interopNamespaceDefault(e) {
    const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
    if (e) {
      for (const k2 in e) {
        if (k2 !== "default") {
          const d = Object.getOwnPropertyDescriptor(e, k2);
          Object.defineProperty(n, k2, d.get ? d : {
            enumerable: true,
            get: () => e[k2]
          });
        }
      }
    }
    n.default = e;
    return Object.freeze(n);
  }
  const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  function getDefaultExportFromNamespaceIfPresent(n) {
    return n && Object.prototype.hasOwnProperty.call(n, "default") ? n["default"] : n;
  }
  function getDefaultExportFromNamespaceIfNotNamed(n) {
    return n && Object.prototype.hasOwnProperty.call(n, "default") && Object.keys(n).length === 1 ? n["default"] : n;
  }
  function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var f = n.default;
    if (typeof f == "function") {
      var a2 = function a22() {
        if (this instanceof a22) {
          return Reflect.construct(f, arguments, this.constructor);
        }
        return f.apply(this, arguments);
      };
      a2.prototype = f.prototype;
    } else a2 = {};
    Object.defineProperty(a2, "__esModule", { value: true });
    Object.keys(n).forEach(function(k2) {
      var d = Object.getOwnPropertyDescriptor(n, k2);
      Object.defineProperty(a2, k2, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k2];
        }
      });
    });
    return a2;
  }
  var jsxRuntime$2 = { exports: {} };
  var reactJsxRuntime_development = {};
  var jsxs_1;
  var jsx_1;
  var Fragment$1;
  "use strict";
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  if (true) {
    (function() {
      "use strict";
      var React$1 = React;
      var REACT_ELEMENT_TYPE2 = Symbol.for("react.element");
      var REACT_PORTAL_TYPE2 = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE2 = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE2 = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE2 = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE2 = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE2 = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE2 = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE2 = Symbol.for("react.memo");
      var REACT_LAZY_TYPE2 = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE2 = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format2) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format2 += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format2);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType2(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE2 || type === REACT_PROFILER_TYPE2 || enableDebugTracing || type === REACT_STRICT_MODE_TYPE2 || type === REACT_SUSPENSE_TYPE2 || type === REACT_SUSPENSE_LIST_TYPE2 || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE2 || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE2 || type.$$typeof === REACT_MEMO_TYPE2 || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE2 || type.$$typeof === REACT_FORWARD_REF_TYPE2 || // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE2:
            return "Fragment";
          case REACT_PORTAL_TYPE2:
            return "Portal";
          case REACT_PROFILER_TYPE2:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE2:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE2:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE2:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE2:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE2:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE2:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE2: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x2) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign2 = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign2({}, props, {
                value: prevLog
              }),
              info: assign2({}, props, {
                value: prevInfo
              }),
              warn: assign2({}, props, {
                value: prevWarn
              }),
              error: assign2({}, props, {
                value: prevError
              }),
              group: assign2({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign2({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign2({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix2;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix2 === void 0) {
            try {
              throw Error();
            } catch (x2) {
              var match = x2.stack.trim().match(/\n( *(at )?)/);
              prefix2 = match && match[1] || "";
            }
          }
          return "\n" + prefix2 + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x2) {
                control = x2;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x2) {
                control = x2;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x2) {
              control = x2;
            }
            fn();
          }
        } catch (sample2) {
          if (sample2 && control && typeof sample2.stack === "string") {
            var sampleLines = sample2.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s2 = sampleLines.length - 1;
            var c2 = controlLines.length - 1;
            while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
              c2--;
            }
            for (; s2 >= 1 && c2 >= 0; s2--, c2--) {
              if (sampleLines[s2] !== controlLines[c2]) {
                if (s2 !== 1 || c2 !== 1) {
                  do {
                    s2--;
                    c2--;
                    if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                      var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s2 >= 1 && c2 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE2:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE2:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE2:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE2:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE2: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x2) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has2 = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has2(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray2(a2) {
        return isArrayImpl(a2);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      var didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config2) {
        {
          if (hasOwnProperty.call(config2, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config2.ref !== void 0;
      }
      function hasValidKey(config2) {
        {
          if (hasOwnProperty.call(config2, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config2.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config2, self2) {
        {
          if (typeof config2.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config2.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE2,
          // Built-in properties that belong on the element
          type,
          key,
          ref,
          props,
          // Record the component responsible for creating this element.
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type, config2, maybeKey, source, self2) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== void 0) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config2)) {
            {
              checkKeyStringCoercion(config2.key);
            }
            key = "" + config2.key;
          }
          if (hasValidRef(config2)) {
            ref = config2.ref;
            warnIfStringRefCannotBeAutoConverted(config2, self2);
          }
          for (propName in config2) {
            if (hasOwnProperty.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config2[propName];
            }
          }
          if (type && type.defaultProps) {
            var defaultProps2 = type.defaultProps;
            for (propName in defaultProps2) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps2[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object2) {
        {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE2;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node !== "object") {
            return;
          }
          if (isArray2(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === void 0 || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE2 || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type.$$typeof === REACT_MEMO_TYPE2)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys = Object.keys(fragment.props);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      var didWarnAboutKeySpread = {};
      function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
        {
          var validType = isValidElementType2(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum(source);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray2(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE2) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type, props, key, source, self2);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== void 0) {
              if (isStaticChildren) {
                if (isArray2(children)) {
                  for (var i = 0; i < children.length; i++) {
                    validateChildKeys(children[i], type);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type);
              }
            }
          }
          {
            if (hasOwnProperty.call(props, "key")) {
              var componentName = getComponentNameFromType(type);
              var keys = Object.keys(props).filter(function(k2) {
                return k2 !== "key";
              });
              var beforeExample = keys.length > 0 ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
              if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                var afterExample = keys.length > 0 ? "{" + keys.join(": ..., ") + ": ...}" : "{}";
                error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                didWarnAboutKeySpread[componentName + beforeExample] = true;
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE2) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      function jsxWithValidationStatic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, true);
        }
      }
      function jsxWithValidationDynamic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, false);
        }
      }
      var jsx = jsxWithValidationDynamic;
      var jsxs = jsxWithValidationStatic;
      Fragment$1 = reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE2;
      jsx_1 = reactJsxRuntime_development.jsx = jsx;
      jsxs_1 = reactJsxRuntime_development.jsxs = jsxs;
    })();
  }
  var jsxRuntime = jsxRuntime$2.exports;
  "use strict";
  if (false) {
    module.exports = require("./cjs/react-jsx-runtime.production.min.js");
  } else {
    jsxRuntime$2.exports = reactJsxRuntime_development;
  }
  var jsxRuntimeExports = jsxRuntime$2.exports;
  const jsxRuntime$1 = /* @__PURE__ */ getDefaultExportFromCjs(jsxRuntimeExports);
  const bandForHour$1 = (h) => {
    if (h >= 0 && h < 7) return "VALLE";
    if (h >= 19 && h < 23) return "PICO";
    return "RESTO";
  };
  function buildPowerFromIsOn$1(data) {
    for (const p of data.assets.pumps) {
      const ts = data.timeseries.pumps[String(p.id)];
      if (!ts) continue;
      ts.power_kw = ts.is_on.map((on) => {
        const base = on ? p.rated_kw * 0.82 : 0.1;
        const jitter = on ? (Math.random() * 0.2 - 0.1) * p.rated_kw : 0;
        return Math.max(0, Number((base + jitter).toFixed(2)));
      });
    }
  }
  function kwhByBandForPump$1(pumpTs) {
    if (!(pumpTs == null ? void 0 : pumpTs.power_kw)) return { VALLE: 0, PICO: 0, RESTO: 0, total: 0 };
    const acc = { VALLE: 0, PICO: 0, RESTO: 0 };
    pumpTs.timestamps.forEach((t, i) => {
      const h = Number(t.slice(11, 13));
      const band2 = bandForHour$1(h);
      const kwh = pumpTs.power_kw[i] ?? 0;
      acc[band2] += kwh;
    });
    const total = acc.VALLE + acc.PICO + acc.RESTO;
    return { ...acc, total };
  }
  const now = /* @__PURE__ */ new Date();
  const baseDate = new Date(now);
  baseDate.setDate(baseDate.getDate() - 7);
  const timestamps = Array.from({ length: 7 * 24 }).map((_, i) => {
    const d = new Date(baseDate.getTime() + i * 36e5);
    return d.toISOString();
  });
  function randomSeries(len, min2, max2) {
    return Array.from({ length: len }).map(
      () => min2 + Math.round(Math.random() * (max2 - min2))
    );
  }
  const mock = {
    generated_at: now.toISOString(),
    org: { id: 1, name: "Demo Org" },
    kpis: {
      assets_total: 6,
      tanks: 3,
      pumps: 3,
      valves: 0,
      manifolds: 0,
      alarms_active: 2,
      alarms_critical_active: 1,
      avg_flow_lpm_30d: 150,
      avg_level_pct_30d: 65
    },
    locations: [
      { location_id: 1, location_code: "LOC-1", location_name: "Planta Norte" },
      { location_id: 2, location_code: "LOC-2", location_name: "Planta Sur" }
    ],
    byLocation: [
      {
        location_id: 1,
        location_code: "LOC-1",
        location_name: "Planta Norte",
        assets_total: 3,
        tanks_count: 2,
        pumps_count: 1,
        valves_count: 0,
        manifolds_count: 0,
        alarms_active: 1,
        alarms_critical_active: 0,
        pump_readings_30d: 120,
        avg_flow_lpm_30d: 100,
        avg_pressure_bar_30d: 2.5,
        pumps_last_seen: now.toISOString(),
        tank_readings_30d: 120,
        avg_level_pct_30d: 60,
        tanks_last_seen: now.toISOString()
      },
      {
        location_id: 2,
        location_code: "LOC-2",
        location_name: "Planta Sur",
        assets_total: 3,
        tanks_count: 1,
        pumps_count: 2,
        valves_count: 0,
        manifolds_count: 0,
        alarms_active: 1,
        alarms_critical_active: 1,
        pump_readings_30d: 120,
        avg_flow_lpm_30d: 200,
        avg_pressure_bar_30d: 3,
        pumps_last_seen: now.toISOString(),
        tank_readings_30d: 120,
        avg_level_pct_30d: 70,
        tanks_last_seen: now.toISOString()
      }
    ],
    assets: {
      tanks: [
        { id: 1, name: "Tanque Norte 1", capacity_liters: 5e4, location_id: 1, fluid: "Agua" },
        { id: 2, name: "Tanque Norte 2", capacity_liters: 3e4, location_id: 1, fluid: "Agua" },
        { id: 3, name: "Tanque Sur", capacity_liters: 4e4, location_id: 2, fluid: "Agua" }
      ],
      pumps: [
        { id: 101, name: "Bomba Norte A", rated_kw: 7.5, drive_type: "vfd", location_id: 1, group_id: 1 },
        { id: 201, name: "Bomba Sur A", rated_kw: 5.5, drive_type: "direct", location_id: 2, group_id: 1 },
        { id: 202, name: "Bomba Sur B", rated_kw: 5.5, drive_type: "direct", location_id: 2, group_id: 1 }
      ],
      valves: [],
      manifolds: []
    },
    latest: {
      tanks: [
        { tank_id: 1, ts: now.toISOString(), level_percent: 62, volume_l: 31e3, temperature_c: 18 },
        { tank_id: 2, ts: now.toISOString(), level_percent: 70, volume_l: 21e3, temperature_c: 19 },
        { tank_id: 3, ts: now.toISOString(), level_percent: 55, volume_l: 22e3, temperature_c: 17 }
      ],
      pumps: [
        { pump_id: 101, ts: now.toISOString(), is_on: true, flow_lpm: 90, pressure_bar: 2.6, voltage_v: 380, current_a: 12, control_mode: "auto", manual_lockout: false },
        { pump_id: 201, ts: now.toISOString(), is_on: false, flow_lpm: 0, pressure_bar: 0, voltage_v: 0, current_a: 0, control_mode: "manual", manual_lockout: false },
        { pump_id: 202, ts: now.toISOString(), is_on: true, flow_lpm: 100, pressure_bar: 3.1, voltage_v: 380, current_a: 14, control_mode: "auto", manual_lockout: false }
      ]
    },
    timeseries: {
      tanks: {
        "1": {
          timestamps,
          level_percent: randomSeries(timestamps.length, 50, 70),
          volume_l: randomSeries(timestamps.length, 28e3, 32e3),
          temperature_c: randomSeries(timestamps.length, 16, 20)
        },
        "2": {
          timestamps,
          level_percent: randomSeries(timestamps.length, 60, 80),
          volume_l: randomSeries(timestamps.length, 2e4, 25e3),
          temperature_c: randomSeries(timestamps.length, 16, 21)
        },
        "3": {
          timestamps,
          level_percent: randomSeries(timestamps.length, 40, 65),
          volume_l: randomSeries(timestamps.length, 2e4, 25e3),
          temperature_c: randomSeries(timestamps.length, 15, 19)
        }
      },
      pumps: {
        "101": {
          timestamps,
          is_on: Array.from({ length: timestamps.length }).map((_, i) => i % 8 < 4)
        },
        "201": {
          timestamps,
          is_on: Array.from({ length: timestamps.length }).map((_, i) => i % 12 < 2)
        },
        "202": {
          timestamps,
          is_on: Array.from({ length: timestamps.length }).map((_, i) => i % 6 < 3)
        }
      }
    },
    analytics30d: {
      pump_uptime: {
        "101": { pump_id: 101, pump_name: "Bomba Norte A", on_seconds: 300 * 3600, total_seconds: 720 * 3600, uptime_pct_30d: 40 },
        "201": { pump_id: 201, pump_name: "Bomba Sur A", on_seconds: 100 * 3600, total_seconds: 720 * 3600, uptime_pct_30d: 14 },
        "202": { pump_id: 202, pump_name: "Bomba Sur B", on_seconds: 400 * 3600, total_seconds: 720 * 3600, uptime_pct_30d: 55 }
      },
      pump_energy_kwh: {
        "101": { pump_id: 101, kwh_30d: 120 },
        "201": { pump_id: 201, kwh_30d: 40 },
        "202": { pump_id: 202, kwh_30d: 150 }
      }
    },
    topology: { edges: [], nodes: [] },
    alarms: [
      { id: 1, severity: "critical", message: "Tanque Sur nivel bajo", ts: now.toISOString() },
      { id: 2, severity: "warning", message: "Bomba Norte A consumo alto", ts: now.toISOString() }
    ]
  };
  buildPowerFromIsOn$1(mock);
  const Ctx = React.createContext(null);
  function KpiFiltersProvider({
    initialLocation = "all",
    children
  }) {
    const [locationId, setLocationId] = React.useState(initialLocation);
    const [window2, setWindow] = React.useState("24h");
    const [pumpId, setPumpId] = React.useState(null);
    const [tankId, setTankId] = React.useState(null);
    const value = {
      locationId,
      window: window2,
      pumpId,
      tankId,
      setLocationId: (id) => {
        setLocationId(id);
        setPumpId(null);
        setTankId(null);
      },
      setWindow,
      selectPump: setPumpId,
      selectTank: setTankId,
      clearSelections: () => {
        setPumpId(null);
        setTankId(null);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Ctx.Provider, { value, children });
  }
  function useKpiFilters() {
    const ctx = React.useContext(Ctx);
    if (!ctx) throw new Error("useKpiFilters must be used within KpiFiltersProvider");
    return ctx;
  }
  function Card(props) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...props, style: { ...props.style || {}, borderRadius: 12, border: "1px solid rgba(0,0,0,0.08)", boxShadow: "0 1px 2px rgba(0,0,0,0.04)" } });
  }
  function CardHeader(props) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...props, style: { ...props.style || {}, padding: 16, paddingBottom: 0 } });
  }
  function CardTitle(props) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { ...props, style: { ...props.style || {}, fontSize: 16, fontWeight: 600, margin: 0 } });
  }
  function CardContent(props) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...props, style: { ...props.style || {}, padding: 16 } });
  }
  function KPI({ label, value, sub }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "rounded-2xl shadow-sm", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { className: "pb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { className: "text-sm text-gray-500 font-medium", children: label }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl font-semibold", children: value }),
        sub && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-500 mt-1", children: sub })
      ] })
    ] });
  }
  const Button = ({ variant = "default", style, ...rest2 }) => {
    const base = {
      padding: "8px 12px",
      borderRadius: 10,
      border: "1px solid rgba(0,0,0,0.08)",
      cursor: "pointer",
      background: variant === "outline" ? "transparent" : "rgba(0,0,0,0.04)"
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { ...rest2, style: { ...base, ...style || {} } });
  };
  function Tabs({
    value,
    onChange,
    tabs
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2 border-b overflow-x-auto", children: tabs.map((t) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: () => onChange(t.id),
        className: `px-3 py-2 text-sm border-b-2 -mb-px ${value === t.id ? "border-gray-900 font-medium" : "border-transparent text-gray-500"}`,
        children: t.label
      },
      t.id
    )) });
  }
  function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for (f in e) e[f] && (n && (n += " "), n += f);
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
  }
  var get$4 = {};
  var isUnsafeProperty$2 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function isUnsafeProperty2(key) {
      return key === "__proto__";
    }
    exports3.isUnsafeProperty = isUnsafeProperty2;
  })(isUnsafeProperty$2);
  const isUnsafeProperty$1 = /* @__PURE__ */ getDefaultExportFromCjs(isUnsafeProperty$2);
  var isDeepKey$1 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function isDeepKey2(key) {
      switch (typeof key) {
        case "number":
        case "symbol": {
          return false;
        }
        case "string": {
          return key.includes(".") || key.includes("[") || key.includes("]");
        }
      }
    }
    exports3.isDeepKey = isDeepKey2;
  })(isDeepKey$1);
  const isDeepKey = /* @__PURE__ */ getDefaultExportFromCjs(isDeepKey$1);
  var toKey$1 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function toKey2(value) {
      var _a;
      if (typeof value === "string" || typeof value === "symbol") {
        return value;
      }
      if (Object.is((_a = value == null ? void 0 : value.valueOf) == null ? void 0 : _a.call(value), -0)) {
        return "-0";
      }
      return String(value);
    }
    exports3.toKey = toKey2;
  })(toKey$1);
  const toKey = /* @__PURE__ */ getDefaultExportFromCjs(toKey$1);
  var toPath$1 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function toPath2(deepKey) {
      const result = [];
      const length2 = deepKey.length;
      if (length2 === 0) {
        return result;
      }
      let index2 = 0;
      let key = "";
      let quoteChar = "";
      let bracket = false;
      if (deepKey.charCodeAt(0) === 46) {
        result.push("");
        index2++;
      }
      while (index2 < length2) {
        const char = deepKey[index2];
        if (quoteChar) {
          if (char === "\\" && index2 + 1 < length2) {
            index2++;
            key += deepKey[index2];
          } else if (char === quoteChar) {
            quoteChar = "";
          } else {
            key += char;
          }
        } else if (bracket) {
          if (char === '"' || char === "'") {
            quoteChar = char;
          } else if (char === "]") {
            bracket = false;
            result.push(key);
            key = "";
          } else {
            key += char;
          }
        } else {
          if (char === "[") {
            bracket = true;
            if (key) {
              result.push(key);
              key = "";
            }
          } else if (char === ".") {
            if (key) {
              result.push(key);
              key = "";
            }
          } else {
            key += char;
          }
        }
        index2++;
      }
      if (key) {
        result.push(key);
      }
      return result;
    }
    exports3.toPath = toPath2;
  })(toPath$1);
  const toPath = /* @__PURE__ */ getDefaultExportFromCjs(toPath$1);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const isUnsafeProperty2 = isUnsafeProperty$2;
    const isDeepKey2 = isDeepKey$1;
    const toKey2 = toKey$1;
    const toPath2 = toPath$1;
    function get2(object2, path2, defaultValue) {
      if (object2 == null) {
        return defaultValue;
      }
      switch (typeof path2) {
        case "string": {
          if (isUnsafeProperty2.isUnsafeProperty(path2)) {
            return defaultValue;
          }
          const result = object2[path2];
          if (result === void 0) {
            if (isDeepKey2.isDeepKey(path2)) {
              return get2(object2, toPath2.toPath(path2), defaultValue);
            } else {
              return defaultValue;
            }
          }
          return result;
        }
        case "number":
        case "symbol": {
          if (typeof path2 === "number") {
            path2 = toKey2.toKey(path2);
          }
          const result = object2[path2];
          if (result === void 0) {
            return defaultValue;
          }
          return result;
        }
        default: {
          if (Array.isArray(path2)) {
            return getWithPath(object2, path2, defaultValue);
          }
          if (Object.is(path2 == null ? void 0 : path2.valueOf(), -0)) {
            path2 = "-0";
          } else {
            path2 = String(path2);
          }
          if (isUnsafeProperty2.isUnsafeProperty(path2)) {
            return defaultValue;
          }
          const result = object2[path2];
          if (result === void 0) {
            return defaultValue;
          }
          return result;
        }
      }
    }
    function getWithPath(object2, path2, defaultValue) {
      if (path2.length === 0) {
        return defaultValue;
      }
      let current2 = object2;
      for (let index2 = 0; index2 < path2.length; index2++) {
        if (current2 == null) {
          return defaultValue;
        }
        if (isUnsafeProperty2.isUnsafeProperty(path2[index2])) {
          return defaultValue;
        }
        current2 = current2[path2[index2]];
      }
      if (current2 === void 0) {
        return defaultValue;
      }
      return current2;
    }
    exports3.get = get2;
  })(get$4);
  const get$3 = /* @__PURE__ */ getDefaultExportFromCjs(get$4);
  var get$1 = get$4.get;
  const get$2 = /* @__PURE__ */ getDefaultExportFromCjs(get$1);
  var reactIs$1 = { exports: {} };
  var reactIs_development = {};
  var typeOf_1;
  var isValidElementType$1;
  var isSuspenseList;
  var isSuspense;
  var isStrictMode;
  var isProfiler;
  var isPortal;
  var isMemo$1;
  var isLazy;
  var isFragment;
  var isForwardRef;
  var isElement;
  var isContextProvider;
  var isContextConsumer$1;
  var SuspenseList;
  var Suspense;
  var StrictMode;
  var Profiler;
  var Portal;
  var Memo$1;
  var Lazy;
  var Fragment;
  var ForwardRef$1;
  var Element;
  var ContextProvider;
  var ContextConsumer;
  "use strict";
  /**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  (function() {
    function typeOf2(object2) {
      if ("object" === typeof object2 && null !== object2) {
        var $$typeof = object2.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE2:
            switch (object2 = object2.type, object2) {
              case REACT_FRAGMENT_TYPE2:
              case REACT_PROFILER_TYPE2:
              case REACT_STRICT_MODE_TYPE2:
              case REACT_SUSPENSE_TYPE2:
              case REACT_SUSPENSE_LIST_TYPE2:
              case REACT_VIEW_TRANSITION_TYPE:
                return object2;
              default:
                switch (object2 = object2 && object2.$$typeof, object2) {
                  case REACT_CONTEXT_TYPE2:
                  case REACT_FORWARD_REF_TYPE2:
                  case REACT_LAZY_TYPE2:
                  case REACT_MEMO_TYPE2:
                    return object2;
                  case REACT_CONSUMER_TYPE2:
                    return object2;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE2:
            return $$typeof;
        }
      }
    }
    var REACT_ELEMENT_TYPE2 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE2 = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE2 = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE2 = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE2 = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE2 = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE2 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE2 = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE2 = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE2 = Symbol.for("react.memo"), REACT_LAZY_TYPE2 = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE2 = Symbol.for("react.client.reference");
    ContextConsumer = reactIs_development.ContextConsumer = REACT_CONSUMER_TYPE2;
    ContextProvider = reactIs_development.ContextProvider = REACT_CONTEXT_TYPE2;
    Element = reactIs_development.Element = REACT_ELEMENT_TYPE2;
    ForwardRef$1 = reactIs_development.ForwardRef = REACT_FORWARD_REF_TYPE2;
    Fragment = reactIs_development.Fragment = REACT_FRAGMENT_TYPE2;
    Lazy = reactIs_development.Lazy = REACT_LAZY_TYPE2;
    Memo$1 = reactIs_development.Memo = REACT_MEMO_TYPE2;
    Portal = reactIs_development.Portal = REACT_PORTAL_TYPE2;
    Profiler = reactIs_development.Profiler = REACT_PROFILER_TYPE2;
    StrictMode = reactIs_development.StrictMode = REACT_STRICT_MODE_TYPE2;
    Suspense = reactIs_development.Suspense = REACT_SUSPENSE_TYPE2;
    SuspenseList = reactIs_development.SuspenseList = REACT_SUSPENSE_LIST_TYPE2;
    isContextConsumer$1 = reactIs_development.isContextConsumer = function(object2) {
      return typeOf2(object2) === REACT_CONSUMER_TYPE2;
    };
    isContextProvider = reactIs_development.isContextProvider = function(object2) {
      return typeOf2(object2) === REACT_CONTEXT_TYPE2;
    };
    isElement = reactIs_development.isElement = function(object2) {
      return "object" === typeof object2 && null !== object2 && object2.$$typeof === REACT_ELEMENT_TYPE2;
    };
    isForwardRef = reactIs_development.isForwardRef = function(object2) {
      return typeOf2(object2) === REACT_FORWARD_REF_TYPE2;
    };
    isFragment = reactIs_development.isFragment = function(object2) {
      return typeOf2(object2) === REACT_FRAGMENT_TYPE2;
    };
    isLazy = reactIs_development.isLazy = function(object2) {
      return typeOf2(object2) === REACT_LAZY_TYPE2;
    };
    isMemo$1 = reactIs_development.isMemo = function(object2) {
      return typeOf2(object2) === REACT_MEMO_TYPE2;
    };
    isPortal = reactIs_development.isPortal = function(object2) {
      return typeOf2(object2) === REACT_PORTAL_TYPE2;
    };
    isProfiler = reactIs_development.isProfiler = function(object2) {
      return typeOf2(object2) === REACT_PROFILER_TYPE2;
    };
    isStrictMode = reactIs_development.isStrictMode = function(object2) {
      return typeOf2(object2) === REACT_STRICT_MODE_TYPE2;
    };
    isSuspense = reactIs_development.isSuspense = function(object2) {
      return typeOf2(object2) === REACT_SUSPENSE_TYPE2;
    };
    isSuspenseList = reactIs_development.isSuspenseList = function(object2) {
      return typeOf2(object2) === REACT_SUSPENSE_LIST_TYPE2;
    };
    isValidElementType$1 = reactIs_development.isValidElementType = function(type) {
      return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE2 || type === REACT_PROFILER_TYPE2 || type === REACT_STRICT_MODE_TYPE2 || type === REACT_SUSPENSE_TYPE2 || type === REACT_SUSPENSE_LIST_TYPE2 || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE2 || type.$$typeof === REACT_MEMO_TYPE2 || type.$$typeof === REACT_CONTEXT_TYPE2 || type.$$typeof === REACT_CONSUMER_TYPE2 || type.$$typeof === REACT_FORWARD_REF_TYPE2 || type.$$typeof === REACT_CLIENT_REFERENCE2 || void 0 !== type.getModuleId) ? true : false;
    };
    typeOf_1 = reactIs_development.typeOf = typeOf2;
  })();
  var reactIs = reactIs$1.exports;
  "use strict";
  if (false) {
    module.exports = require("./cjs/react-is.production.js");
  } else {
    reactIs$1.exports = reactIs_development;
  }
  var reactIsExports = reactIs$1.exports;
  const index$2 = /* @__PURE__ */ getDefaultExportFromCjs(reactIsExports);
  var mathSign = (value) => {
    if (value === 0) {
      return 0;
    }
    if (value > 0) {
      return 1;
    }
    return -1;
  };
  var isNan = (value) => {
    return typeof value == "number" && value != +value;
  };
  var isPercent = (value) => typeof value === "string" && value.indexOf("%") === value.length - 1;
  var isNumber = (value) => (typeof value === "number" || value instanceof Number) && !isNan(value);
  var isNumOrStr = (value) => isNumber(value) || typeof value === "string";
  var idCounter = 0;
  var uniqueId = (prefix2) => {
    var id = ++idCounter;
    return "".concat(prefix2 || "").concat(id);
  };
  var getPercentValue = function getPercentValue2(percent, totalValue) {
    var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var validate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (!isNumber(percent) && typeof percent !== "string") {
      return defaultValue;
    }
    var value;
    if (isPercent(percent)) {
      if (totalValue == null) {
        return defaultValue;
      }
      var index2 = percent.indexOf("%");
      value = totalValue * parseFloat(percent.slice(0, index2)) / 100;
    } else {
      value = +percent;
    }
    if (isNan(value)) {
      value = defaultValue;
    }
    if (validate && totalValue != null && value > totalValue) {
      value = totalValue;
    }
    return value;
  };
  var hasDuplicate = (ary2) => {
    if (!Array.isArray(ary2)) {
      return false;
    }
    var len = ary2.length;
    var cache = {};
    for (var i = 0; i < len; i++) {
      if (!cache[ary2[i]]) {
        cache[ary2[i]] = true;
      } else {
        return true;
      }
    }
    return false;
  };
  var interpolateNumber$2 = (numberA, numberB) => {
    if (isNumber(numberA) && isNumber(numberB)) {
      return (t) => numberA + t * (numberB - numberA);
    }
    return () => numberB;
  };
  function interpolate$1(start, end, t) {
    if (isNumber(start) && isNumber(end)) {
      return start + t * (end - start);
    }
    return end;
  }
  function findEntryInArray(ary2, specifiedKey, specifiedValue) {
    if (!ary2 || !ary2.length) {
      return void 0;
    }
    return ary2.find((entry) => entry && (typeof specifiedKey === "function" ? specifiedKey(entry) : get$2(entry, specifiedKey)) === specifiedValue);
  }
  var getLinearRegression = (data) => {
    if (!data || !data.length) {
      return null;
    }
    var len = data.length;
    var xsum = 0;
    var ysum = 0;
    var xysum = 0;
    var xxsum = 0;
    var xmin = Infinity;
    var xmax = -Infinity;
    var xcurrent = 0;
    var ycurrent = 0;
    for (var i = 0; i < len; i++) {
      xcurrent = data[i].cx || 0;
      ycurrent = data[i].cy || 0;
      xsum += xcurrent;
      ysum += ycurrent;
      xysum += xcurrent * ycurrent;
      xxsum += xcurrent * xcurrent;
      xmin = Math.min(xmin, xcurrent);
      xmax = Math.max(xmax, xcurrent);
    }
    var a2 = len * xxsum !== xsum * xsum ? (len * xysum - xsum * ysum) / (len * xxsum - xsum * xsum) : 0;
    return {
      xmin,
      xmax,
      a: a2,
      b: (ysum - a2 * xsum) / len
    };
  };
  var isNullish = (value) => {
    return value === null || typeof value === "undefined";
  };
  var upperFirst$1 = (value) => {
    if (isNullish(value)) {
      return value;
    }
    return "".concat(value.charAt(0).toUpperCase()).concat(value.slice(1));
  };
  var EventKeys = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"];
  function isEventKey(key) {
    if (typeof key !== "string") {
      return false;
    }
    var allowedEventKeys = EventKeys;
    return allowedEventKeys.includes(key);
  }
  function excludeEventProps(obj) {
    var filteredEntries = Object.entries(obj).filter((_ref2) => {
      var [key] = _ref2;
      return !isEventKey(key);
    });
    return Object.fromEntries(filteredEntries);
  }
  var SVGContainerPropKeys = ["viewBox", "children"];
  var PolyElementKeys = ["points", "pathLength"];
  var FilteredElementKeyMap = {
    svg: SVGContainerPropKeys,
    polygon: PolyElementKeys,
    polyline: PolyElementKeys
  };
  var adaptEventHandlers = (props, newHandler) => {
    if (!props || typeof props === "function" || typeof props === "boolean") {
      return null;
    }
    var inputProps = props;
    if (/* @__PURE__ */ React.isValidElement(props)) {
      inputProps = props.props;
    }
    if (typeof inputProps !== "object" && typeof inputProps !== "function") {
      return null;
    }
    var out = {};
    Object.keys(inputProps).forEach((key) => {
      if (isEventKey(key)) {
        out[key] = newHandler || ((e) => inputProps[key](inputProps, e));
      }
    });
    return out;
  };
  var getEventHandlerOfChild = (originalHandler, data, index2) => (e) => {
    originalHandler(data, index2, e);
    return null;
  };
  var adaptEventsOfChild = (props, data, index2) => {
    if (props === null || typeof props !== "object" && typeof props !== "function") {
      return null;
    }
    var out = null;
    Object.keys(props).forEach((key) => {
      var item = props[key];
      if (isEventKey(key) && typeof item === "function") {
        if (!out) out = {};
        out[key] = getEventHandlerOfChild(item, data, index2);
      }
    });
    return out;
  };
  var SVGElementPropKeys = [
    "aria-activedescendant",
    "aria-atomic",
    "aria-autocomplete",
    "aria-busy",
    "aria-checked",
    "aria-colcount",
    "aria-colindex",
    "aria-colspan",
    "aria-controls",
    "aria-current",
    "aria-describedby",
    "aria-details",
    "aria-disabled",
    "aria-errormessage",
    "aria-expanded",
    "aria-flowto",
    "aria-haspopup",
    "aria-hidden",
    "aria-invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-level",
    "aria-live",
    "aria-modal",
    "aria-multiline",
    "aria-multiselectable",
    "aria-orientation",
    "aria-owns",
    "aria-placeholder",
    "aria-posinset",
    "aria-pressed",
    "aria-readonly",
    "aria-relevant",
    "aria-required",
    "aria-roledescription",
    "aria-rowcount",
    "aria-rowindex",
    "aria-rowspan",
    "aria-selected",
    "aria-setsize",
    "aria-sort",
    "aria-valuemax",
    "aria-valuemin",
    "aria-valuenow",
    "aria-valuetext",
    "className",
    "color",
    "height",
    "id",
    "lang",
    "max",
    "media",
    "method",
    "min",
    "name",
    "style",
    /*
     * removed 'type' SVGElementPropKey because we do not currently use any SVG elements
     * that can use it, and it conflicts with the recharts prop 'type'
     * https://github.com/recharts/recharts/pull/3327
     * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type
     */
    // 'type',
    "target",
    "width",
    "role",
    "tabIndex",
    "accentHeight",
    "accumulate",
    "additive",
    "alignmentBaseline",
    "allowReorder",
    "alphabetic",
    "amplitude",
    "arabicForm",
    "ascent",
    "attributeName",
    "attributeType",
    "autoReverse",
    "azimuth",
    "baseFrequency",
    "baselineShift",
    "baseProfile",
    "bbox",
    "begin",
    "bias",
    "by",
    "calcMode",
    "capHeight",
    "clip",
    "clipPath",
    "clipPathUnits",
    "clipRule",
    "colorInterpolation",
    "colorInterpolationFilters",
    "colorProfile",
    "colorRendering",
    "contentScriptType",
    "contentStyleType",
    "cursor",
    "cx",
    "cy",
    "d",
    "decelerate",
    "descent",
    "diffuseConstant",
    "direction",
    "display",
    "divisor",
    "dominantBaseline",
    "dur",
    "dx",
    "dy",
    "edgeMode",
    "elevation",
    "enableBackground",
    "end",
    "exponent",
    "externalResourcesRequired",
    "fill",
    "fillOpacity",
    "fillRule",
    "filter",
    "filterRes",
    "filterUnits",
    "floodColor",
    "floodOpacity",
    "focusable",
    "fontFamily",
    "fontSize",
    "fontSizeAdjust",
    "fontStretch",
    "fontStyle",
    "fontVariant",
    "fontWeight",
    "format",
    "from",
    "fx",
    "fy",
    "g1",
    "g2",
    "glyphName",
    "glyphOrientationHorizontal",
    "glyphOrientationVertical",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "hanging",
    "horizAdvX",
    "horizOriginX",
    "href",
    "ideographic",
    "imageRendering",
    "in2",
    "in",
    "intercept",
    "k1",
    "k2",
    "k3",
    "k4",
    "k",
    "kernelMatrix",
    "kernelUnitLength",
    "kerning",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "letterSpacing",
    "lightingColor",
    "limitingConeAngle",
    "local",
    "markerEnd",
    "markerHeight",
    "markerMid",
    "markerStart",
    "markerUnits",
    "markerWidth",
    "mask",
    "maskContentUnits",
    "maskUnits",
    "mathematical",
    "mode",
    "numOctaves",
    "offset",
    "opacity",
    "operator",
    "order",
    "orient",
    "orientation",
    "origin",
    "overflow",
    "overlinePosition",
    "overlineThickness",
    "paintOrder",
    "panose1",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointerEvents",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "r",
    "radius",
    "refX",
    "refY",
    "renderingIntent",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "restart",
    "result",
    "rotate",
    "rx",
    "ry",
    "seed",
    "shapeRendering",
    "slope",
    "spacing",
    "specularConstant",
    "specularExponent",
    "speed",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stemh",
    "stemv",
    "stitchTiles",
    "stopColor",
    "stopOpacity",
    "strikethroughPosition",
    "strikethroughThickness",
    "string",
    "stroke",
    "strokeDasharray",
    "strokeDashoffset",
    "strokeLinecap",
    "strokeLinejoin",
    "strokeMiterlimit",
    "strokeOpacity",
    "strokeWidth",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textAnchor",
    "textDecoration",
    "textLength",
    "textRendering",
    "to",
    "transform",
    "u1",
    "u2",
    "underlinePosition",
    "underlineThickness",
    "unicode",
    "unicodeBidi",
    "unicodeRange",
    "unitsPerEm",
    "vAlphabetic",
    "values",
    "vectorEffect",
    "version",
    "vertAdvY",
    "vertOriginX",
    "vertOriginY",
    "vHanging",
    "vIdeographic",
    "viewTarget",
    "visibility",
    "vMathematical",
    "widths",
    "wordSpacing",
    "writingMode",
    "x1",
    "x2",
    "x",
    "xChannelSelector",
    "xHeight",
    "xlinkActuate",
    "xlinkArcrole",
    "xlinkHref",
    "xlinkRole",
    "xlinkShow",
    "xlinkTitle",
    "xlinkType",
    "xmlBase",
    "xmlLang",
    "xmlns",
    "xmlnsXlink",
    "xmlSpace",
    "y1",
    "y2",
    "y",
    "yChannelSelector",
    "z",
    "zoomAndPan",
    "ref",
    "key",
    "angle"
  ];
  function isSvgElementPropKey(key) {
    if (typeof key !== "string") {
      return false;
    }
    var allowedSvgKeys = SVGElementPropKeys;
    return allowedSvgKeys.includes(key);
  }
  function svgPropertiesNoEvents(obj) {
    var filteredEntries = Object.entries(obj).filter((_ref2) => {
      var [key] = _ref2;
      return isSvgElementPropKey(key);
    });
    return Object.fromEntries(filteredEntries);
  }
  var SCALE_TYPES = ["auto", "linear", "pow", "sqrt", "log", "identity", "time", "band", "point", "ordinal", "quantile", "quantize", "utc", "sequential", "threshold"];
  var getDisplayName = (Comp) => {
    if (typeof Comp === "string") {
      return Comp;
    }
    if (!Comp) {
      return "";
    }
    return Comp.displayName || Comp.name || "Component";
  };
  var lastChildren = null;
  var lastResult = null;
  var toArray$2 = (children) => {
    if (children === lastChildren && Array.isArray(lastResult)) {
      return lastResult;
    }
    var result = [];
    React.Children.forEach(children, (child) => {
      if (isNullish(child)) return;
      if (reactIsExports.isFragment(child)) {
        result = result.concat(toArray$2(child.props.children));
      } else {
        result.push(child);
      }
    });
    lastResult = result;
    lastChildren = children;
    return result;
  };
  function findAllByType(children, type) {
    var result = [];
    var types = [];
    if (Array.isArray(type)) {
      types = type.map((t) => getDisplayName(t));
    } else {
      types = [getDisplayName(type)];
    }
    toArray$2(children).forEach((child) => {
      var childType = get$2(child, "type.displayName") || get$2(child, "type.name");
      if (types.indexOf(childType) !== -1) {
        result.push(child);
      }
    });
    return result;
  }
  var isClipDot = (dot) => {
    if (dot && typeof dot === "object" && "clipDot" in dot) {
      return Boolean(dot.clipDot);
    }
    return true;
  };
  var isValidSpreadableProp = (property2, key, includeEvents, svgElementType) => {
    var _ref2;
    if (typeof key === "symbol" || typeof key === "number") {
      return true;
    }
    var matchingElementTypeKeys = (_ref2 = svgElementType && (FilteredElementKeyMap === null || FilteredElementKeyMap === void 0 ? void 0 : FilteredElementKeyMap[svgElementType])) !== null && _ref2 !== void 0 ? _ref2 : [];
    var isDataAttribute = key.startsWith("data-");
    var isSpecificSvgAttribute = typeof property2 !== "function" && (Boolean(svgElementType) && matchingElementTypeKeys.includes(key) || isSvgElementPropKey(key));
    var isEventAttribute = Boolean(includeEvents) && isEventKey(key);
    return isDataAttribute || isSpecificSvgAttribute || isEventAttribute;
  };
  var filterProps = (props, includeEvents, svgElementType) => {
    if (!props || typeof props === "function" || typeof props === "boolean") {
      return null;
    }
    var inputProps = props;
    if (/* @__PURE__ */ React.isValidElement(props)) {
      inputProps = props.props;
    }
    if (typeof inputProps !== "object" && typeof inputProps !== "function") {
      return null;
    }
    var out = {};
    Object.keys(inputProps).forEach((key) => {
      var _inputProps;
      if (isValidSpreadableProp((_inputProps = inputProps) === null || _inputProps === void 0 ? void 0 : _inputProps[key], key, includeEvents, svgElementType)) {
        out[key] = inputProps[key];
      }
    });
    return out;
  };
  var _excluded$A = ["children", "width", "height", "viewBox", "className", "style", "title", "desc"];
  function _extends$L() {
    return _extends$L = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$L.apply(null, arguments);
  }
  function _objectWithoutProperties$A(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$A(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$A(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var Surface = /* @__PURE__ */ React.forwardRef((props, ref) => {
    var {
      children,
      width,
      height,
      viewBox,
      className,
      style,
      title,
      desc
    } = props, others = _objectWithoutProperties$A(props, _excluded$A);
    var svgView = viewBox || {
      width,
      height,
      x: 0,
      y: 0
    };
    var layerClass = clsx("recharts-surface", className);
    return /* @__PURE__ */ React__namespace.createElement("svg", _extends$L({}, filterProps(others, true, "svg"), {
      className: layerClass,
      width,
      height,
      style,
      viewBox: "".concat(svgView.x, " ").concat(svgView.y, " ").concat(svgView.width, " ").concat(svgView.height),
      ref
    }), /* @__PURE__ */ React__namespace.createElement("title", null, title), /* @__PURE__ */ React__namespace.createElement("desc", null, desc), children);
  });
  var _excluded$z = ["children", "className"];
  function _extends$K() {
    return _extends$K = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$K.apply(null, arguments);
  }
  function _objectWithoutProperties$z(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$z(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$z(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var Layer = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
    var {
      children,
      className
    } = props, others = _objectWithoutProperties$z(props, _excluded$z);
    var layerClass = clsx("recharts-layer", className);
    return /* @__PURE__ */ React__namespace.createElement("g", _extends$K({
      className: layerClass
    }, filterProps(others, true), {
      ref
    }), children);
  });
  var LegendPortalContext = /* @__PURE__ */ React.createContext(null);
  var useLegendPortal = () => React.useContext(LegendPortalContext);
  function constant$2(x2) {
    return function constant2() {
      return x2;
    };
  }
  const abs = Math.abs;
  const atan2 = Math.atan2;
  const cos = Math.cos;
  const max$1 = Math.max;
  const min$1 = Math.min;
  const sin = Math.sin;
  const sqrt$1 = Math.sqrt;
  const epsilon$1 = 1e-12;
  const pi$1 = Math.PI;
  const halfPi = pi$1 / 2;
  const tau$1 = 2 * pi$1;
  function acos(x2) {
    return x2 > 1 ? 0 : x2 < -1 ? pi$1 : Math.acos(x2);
  }
  function asin(x2) {
    return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
  }
  const pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
  function append(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += arguments[i] + strings[i];
    }
  }
  function appendRound(digits) {
    let d = Math.floor(digits);
    if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
    if (d > 15) return append;
    const k2 = 10 ** d;
    return function(strings) {
      this._ += strings[0];
      for (let i = 1, n = strings.length; i < n; ++i) {
        this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
      }
    };
  }
  class Path {
    constructor(digits) {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null;
      this._ = "";
      this._append = digits == null ? append : appendRound(digits);
    }
    moveTo(x2, y2) {
      this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
    }
    closePath() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._append`Z`;
      }
    }
    lineTo(x2, y2) {
      this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
    }
    quadraticCurveTo(x1, y1, x2, y2) {
      this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
    }
    bezierCurveTo(x1, y1, x2, y2, x3, y3) {
      this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
    }
    arcTo(x1, y1, x2, y2, r2) {
      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r2 = +r2;
      if (r2 < 0) throw new Error(`negative radius: ${r2}`);
      let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
      if (this._x1 === null) {
        this._append`M${this._x1 = x1},${this._y1 = y1}`;
      } else if (!(l01_2 > epsilon)) ;
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r2) {
        this._append`L${this._x1 = x1},${this._y1 = y1}`;
      } else {
        let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
        if (Math.abs(t01 - 1) > epsilon) {
          this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
        }
        this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
      }
    }
    arc(x2, y2, r2, a0, a1, ccw) {
      x2 = +x2, y2 = +y2, r2 = +r2, ccw = !!ccw;
      if (r2 < 0) throw new Error(`negative radius: ${r2}`);
      let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
      if (this._x1 === null) {
        this._append`M${x0},${y0}`;
      } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
        this._append`L${x0},${y0}`;
      }
      if (!r2) return;
      if (da < 0) da = da % tau + tau;
      if (da > tauEpsilon) {
        this._append`A${r2},${r2},0,1,${cw},${x2 - dx},${y2 - dy}A${r2},${r2},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
      } else if (da > epsilon) {
        this._append`A${r2},${r2},0,${+(da >= pi)},${cw},${this._x1 = x2 + r2 * Math.cos(a1)},${this._y1 = y2 + r2 * Math.sin(a1)}`;
      }
    }
    rect(x2, y2, w, h) {
      this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h}h${-w}Z`;
    }
    toString() {
      return this._;
    }
  }
  function path() {
    return new Path();
  }
  path.prototype = Path.prototype;
  function pathRound(digits = 3) {
    return new Path(+digits);
  }
  function withPath(shape) {
    let digits = 3;
    shape.digits = function(_) {
      if (!arguments.length) return digits;
      if (_ == null) {
        digits = null;
      } else {
        const d = Math.floor(_);
        if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
        digits = d;
      }
      return shape;
    };
    return () => new Path(digits);
  }
  function arcInnerRadius(d) {
    return d.innerRadius;
  }
  function arcOuterRadius(d) {
    return d.outerRadius;
  }
  function arcStartAngle(d) {
    return d.startAngle;
  }
  function arcEndAngle(d) {
    return d.endAngle;
  }
  function arcPadAngle(d) {
    return d && d.padAngle;
  }
  function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
    if (t * t < epsilon$1) return;
    t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
    return [x0 + t * x10, y0 + t * y10];
  }
  function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
    var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt$1(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r2 = r1 - rc, D2 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt$1(max$1(0, r2 * r2 * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d) / d2, cy0 = (-D2 * dx - dy * d) / d2, cx1 = (D2 * dy + dx * d) / d2, cy1 = (-D2 * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return {
      cx: cx0,
      cy: cy0,
      x01: -ox,
      y01: -oy,
      x11: cx0 * (r1 / r2 - 1),
      y11: cy0 * (r1 / r2 - 1)
    };
  }
  function arc() {
    var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant$2(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc2);
    function arc2() {
      var buffer, r2, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw = a1 > a0;
      if (!context) context = buffer = path2();
      if (r1 < r0) r2 = r1, r1 = r0, r0 = r2;
      if (!(r1 > epsilon$1)) context.moveTo(0, 0);
      else if (da > tau$1 - epsilon$1) {
        context.moveTo(r1 * cos(a0), r1 * sin(a0));
        context.arc(0, 0, r1, a0, a1, !cw);
        if (r0 > epsilon$1) {
          context.moveTo(r0 * cos(a1), r0 * sin(a1));
          context.arc(0, 0, r0, a1, a0, cw);
        }
      } else {
        var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon$1 && (padRadius ? +padRadius.apply(this, arguments) : sqrt$1(r0 * r0 + r1 * r1)), rc = min$1(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
        if (rp > epsilon$1) {
          var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
          if ((da0 -= p0 * 2) > epsilon$1) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
          else da0 = 0, a00 = a10 = (a0 + a1) / 2;
          if ((da1 -= p1 * 2) > epsilon$1) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
          else da1 = 0, a01 = a11 = (a0 + a1) / 2;
        }
        var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
        if (rc > epsilon$1) {
          var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
          if (da < pi$1) {
            if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
              var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt$1(ax * ax + ay * ay) * sqrt$1(bx * bx + by * by))) / 2), lc = sqrt$1(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = min$1(rc, (r0 - lc) / (kc - 1));
              rc1 = min$1(rc, (r1 - lc) / (kc + 1));
            } else {
              rc0 = rc1 = 0;
            }
          }
        }
        if (!(da1 > epsilon$1)) context.moveTo(x01, y01);
        else if (rc1 > epsilon$1) {
          t02 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
          t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
          context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
          if (rc1 < rc) context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
          else {
            context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
            context.arc(0, 0, r1, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), !cw);
            context.arc(t12.cx, t12.cy, rc1, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
          }
        } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
        if (!(r0 > epsilon$1) || !(da0 > epsilon$1)) context.lineTo(x10, y10);
        else if (rc0 > epsilon$1) {
          t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
          t12 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
          context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
          if (rc0 < rc) context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
          else {
            context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
            context.arc(0, 0, r0, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), cw);
            context.arc(t12.cx, t12.cy, rc0, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
          }
        } else context.arc(0, 0, r0, a10, a00, cw);
      }
      context.closePath();
      if (buffer) return context = null, buffer + "" || null;
    }
    arc2.centroid = function() {
      var r2 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$1 / 2;
      return [cos(a2) * r2, sin(a2) * r2];
    };
    arc2.innerRadius = function(_) {
      return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$2(+_), arc2) : innerRadius;
    };
    arc2.outerRadius = function(_) {
      return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$2(+_), arc2) : outerRadius;
    };
    arc2.cornerRadius = function(_) {
      return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$2(+_), arc2) : cornerRadius;
    };
    arc2.padRadius = function(_) {
      return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), arc2) : padRadius;
    };
    arc2.startAngle = function(_) {
      return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$2(+_), arc2) : startAngle;
    };
    arc2.endAngle = function(_) {
      return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$2(+_), arc2) : endAngle;
    };
    arc2.padAngle = function(_) {
      return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$2(+_), arc2) : padAngle;
    };
    arc2.context = function(_) {
      return arguments.length ? (context = _ == null ? null : _, arc2) : context;
    };
    return arc2;
  }
  var slice$1 = Array.prototype.slice;
  function array$2(x2) {
    return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
  }
  function Linear(context) {
    this._context = context;
  }
  Linear.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
        default:
          this._context.lineTo(x2, y2);
          break;
      }
    }
  };
  function curveLinear(context) {
    return new Linear(context);
  }
  function x(p) {
    return p[0];
  }
  function y(p) {
    return p[1];
  }
  function shapeLine(x$1, y$1) {
    var defined2 = constant$2(true), context = null, curve = curveLinear, output = null, path2 = withPath(line);
    x$1 = typeof x$1 === "function" ? x$1 : x$1 === void 0 ? x : constant$2(x$1);
    y$1 = typeof y$1 === "function" ? y$1 : y$1 === void 0 ? y : constant$2(y$1);
    function line(data) {
      var i, n = (data = array$2(data)).length, d, defined0 = false, buffer;
      if (context == null) output = curve(buffer = path2());
      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined2(d = data[i], i, data)) === defined0) {
          if (defined0 = !defined0) output.lineStart();
          else output.lineEnd();
        }
        if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
      }
      if (buffer) return output = null, buffer + "" || null;
    }
    line.x = function(_) {
      return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$2(+_), line) : x$1;
    };
    line.y = function(_) {
      return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$2(+_), line) : y$1;
    };
    line.defined = function(_) {
      return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant$2(!!_), line) : defined2;
    };
    line.curve = function(_) {
      return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
    };
    line.context = function(_) {
      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
    };
    return line;
  }
  function shapeArea(x0, y0, y1) {
    var x1 = null, defined2 = constant$2(true), context = null, curve = curveLinear, output = null, path2 = withPath(area);
    x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x : constant$2(+x0);
    y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant$2(0) : constant$2(+y0);
    y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant$2(+y1);
    function area(data) {
      var i, j, k2, n = (data = array$2(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
      if (context == null) output = curve(buffer = path2());
      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined2(d = data[i], i, data)) === defined0) {
          if (defined0 = !defined0) {
            j = i;
            output.areaStart();
            output.lineStart();
          } else {
            output.lineEnd();
            output.lineStart();
            for (k2 = i - 1; k2 >= j; --k2) {
              output.point(x0z[k2], y0z[k2]);
            }
            output.lineEnd();
            output.areaEnd();
          }
        }
        if (defined0) {
          x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
          output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
        }
      }
      if (buffer) return output = null, buffer + "" || null;
    }
    function arealine() {
      return shapeLine().defined(defined2).curve(curve).context(context);
    }
    area.x = function(_) {
      return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$2(+_), x1 = null, area) : x0;
    };
    area.x0 = function(_) {
      return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$2(+_), area) : x0;
    };
    area.x1 = function(_) {
      return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), area) : x1;
    };
    area.y = function(_) {
      return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$2(+_), y1 = null, area) : y0;
    };
    area.y0 = function(_) {
      return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$2(+_), area) : y0;
    };
    area.y1 = function(_) {
      return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), area) : y1;
    };
    area.lineX0 = area.lineY0 = function() {
      return arealine().x(x0).y(y0);
    };
    area.lineY1 = function() {
      return arealine().x(x0).y(y1);
    };
    area.lineX1 = function() {
      return arealine().x(x1).y(y0);
    };
    area.defined = function(_) {
      return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant$2(!!_), area) : defined2;
    };
    area.curve = function(_) {
      return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
    };
    area.context = function(_) {
      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
    };
    return area;
  }
  function descending$2(a2, b) {
    return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
  }
  function identity$9(d) {
    return d;
  }
  function pie() {
    var value = identity$9, sortValues = descending$2, sort2 = null, startAngle = constant$2(0), endAngle = constant$2(tau$1), padAngle = constant$2(0);
    function pie2(data) {
      var i, n = (data = array$2(data)).length, j, k2, sum2 = 0, index2 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau$1, Math.max(-tau$1, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
      for (i = 0; i < n; ++i) {
        if ((v = arcs[index2[i] = i] = +value(data[i], i, data)) > 0) {
          sum2 += v;
        }
      }
      if (sortValues != null) index2.sort(function(i2, j2) {
        return sortValues(arcs[i2], arcs[j2]);
      });
      else if (sort2 != null) index2.sort(function(i2, j2) {
        return sort2(data[i2], data[j2]);
      });
      for (i = 0, k2 = sum2 ? (da - n * pa) / sum2 : 0; i < n; ++i, a0 = a1) {
        j = index2[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k2 : 0) + pa, arcs[j] = {
          data: data[j],
          index: i,
          value: v,
          startAngle: a0,
          endAngle: a1,
          padAngle: p
        };
      }
      return arcs;
    }
    pie2.value = function(_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant$2(+_), pie2) : value;
    };
    pie2.sortValues = function(_) {
      return arguments.length ? (sortValues = _, sort2 = null, pie2) : sortValues;
    };
    pie2.sort = function(_) {
      return arguments.length ? (sort2 = _, sortValues = null, pie2) : sort2;
    };
    pie2.startAngle = function(_) {
      return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$2(+_), pie2) : startAngle;
    };
    pie2.endAngle = function(_) {
      return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$2(+_), pie2) : endAngle;
    };
    pie2.padAngle = function(_) {
      return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$2(+_), pie2) : padAngle;
    };
    return pie2;
  }
  var curveRadialLinear = curveRadial(curveLinear);
  function Radial(curve) {
    this._curve = curve;
  }
  Radial.prototype = {
    areaStart: function() {
      this._curve.areaStart();
    },
    areaEnd: function() {
      this._curve.areaEnd();
    },
    lineStart: function() {
      this._curve.lineStart();
    },
    lineEnd: function() {
      this._curve.lineEnd();
    },
    point: function(a2, r2) {
      this._curve.point(r2 * Math.sin(a2), r2 * -Math.cos(a2));
    }
  };
  function curveRadial(curve) {
    function radial2(context) {
      return new Radial(curve(context));
    }
    radial2._curve = curve;
    return radial2;
  }
  function lineRadial(l) {
    var c2 = l.curve;
    l.angle = l.x, delete l.x;
    l.radius = l.y, delete l.y;
    l.curve = function(_) {
      return arguments.length ? c2(curveRadial(_)) : c2()._curve;
    };
    return l;
  }
  function lineRadial$1() {
    return lineRadial(shapeLine().curve(curveRadialLinear));
  }
  function areaRadial() {
    var a2 = shapeArea().curve(curveRadialLinear), c2 = a2.curve, x0 = a2.lineX0, x1 = a2.lineX1, y0 = a2.lineY0, y1 = a2.lineY1;
    a2.angle = a2.x, delete a2.x;
    a2.startAngle = a2.x0, delete a2.x0;
    a2.endAngle = a2.x1, delete a2.x1;
    a2.radius = a2.y, delete a2.y;
    a2.innerRadius = a2.y0, delete a2.y0;
    a2.outerRadius = a2.y1, delete a2.y1;
    a2.lineStartAngle = function() {
      return lineRadial(x0());
    }, delete a2.lineX0;
    a2.lineEndAngle = function() {
      return lineRadial(x1());
    }, delete a2.lineX1;
    a2.lineInnerRadius = function() {
      return lineRadial(y0());
    }, delete a2.lineY0;
    a2.lineOuterRadius = function() {
      return lineRadial(y1());
    }, delete a2.lineY1;
    a2.curve = function(_) {
      return arguments.length ? c2(curveRadial(_)) : c2()._curve;
    };
    return a2;
  }
  function pointRadial(x2, y2) {
    return [(y2 = +y2) * Math.cos(x2 -= Math.PI / 2), y2 * Math.sin(x2)];
  }
  class Bump {
    constructor(context, x2) {
      this._context = context;
      this._x = x2;
    }
    areaStart() {
      this._line = 0;
    }
    areaEnd() {
      this._line = NaN;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    }
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0: {
          this._point = 1;
          if (this._line) this._context.lineTo(x2, y2);
          else this._context.moveTo(x2, y2);
          break;
        }
        case 1:
          this._point = 2;
        default: {
          if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x2) / 2, this._y0, this._x0, y2, x2, y2);
          else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x2, this._y0, x2, y2);
          break;
        }
      }
      this._x0 = x2, this._y0 = y2;
    }
  }
  class BumpRadial {
    constructor(context) {
      this._context = context;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
    }
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      if (this._point === 0) {
        this._point = 1;
      } else {
        const p0 = pointRadial(this._x0, this._y0);
        const p1 = pointRadial(this._x0, this._y0 = (this._y0 + y2) / 2);
        const p2 = pointRadial(x2, this._y0);
        const p3 = pointRadial(x2, y2);
        this._context.moveTo(...p0);
        this._context.bezierCurveTo(...p1, ...p2, ...p3);
      }
      this._x0 = x2, this._y0 = y2;
    }
  }
  function bumpX(context) {
    return new Bump(context, true);
  }
  function bumpY(context) {
    return new Bump(context, false);
  }
  function bumpRadial(context) {
    return new BumpRadial(context);
  }
  function linkSource(d) {
    return d.source;
  }
  function linkTarget(d) {
    return d.target;
  }
  function link(curve) {
    let source = linkSource, target = linkTarget, x$1 = x, y$1 = y, context = null, output = null, path2 = withPath(link2);
    function link2() {
      let buffer;
      const argv = slice$1.call(arguments);
      const s2 = source.apply(this, argv);
      const t = target.apply(this, argv);
      if (context == null) output = curve(buffer = path2());
      output.lineStart();
      argv[0] = s2, output.point(+x$1.apply(this, argv), +y$1.apply(this, argv));
      argv[0] = t, output.point(+x$1.apply(this, argv), +y$1.apply(this, argv));
      output.lineEnd();
      if (buffer) return output = null, buffer + "" || null;
    }
    link2.source = function(_) {
      return arguments.length ? (source = _, link2) : source;
    };
    link2.target = function(_) {
      return arguments.length ? (target = _, link2) : target;
    };
    link2.x = function(_) {
      return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$2(+_), link2) : x$1;
    };
    link2.y = function(_) {
      return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$2(+_), link2) : y$1;
    };
    link2.context = function(_) {
      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link2) : context;
    };
    return link2;
  }
  function linkHorizontal() {
    return link(bumpX);
  }
  function linkVertical() {
    return link(bumpY);
  }
  function linkRadial() {
    const l = link(bumpRadial);
    l.angle = l.x, delete l.x;
    l.radius = l.y, delete l.y;
    return l;
  }
  const sqrt3$2 = sqrt$1(3);
  const asterisk = {
    draw(context, size) {
      const r2 = sqrt$1(size + min$1(size / 28, 0.75)) * 0.59436;
      const t = r2 / 2;
      const u = t * sqrt3$2;
      context.moveTo(0, r2);
      context.lineTo(0, -r2);
      context.moveTo(-u, -t);
      context.lineTo(u, t);
      context.moveTo(-u, t);
      context.lineTo(u, -t);
    }
  };
  const symbolCircle = {
    draw(context, size) {
      const r2 = sqrt$1(size / pi$1);
      context.moveTo(r2, 0);
      context.arc(0, 0, r2, 0, tau$1);
    }
  };
  const symbolCross = {
    draw(context, size) {
      const r2 = sqrt$1(size / 5) / 2;
      context.moveTo(-3 * r2, -r2);
      context.lineTo(-r2, -r2);
      context.lineTo(-r2, -3 * r2);
      context.lineTo(r2, -3 * r2);
      context.lineTo(r2, -r2);
      context.lineTo(3 * r2, -r2);
      context.lineTo(3 * r2, r2);
      context.lineTo(r2, r2);
      context.lineTo(r2, 3 * r2);
      context.lineTo(-r2, 3 * r2);
      context.lineTo(-r2, r2);
      context.lineTo(-3 * r2, r2);
      context.closePath();
    }
  };
  const tan30 = sqrt$1(1 / 3);
  const tan30_2 = tan30 * 2;
  const symbolDiamond = {
    draw(context, size) {
      const y2 = sqrt$1(size / tan30_2);
      const x2 = y2 * tan30;
      context.moveTo(0, -y2);
      context.lineTo(x2, 0);
      context.lineTo(0, y2);
      context.lineTo(-x2, 0);
      context.closePath();
    }
  };
  const diamond2 = {
    draw(context, size) {
      const r2 = sqrt$1(size) * 0.62625;
      context.moveTo(0, -r2);
      context.lineTo(r2, 0);
      context.lineTo(0, r2);
      context.lineTo(-r2, 0);
      context.closePath();
    }
  };
  const plus = {
    draw(context, size) {
      const r2 = sqrt$1(size - min$1(size / 7, 2)) * 0.87559;
      context.moveTo(-r2, 0);
      context.lineTo(r2, 0);
      context.moveTo(0, r2);
      context.lineTo(0, -r2);
    }
  };
  const symbolSquare = {
    draw(context, size) {
      const w = sqrt$1(size);
      const x2 = -w / 2;
      context.rect(x2, x2, w, w);
    }
  };
  const square2 = {
    draw(context, size) {
      const r2 = sqrt$1(size) * 0.4431;
      context.moveTo(r2, r2);
      context.lineTo(r2, -r2);
      context.lineTo(-r2, -r2);
      context.lineTo(-r2, r2);
      context.closePath();
    }
  };
  const ka = 0.8908130915292852;
  const kr = sin(pi$1 / 10) / sin(7 * pi$1 / 10);
  const kx = sin(tau$1 / 10) * kr;
  const ky = -cos(tau$1 / 10) * kr;
  const symbolStar = {
    draw(context, size) {
      const r2 = sqrt$1(size * ka);
      const x2 = kx * r2;
      const y2 = ky * r2;
      context.moveTo(0, -r2);
      context.lineTo(x2, y2);
      for (let i = 1; i < 5; ++i) {
        const a2 = tau$1 * i / 5;
        const c2 = cos(a2);
        const s2 = sin(a2);
        context.lineTo(s2 * r2, -c2 * r2);
        context.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
      }
      context.closePath();
    }
  };
  const sqrt3$1 = sqrt$1(3);
  const symbolTriangle = {
    draw(context, size) {
      const y2 = -sqrt$1(size / (sqrt3$1 * 3));
      context.moveTo(0, y2 * 2);
      context.lineTo(-sqrt3$1 * y2, -y2);
      context.lineTo(sqrt3$1 * y2, -y2);
      context.closePath();
    }
  };
  const sqrt3 = sqrt$1(3);
  const triangle2 = {
    draw(context, size) {
      const s2 = sqrt$1(size) * 0.6824;
      const t = s2 / 2;
      const u = s2 * sqrt3 / 2;
      context.moveTo(0, -s2);
      context.lineTo(u, t);
      context.lineTo(-u, t);
      context.closePath();
    }
  };
  const c = -0.5;
  const s = sqrt$1(3) / 2;
  const k$4 = 1 / sqrt$1(12);
  const a = (k$4 / 2 + 1) * 3;
  const symbolWye = {
    draw(context, size) {
      const r2 = sqrt$1(size / a);
      const x0 = r2 / 2, y0 = r2 * k$4;
      const x1 = x0, y1 = r2 * k$4 + r2;
      const x2 = -x1, y2 = y1;
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
      context.lineTo(x2, y2);
      context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
      context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
      context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
      context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
      context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
      context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
      context.closePath();
    }
  };
  const times = {
    draw(context, size) {
      const r2 = sqrt$1(size - min$1(size / 6, 1.7)) * 0.6189;
      context.moveTo(-r2, -r2);
      context.lineTo(r2, r2);
      context.moveTo(-r2, r2);
      context.lineTo(r2, -r2);
    }
  };
  const symbolsFill = [
    symbolCircle,
    symbolCross,
    symbolDiamond,
    symbolSquare,
    symbolStar,
    symbolTriangle,
    symbolWye
  ];
  const symbolsStroke = [
    symbolCircle,
    plus,
    times,
    triangle2,
    asterisk,
    square2,
    diamond2
  ];
  function Symbol$1(type, size) {
    let context = null, path2 = withPath(symbol);
    type = typeof type === "function" ? type : constant$2(type || symbolCircle);
    size = typeof size === "function" ? size : constant$2(size === void 0 ? 64 : +size);
    function symbol() {
      let buffer;
      if (!context) context = buffer = path2();
      type.apply(this, arguments).draw(context, +size.apply(this, arguments));
      if (buffer) return context = null, buffer + "" || null;
    }
    symbol.type = function(_) {
      return arguments.length ? (type = typeof _ === "function" ? _ : constant$2(_), symbol) : type;
    };
    symbol.size = function(_) {
      return arguments.length ? (size = typeof _ === "function" ? _ : constant$2(+_), symbol) : size;
    };
    symbol.context = function(_) {
      return arguments.length ? (context = _ == null ? null : _, symbol) : context;
    };
    return symbol;
  }
  function noop$8() {
  }
  function point$4(that, x2, y2) {
    that._context.bezierCurveTo(
      (2 * that._x0 + that._x1) / 3,
      (2 * that._y0 + that._y1) / 3,
      (that._x0 + 2 * that._x1) / 3,
      (that._y0 + 2 * that._y1) / 3,
      (that._x0 + 4 * that._x1 + x2) / 6,
      (that._y0 + 4 * that._y1 + y2) / 6
    );
  }
  function Basis(context) {
    this._context = context;
  }
  Basis.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 3:
          point$4(this, this._x1, this._y1);
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
        default:
          point$4(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = x2;
      this._y0 = this._y1, this._y1 = y2;
    }
  };
  function curveBasis(context) {
    return new Basis(context);
  }
  function BasisClosed(context) {
    this._context = context;
  }
  BasisClosed.prototype = {
    areaStart: noop$8,
    areaEnd: noop$8,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x2, this._y2);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x2, this._y2);
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          break;
        }
      }
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x2 = x2, this._y2 = y2;
          break;
        case 1:
          this._point = 2;
          this._x3 = x2, this._y3 = y2;
          break;
        case 2:
          this._point = 3;
          this._x4 = x2, this._y4 = y2;
          this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
          break;
        default:
          point$4(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = x2;
      this._y0 = this._y1, this._y1 = y2;
    }
  };
  function curveBasisClosed(context) {
    return new BasisClosed(context);
  }
  function BasisOpen(context) {
    this._context = context;
  }
  BasisOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
          this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
          break;
        case 3:
          this._point = 4;
        default:
          point$4(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = x2;
      this._y0 = this._y1, this._y1 = y2;
    }
  };
  function curveBasisOpen(context) {
    return new BasisOpen(context);
  }
  function Bundle(context, beta) {
    this._basis = new Basis(context);
    this._beta = beta;
  }
  Bundle.prototype = {
    lineStart: function() {
      this._x = [];
      this._y = [];
      this._basis.lineStart();
    },
    lineEnd: function() {
      var x2 = this._x, y2 = this._y, j = x2.length - 1;
      if (j > 0) {
        var x0 = x2[0], y0 = y2[0], dx = x2[j] - x0, dy = y2[j] - y0, i = -1, t;
        while (++i <= j) {
          t = i / j;
          this._basis.point(
            this._beta * x2[i] + (1 - this._beta) * (x0 + t * dx),
            this._beta * y2[i] + (1 - this._beta) * (y0 + t * dy)
          );
        }
      }
      this._x = this._y = null;
      this._basis.lineEnd();
    },
    point: function(x2, y2) {
      this._x.push(+x2);
      this._y.push(+y2);
    }
  };
  const bundle = function custom(beta) {
    function bundle2(context) {
      return beta === 1 ? new Basis(context) : new Bundle(context, beta);
    }
    bundle2.beta = function(beta2) {
      return custom(+beta2);
    };
    return bundle2;
  }(0.85);
  function point$3(that, x2, y2) {
    that._context.bezierCurveTo(
      that._x1 + that._k * (that._x2 - that._x0),
      that._y1 + that._k * (that._y2 - that._y0),
      that._x2 + that._k * (that._x1 - x2),
      that._y2 + that._k * (that._y1 - y2),
      that._x2,
      that._y2
    );
  }
  function Cardinal(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  Cardinal.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          point$3(this, this._x1, this._y1);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
          this._x1 = x2, this._y1 = y2;
          break;
        case 2:
          this._point = 3;
        default:
          point$3(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const cardinal = function custom(tension) {
    function cardinal2(context) {
      return new Cardinal(context, tension);
    }
    cardinal2.tension = function(tension2) {
      return custom(+tension2);
    };
    return cardinal2;
  }(0);
  function CardinalClosed(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  CardinalClosed.prototype = {
    areaStart: noop$8,
    areaEnd: noop$8,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x3 = x2, this._y3 = y2;
          break;
        case 1:
          this._point = 2;
          this._context.moveTo(this._x4 = x2, this._y4 = y2);
          break;
        case 2:
          this._point = 3;
          this._x5 = x2, this._y5 = y2;
          break;
        default:
          point$3(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const cardinalClosed = function custom(tension) {
    function cardinal2(context) {
      return new CardinalClosed(context, tension);
    }
    cardinal2.tension = function(tension2) {
      return custom(+tension2);
    };
    return cardinal2;
  }(0);
  function CardinalOpen(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  CardinalOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        default:
          point$3(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const cardinalOpen = function custom(tension) {
    function cardinal2(context) {
      return new CardinalOpen(context, tension);
    }
    cardinal2.tension = function(tension2) {
      return custom(+tension2);
    };
    return cardinal2;
  }(0);
  function point$2(that, x2, y2) {
    var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
    if (that._l01_a > epsilon$1) {
      var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
      x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
      y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
    }
    if (that._l23_a > epsilon$1) {
      var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
      x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
      y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
    }
    that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
  }
  function CatmullRom(context, alpha2) {
    this._context = context;
    this._alpha = alpha2;
  }
  CatmullRom.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          this.point(this._x2, this._y2);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      if (this._point) {
        var x23 = this._x2 - x2, y23 = this._y2 - y2;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
        default:
          point$2(this, x2, y2);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const catmullRom = function custom(alpha2) {
    function catmullRom2(context) {
      return alpha2 ? new CatmullRom(context, alpha2) : new Cardinal(context, 0);
    }
    catmullRom2.alpha = function(alpha3) {
      return custom(+alpha3);
    };
    return catmullRom2;
  }(0.5);
  function CatmullRomClosed(context, alpha2) {
    this._context = context;
    this._alpha = alpha2;
  }
  CatmullRomClosed.prototype = {
    areaStart: noop$8,
    areaEnd: noop$8,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      if (this._point) {
        var x23 = this._x2 - x2, y23 = this._y2 - y2;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x3 = x2, this._y3 = y2;
          break;
        case 1:
          this._point = 2;
          this._context.moveTo(this._x4 = x2, this._y4 = y2);
          break;
        case 2:
          this._point = 3;
          this._x5 = x2, this._y5 = y2;
          break;
        default:
          point$2(this, x2, y2);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const catmullRomClosed = function custom(alpha2) {
    function catmullRom2(context) {
      return alpha2 ? new CatmullRomClosed(context, alpha2) : new CardinalClosed(context, 0);
    }
    catmullRom2.alpha = function(alpha3) {
      return custom(+alpha3);
    };
    return catmullRom2;
  }(0.5);
  function CatmullRomOpen(context, alpha2) {
    this._context = context;
    this._alpha = alpha2;
  }
  CatmullRomOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      if (this._point) {
        var x23 = this._x2 - x2, y23 = this._y2 - y2;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        default:
          point$2(this, x2, y2);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const catmullRomOpen = function custom(alpha2) {
    function catmullRom2(context) {
      return alpha2 ? new CatmullRomOpen(context, alpha2) : new CardinalOpen(context, 0);
    }
    catmullRom2.alpha = function(alpha3) {
      return custom(+alpha3);
    };
    return catmullRom2;
  }(0.5);
  function LinearClosed(context) {
    this._context = context;
  }
  LinearClosed.prototype = {
    areaStart: noop$8,
    areaEnd: noop$8,
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._point) this._context.closePath();
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      if (this._point) this._context.lineTo(x2, y2);
      else this._point = 1, this._context.moveTo(x2, y2);
    }
  };
  function curveLinearClosed(context) {
    return new LinearClosed(context);
  }
  function sign(x2) {
    return x2 < 0 ? -1 : 1;
  }
  function slope3(that, x2, y2) {
    var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
  }
  function slope2(that, t) {
    var h = that._x1 - that._x0;
    return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
  }
  function point$1(that, t02, t12) {
    var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
    that._context.bezierCurveTo(x0 + dx, y0 + dx * t02, x1 - dx, y1 - dx * t12, x1, y1);
  }
  function MonotoneX(context) {
    this._context = context;
  }
  MonotoneX.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
        case 3:
          point$1(this, this._t0, slope2(this, this._t0));
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      var t12 = NaN;
      x2 = +x2, y2 = +y2;
      if (x2 === this._x1 && y2 === this._y1) return;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          point$1(this, slope2(this, t12 = slope3(this, x2, y2)), t12);
          break;
        default:
          point$1(this, this._t0, t12 = slope3(this, x2, y2));
          break;
      }
      this._x0 = this._x1, this._x1 = x2;
      this._y0 = this._y1, this._y1 = y2;
      this._t0 = t12;
    }
  };
  function MonotoneY(context) {
    this._context = new ReflectContext(context);
  }
  (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
    MonotoneX.prototype.point.call(this, y2, x2);
  };
  function ReflectContext(context) {
    this._context = context;
  }
  ReflectContext.prototype = {
    moveTo: function(x2, y2) {
      this._context.moveTo(y2, x2);
    },
    closePath: function() {
      this._context.closePath();
    },
    lineTo: function(x2, y2) {
      this._context.lineTo(y2, x2);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
      this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
    }
  };
  function monotoneX(context) {
    return new MonotoneX(context);
  }
  function monotoneY(context) {
    return new MonotoneY(context);
  }
  function Natural(context) {
    this._context = context;
  }
  Natural.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = [];
      this._y = [];
    },
    lineEnd: function() {
      var x2 = this._x, y2 = this._y, n = x2.length;
      if (n) {
        this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
        if (n === 2) {
          this._context.lineTo(x2[1], y2[1]);
        } else {
          var px = controlPoints(x2), py = controlPoints(y2);
          for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
            this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
          }
        }
      }
      if (this._line || this._line !== 0 && n === 1) this._context.closePath();
      this._line = 1 - this._line;
      this._x = this._y = null;
    },
    point: function(x2, y2) {
      this._x.push(+x2);
      this._y.push(+y2);
    }
  };
  function controlPoints(x2) {
    var i, n = x2.length - 1, m, a2 = new Array(n), b = new Array(n), r2 = new Array(n);
    a2[0] = 0, b[0] = 2, r2[0] = x2[0] + 2 * x2[1];
    for (i = 1; i < n - 1; ++i) a2[i] = 1, b[i] = 4, r2[i] = 4 * x2[i] + 2 * x2[i + 1];
    a2[n - 1] = 2, b[n - 1] = 7, r2[n - 1] = 8 * x2[n - 1] + x2[n];
    for (i = 1; i < n; ++i) m = a2[i] / b[i - 1], b[i] -= m, r2[i] -= m * r2[i - 1];
    a2[n - 1] = r2[n - 1] / b[n - 1];
    for (i = n - 2; i >= 0; --i) a2[i] = (r2[i] - a2[i + 1]) / b[i];
    b[n - 1] = (x2[n] + a2[n - 1]) / 2;
    for (i = 0; i < n - 1; ++i) b[i] = 2 * x2[i + 1] - a2[i + 1];
    return [a2, b];
  }
  function curveNatural(context) {
    return new Natural(context);
  }
  function Step(context, t) {
    this._context = context;
    this._t = t;
  }
  Step.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = this._y = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
        default: {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y2);
            this._context.lineTo(x2, y2);
          } else {
            var x1 = this._x * (1 - this._t) + x2 * this._t;
            this._context.lineTo(x1, this._y);
            this._context.lineTo(x1, y2);
          }
          break;
        }
      }
      this._x = x2, this._y = y2;
    }
  };
  function curveStep(context) {
    return new Step(context, 0.5);
  }
  function stepBefore(context) {
    return new Step(context, 0);
  }
  function stepAfter(context) {
    return new Step(context, 1);
  }
  function stackOffsetNone(series, order) {
    if (!((n = series.length) > 1)) return;
    for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
      s0 = s1, s1 = series[order[i]];
      for (j = 0; j < m; ++j) {
        s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
      }
    }
  }
  function stackOrderNone(series) {
    var n = series.length, o = new Array(n);
    while (--n >= 0) o[n] = n;
    return o;
  }
  function stackValue(d, key) {
    return d[key];
  }
  function stackSeries(key) {
    const series = [];
    series.key = key;
    return series;
  }
  function shapeStack() {
    var keys = constant$2([]), order = stackOrderNone, offset = stackOffsetNone, value = stackValue;
    function stack(data) {
      var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
      for (const d of data) {
        for (i = 0, ++j; i < n; ++i) {
          (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
        }
      }
      for (i = 0, oz = array$2(order(sz)); i < n; ++i) {
        sz[oz[i]].index = i;
      }
      offset(sz, oz);
      return sz;
    }
    stack.keys = function(_) {
      return arguments.length ? (keys = typeof _ === "function" ? _ : constant$2(Array.from(_)), stack) : keys;
    };
    stack.value = function(_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant$2(+_), stack) : value;
    };
    stack.order = function(_) {
      return arguments.length ? (order = _ == null ? stackOrderNone : typeof _ === "function" ? _ : constant$2(Array.from(_)), stack) : order;
    };
    stack.offset = function(_) {
      return arguments.length ? (offset = _ == null ? stackOffsetNone : _, stack) : offset;
    };
    return stack;
  }
  function stackOffsetExpand(series, order) {
    if (!((n = series.length) > 0)) return;
    for (var i, n, j = 0, m = series[0].length, y2; j < m; ++j) {
      for (y2 = i = 0; i < n; ++i) y2 += series[i][j][1] || 0;
      if (y2) for (i = 0; i < n; ++i) series[i][j][1] /= y2;
    }
    stackOffsetNone(series, order);
  }
  function diverging$1(series, order) {
    if (!((n = series.length) > 0)) return;
    for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
      for (yp = yn = 0, i = 0; i < n; ++i) {
        if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
          d[0] = yp, d[1] = yp += dy;
        } else if (dy < 0) {
          d[1] = yn, d[0] = yn += dy;
        } else {
          d[0] = 0, d[1] = dy;
        }
      }
    }
  }
  function stackOffsetSilhouette(series, order) {
    if (!((n = series.length) > 0)) return;
    for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
      for (var i = 0, y2 = 0; i < n; ++i) y2 += series[i][j][1] || 0;
      s0[j][1] += s0[j][0] = -y2 / 2;
    }
    stackOffsetNone(series, order);
  }
  function stackOffsetWiggle(series, order) {
    if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
    for (var y2 = 0, j = 1, s0, m, n; j < m; ++j) {
      for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
        var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
        for (var k2 = 0; k2 < i; ++k2) {
          var sk = series[order[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
          s3 += skj0 - skj1;
        }
        s1 += sij0, s2 += s3 * sij0;
      }
      s0[j - 1][1] += s0[j - 1][0] = y2;
      if (s1) y2 -= s2 / s1;
    }
    s0[j - 1][1] += s0[j - 1][0] = y2;
    stackOffsetNone(series, order);
  }
  function appearance(series) {
    var peaks = series.map(peak);
    return stackOrderNone(series).sort(function(a2, b) {
      return peaks[a2] - peaks[b];
    });
  }
  function peak(series) {
    var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
    while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
    return j;
  }
  function ascending$1(series) {
    var sums = series.map(sum$2);
    return stackOrderNone(series).sort(function(a2, b) {
      return sums[a2] - sums[b];
    });
  }
  function sum$2(series) {
    var s2 = 0, i = -1, n = series.length, v;
    while (++i < n) if (v = +series[i][1]) s2 += v;
    return s2;
  }
  function descending$1(series) {
    return ascending$1(series).reverse();
  }
  function insideOut(series) {
    var n = series.length, i, j, sums = series.map(sum$2), order = appearance(series), top = 0, bottom = 0, tops = [], bottoms = [];
    for (i = 0; i < n; ++i) {
      j = order[i];
      if (top < bottom) {
        top += sums[j];
        tops.push(j);
      } else {
        bottom += sums[j];
        bottoms.push(j);
      }
    }
    return bottoms.reverse().concat(tops);
  }
  function reverse$2(series) {
    return stackOrderNone(series).reverse();
  }
  var _excluded$y = ["type", "size", "sizeType"];
  function _extends$J() {
    return _extends$J = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$J.apply(null, arguments);
  }
  function ownKeys$X(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$X(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$X(Object(t), true).forEach(function(r3) {
        _defineProperty$$(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$X(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$$(e, r2, t) {
    return (r2 = _toPropertyKey$$(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$$(t) {
    var i = _toPrimitive$$(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$$(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _objectWithoutProperties$y(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$y(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$y(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var symbolFactories = {
    symbolCircle,
    symbolCross,
    symbolDiamond,
    symbolSquare,
    symbolStar,
    symbolTriangle,
    symbolWye
  };
  var RADIAN$2 = Math.PI / 180;
  var getSymbolFactory = (type) => {
    var name = "symbol".concat(upperFirst$1(type));
    return symbolFactories[name] || symbolCircle;
  };
  var calculateAreaSize = (size, sizeType, type) => {
    if (sizeType === "area") {
      return size;
    }
    switch (type) {
      case "cross":
        return 5 * size * size / 9;
      case "diamond":
        return 0.5 * size * size / Math.sqrt(3);
      case "square":
        return size * size;
      case "star": {
        var angle = 18 * RADIAN$2;
        return 1.25 * size * size * (Math.tan(angle) - Math.tan(angle * 2) * Math.tan(angle) ** 2);
      }
      case "triangle":
        return Math.sqrt(3) * size * size / 4;
      case "wye":
        return (21 - 10 * Math.sqrt(3)) * size * size / 8;
      default:
        return Math.PI * size * size / 4;
    }
  };
  var registerSymbol = (key, factory) => {
    symbolFactories["symbol".concat(upperFirst$1(key))] = factory;
  };
  var Symbols = (_ref2) => {
    var {
      type = "circle",
      size = 64,
      sizeType = "area"
    } = _ref2, rest2 = _objectWithoutProperties$y(_ref2, _excluded$y);
    var props = _objectSpread$X(_objectSpread$X({}, rest2), {}, {
      type,
      size,
      sizeType
    });
    var getPath2 = () => {
      var symbolFactory = getSymbolFactory(type);
      var symbol = Symbol$1().type(symbolFactory).size(calculateAreaSize(size, sizeType, type));
      return symbol();
    };
    var {
      className,
      cx,
      cy
    } = props;
    var filteredProps = filterProps(props, true);
    if (cx === +cx && cy === +cy && size === +size) {
      return /* @__PURE__ */ React__namespace.createElement("path", _extends$J({}, filteredProps, {
        className: clsx("recharts-symbols", className),
        transform: "translate(".concat(cx, ", ").concat(cy, ")"),
        d: getPath2()
      }));
    }
    return null;
  };
  Symbols.registerSymbol = registerSymbol;
  function _extends$I() {
    return _extends$I = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$I.apply(null, arguments);
  }
  function ownKeys$W(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$W(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$W(Object(t), true).forEach(function(r3) {
        _defineProperty$_(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$W(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$_(e, r2, t) {
    return (r2 = _toPropertyKey$_(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$_(t) {
    var i = _toPrimitive$_(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$_(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var SIZE = 32;
  class DefaultLegendContent extends React.PureComponent {
    /**
     * Render the path of icon
     * @param data Data of each legend item
     * @param iconType if defined, it will always render this icon. If undefined then it uses icon from data.type
     * @return Path element
     */
    renderIcon(data, iconType) {
      var {
        inactiveColor
      } = this.props;
      var halfSize = SIZE / 2;
      var sixthSize = SIZE / 6;
      var thirdSize = SIZE / 3;
      var color2 = data.inactive ? inactiveColor : data.color;
      var preferredIcon = iconType !== null && iconType !== void 0 ? iconType : data.type;
      if (preferredIcon === "none") {
        return null;
      }
      if (preferredIcon === "plainline") {
        return /* @__PURE__ */ React__namespace.createElement("line", {
          strokeWidth: 4,
          fill: "none",
          stroke: color2,
          strokeDasharray: data.payload.strokeDasharray,
          x1: 0,
          y1: halfSize,
          x2: SIZE,
          y2: halfSize,
          className: "recharts-legend-icon"
        });
      }
      if (preferredIcon === "line") {
        return /* @__PURE__ */ React__namespace.createElement("path", {
          strokeWidth: 4,
          fill: "none",
          stroke: color2,
          d: "M0,".concat(halfSize, "h").concat(thirdSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(2 * thirdSize, ",").concat(halfSize, "\n            H").concat(SIZE, "M").concat(2 * thirdSize, ",").concat(halfSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(thirdSize, ",").concat(halfSize),
          className: "recharts-legend-icon"
        });
      }
      if (preferredIcon === "rect") {
        return /* @__PURE__ */ React__namespace.createElement("path", {
          stroke: "none",
          fill: color2,
          d: "M0,".concat(SIZE / 8, "h").concat(SIZE, "v").concat(SIZE * 3 / 4, "h").concat(-SIZE, "z"),
          className: "recharts-legend-icon"
        });
      }
      if (/* @__PURE__ */ React__namespace.isValidElement(data.legendIcon)) {
        var iconProps = _objectSpread$W({}, data);
        delete iconProps.legendIcon;
        return /* @__PURE__ */ React__namespace.cloneElement(data.legendIcon, iconProps);
      }
      return /* @__PURE__ */ React__namespace.createElement(Symbols, {
        fill: color2,
        cx: halfSize,
        cy: halfSize,
        size: SIZE,
        sizeType: "diameter",
        type: preferredIcon
      });
    }
    /**
     * Draw items of legend
     * @return Items
     */
    renderItems() {
      var {
        payload,
        iconSize,
        layout,
        formatter,
        inactiveColor,
        iconType
      } = this.props;
      var viewBox = {
        x: 0,
        y: 0,
        width: SIZE,
        height: SIZE
      };
      var itemStyle = {
        display: layout === "horizontal" ? "inline-block" : "block",
        marginRight: 10
      };
      var svgStyle = {
        display: "inline-block",
        verticalAlign: "middle",
        marginRight: 4
      };
      return payload.map((entry, i) => {
        var finalFormatter = entry.formatter || formatter;
        var className = clsx({
          "recharts-legend-item": true,
          ["legend-item-".concat(i)]: true,
          inactive: entry.inactive
        });
        if (entry.type === "none") {
          return null;
        }
        var color2 = entry.inactive ? inactiveColor : entry.color;
        var finalValue = finalFormatter ? finalFormatter(entry.value, entry, i) : entry.value;
        return /* @__PURE__ */ React__namespace.createElement("li", _extends$I({
          className,
          style: itemStyle,
          key: "legend-item-".concat(i)
        }, adaptEventsOfChild(this.props, entry, i)), /* @__PURE__ */ React__namespace.createElement(Surface, {
          width: iconSize,
          height: iconSize,
          viewBox,
          style: svgStyle,
          "aria-label": "".concat(finalValue, " legend icon")
        }, this.renderIcon(entry, iconType)), /* @__PURE__ */ React__namespace.createElement("span", {
          className: "recharts-legend-item-text",
          style: {
            color: color2
          }
        }, finalValue));
      });
    }
    render() {
      var {
        payload,
        layout,
        align
      } = this.props;
      if (!payload || !payload.length) {
        return null;
      }
      var finalStyle = {
        padding: 0,
        margin: 0,
        textAlign: layout === "horizontal" ? align : "left"
      };
      return /* @__PURE__ */ React__namespace.createElement("ul", {
        className: "recharts-default-legend",
        style: finalStyle
      }, this.renderItems());
    }
  }
  _defineProperty$_(DefaultLegendContent, "displayName", "Legend");
  _defineProperty$_(DefaultLegendContent, "defaultProps", {
    align: "center",
    iconSize: 14,
    inactiveColor: "#ccc",
    layout: "horizontal",
    verticalAlign: "middle"
  });
  var uniqBy$6 = {};
  var uniqBy$5 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function uniqBy2(arr, mapper) {
      const map2 = /* @__PURE__ */ new Map();
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        const key = mapper(item);
        if (!map2.has(key)) {
          map2.set(key, item);
        }
      }
      return Array.from(map2.values());
    }
    exports3.uniqBy = uniqBy2;
  })(uniqBy$5);
  const uniqBy$4 = /* @__PURE__ */ getDefaultExportFromCjs(uniqBy$5);
  var identity$8 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function identity2(x2) {
      return x2;
    }
    exports3.identity = identity2;
  })(identity$8);
  const identity$7 = /* @__PURE__ */ getDefaultExportFromCjs(identity$8);
  var isArrayLikeObject$1 = {};
  var isArrayLike$1 = {};
  var isLength$2 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function isLength2(value) {
      return Number.isSafeInteger(value) && value >= 0;
    }
    exports3.isLength = isLength2;
  })(isLength$2);
  const isLength$1 = /* @__PURE__ */ getDefaultExportFromCjs(isLength$2);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const isLength2 = isLength$2;
    function isArrayLike2(value) {
      return value != null && typeof value !== "function" && isLength2.isLength(value.length);
    }
    exports3.isArrayLike = isArrayLike2;
  })(isArrayLike$1);
  const isArrayLike = /* @__PURE__ */ getDefaultExportFromCjs(isArrayLike$1);
  var isObjectLike$2 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function isObjectLike2(value) {
      return typeof value === "object" && value !== null;
    }
    exports3.isObjectLike = isObjectLike2;
  })(isObjectLike$2);
  const isObjectLike$1 = /* @__PURE__ */ getDefaultExportFromCjs(isObjectLike$2);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const isArrayLike2 = isArrayLike$1;
    const isObjectLike2 = isObjectLike$2;
    function isArrayLikeObject2(value) {
      return isObjectLike2.isObjectLike(value) && isArrayLike2.isArrayLike(value);
    }
    exports3.isArrayLikeObject = isArrayLikeObject2;
  })(isArrayLikeObject$1);
  const isArrayLikeObject = /* @__PURE__ */ getDefaultExportFromCjs(isArrayLikeObject$1);
  var iteratee$1 = {};
  var property$1 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const get2 = get$4;
    function property2(path2) {
      return function(object2) {
        return get2.get(object2, path2);
      };
    }
    exports3.property = property2;
  })(property$1);
  const property = /* @__PURE__ */ getDefaultExportFromCjs(property$1);
  var matches$2 = {};
  var isMatch = {};
  var isMatchWith = {};
  var isObject$1 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function isObject2(value) {
      return value !== null && (typeof value === "object" || typeof value === "function");
    }
    exports3.isObject = isObject2;
  })(isObject$1);
  const isObject = /* @__PURE__ */ getDefaultExportFromCjs(isObject$1);
  var isPrimitive$2 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function isPrimitive2(value) {
      return value == null || typeof value !== "object" && typeof value !== "function";
    }
    exports3.isPrimitive = isPrimitive2;
  })(isPrimitive$2);
  const isPrimitive$1 = /* @__PURE__ */ getDefaultExportFromCjs(isPrimitive$2);
  var eq$2 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function eq2(value, other) {
      return value === other || Number.isNaN(value) && Number.isNaN(other);
    }
    exports3.eq = eq2;
  })(eq$2);
  const eq$1 = /* @__PURE__ */ getDefaultExportFromCjs(eq$2);
  var hasRequiredIsMatchWith;
  function requireIsMatchWith() {
    if (hasRequiredIsMatchWith) return isMatchWith;
    hasRequiredIsMatchWith = 1;
    (function(exports3) {
      "use strict";
      Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
      const isMatch2 = requireIsMatch();
      const isObject2 = isObject$1;
      const isPrimitive2 = isPrimitive$2;
      const eq2 = eq$2;
      function isMatchWith2(target, source, compare) {
        if (typeof compare !== "function") {
          return isMatch2.isMatch(target, source);
        }
        return isMatchWithInternal(target, source, function doesMatch(objValue, srcValue, key, object2, source2, stack) {
          const isEqual2 = compare(objValue, srcValue, key, object2, source2, stack);
          if (isEqual2 !== void 0) {
            return Boolean(isEqual2);
          }
          return isMatchWithInternal(objValue, srcValue, doesMatch, stack);
        }, /* @__PURE__ */ new Map());
      }
      function isMatchWithInternal(target, source, compare, stack) {
        if (source === target) {
          return true;
        }
        switch (typeof source) {
          case "object": {
            return isObjectMatch(target, source, compare, stack);
          }
          case "function": {
            const sourceKeys = Object.keys(source);
            if (sourceKeys.length > 0) {
              return isMatchWithInternal(target, { ...source }, compare, stack);
            }
            return eq2.eq(target, source);
          }
          default: {
            if (!isObject2.isObject(target)) {
              return eq2.eq(target, source);
            }
            if (typeof source === "string") {
              return source === "";
            }
            return true;
          }
        }
      }
      function isObjectMatch(target, source, compare, stack) {
        if (source == null) {
          return true;
        }
        if (Array.isArray(source)) {
          return isArrayMatch(target, source, compare, stack);
        }
        if (source instanceof Map) {
          return isMapMatch(target, source, compare, stack);
        }
        if (source instanceof Set) {
          return isSetMatch(target, source, compare, stack);
        }
        const keys = Object.keys(source);
        if (target == null) {
          return keys.length === 0;
        }
        if (keys.length === 0) {
          return true;
        }
        if (stack && stack.has(source)) {
          return stack.get(source) === target;
        }
        if (stack) {
          stack.set(source, target);
        }
        try {
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (!isPrimitive2.isPrimitive(target) && !(key in target)) {
              return false;
            }
            if (source[key] === void 0 && target[key] !== void 0) {
              return false;
            }
            if (source[key] === null && target[key] !== null) {
              return false;
            }
            const isEqual2 = compare(target[key], source[key], key, target, source, stack);
            if (!isEqual2) {
              return false;
            }
          }
          return true;
        } finally {
          if (stack) {
            stack.delete(source);
          }
        }
      }
      function isMapMatch(target, source, compare, stack) {
        if (source.size === 0) {
          return true;
        }
        if (!(target instanceof Map)) {
          return false;
        }
        for (const [key, sourceValue] of source.entries()) {
          const targetValue = target.get(key);
          const isEqual2 = compare(targetValue, sourceValue, key, target, source, stack);
          if (isEqual2 === false) {
            return false;
          }
        }
        return true;
      }
      function isArrayMatch(target, source, compare, stack) {
        if (source.length === 0) {
          return true;
        }
        if (!Array.isArray(target)) {
          return false;
        }
        const countedIndex = /* @__PURE__ */ new Set();
        for (let i = 0; i < source.length; i++) {
          const sourceItem = source[i];
          let found = false;
          for (let j = 0; j < target.length; j++) {
            if (countedIndex.has(j)) {
              continue;
            }
            const targetItem = target[j];
            let matches2 = false;
            const isEqual2 = compare(targetItem, sourceItem, i, target, source, stack);
            if (isEqual2) {
              matches2 = true;
            }
            if (matches2) {
              countedIndex.add(j);
              found = true;
              break;
            }
          }
          if (!found) {
            return false;
          }
        }
        return true;
      }
      function isSetMatch(target, source, compare, stack) {
        if (source.size === 0) {
          return true;
        }
        if (!(target instanceof Set)) {
          return false;
        }
        return isArrayMatch([...target], [...source], compare, stack);
      }
      exports3.isMatchWith = isMatchWith2;
      exports3.isSetMatch = isSetMatch;
    })(isMatchWith);
    return isMatchWith;
  }
  var hasRequiredIsMatch;
  function requireIsMatch() {
    if (hasRequiredIsMatch) return isMatch;
    hasRequiredIsMatch = 1;
    (function(exports3) {
      "use strict";
      Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
      const isMatchWith2 = requireIsMatchWith();
      function isMatch2(target, source) {
        return isMatchWith2.isMatchWith(target, source, () => void 0);
      }
      exports3.isMatch = isMatch2;
    })(isMatch);
    return isMatch;
  }
  var cloneDeep$4 = {};
  var cloneDeepWith$4 = {};
  var getSymbols$2 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function getSymbols2(object2) {
      return Object.getOwnPropertySymbols(object2).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object2, symbol));
    }
    exports3.getSymbols = getSymbols2;
  })(getSymbols$2);
  const getSymbols$1 = /* @__PURE__ */ getDefaultExportFromCjs(getSymbols$2);
  var getTag$2 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function getTag2(value) {
      if (value == null) {
        return value === void 0 ? "[object Undefined]" : "[object Null]";
      }
      return Object.prototype.toString.call(value);
    }
    exports3.getTag = getTag2;
  })(getTag$2);
  const getTag$1 = /* @__PURE__ */ getDefaultExportFromCjs(getTag$2);
  var tags$1 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const regexpTag2 = "[object RegExp]";
    const stringTag2 = "[object String]";
    const numberTag2 = "[object Number]";
    const booleanTag2 = "[object Boolean]";
    const argumentsTag2 = "[object Arguments]";
    const symbolTag2 = "[object Symbol]";
    const dateTag2 = "[object Date]";
    const mapTag2 = "[object Map]";
    const setTag2 = "[object Set]";
    const arrayTag2 = "[object Array]";
    const functionTag2 = "[object Function]";
    const arrayBufferTag2 = "[object ArrayBuffer]";
    const objectTag2 = "[object Object]";
    const errorTag2 = "[object Error]";
    const dataViewTag2 = "[object DataView]";
    const uint8ArrayTag2 = "[object Uint8Array]";
    const uint8ClampedArrayTag2 = "[object Uint8ClampedArray]";
    const uint16ArrayTag2 = "[object Uint16Array]";
    const uint32ArrayTag2 = "[object Uint32Array]";
    const bigUint64ArrayTag2 = "[object BigUint64Array]";
    const int8ArrayTag2 = "[object Int8Array]";
    const int16ArrayTag2 = "[object Int16Array]";
    const int32ArrayTag2 = "[object Int32Array]";
    const bigInt64ArrayTag2 = "[object BigInt64Array]";
    const float32ArrayTag2 = "[object Float32Array]";
    const float64ArrayTag2 = "[object Float64Array]";
    exports3.argumentsTag = argumentsTag2;
    exports3.arrayBufferTag = arrayBufferTag2;
    exports3.arrayTag = arrayTag2;
    exports3.bigInt64ArrayTag = bigInt64ArrayTag2;
    exports3.bigUint64ArrayTag = bigUint64ArrayTag2;
    exports3.booleanTag = booleanTag2;
    exports3.dataViewTag = dataViewTag2;
    exports3.dateTag = dateTag2;
    exports3.errorTag = errorTag2;
    exports3.float32ArrayTag = float32ArrayTag2;
    exports3.float64ArrayTag = float64ArrayTag2;
    exports3.functionTag = functionTag2;
    exports3.int16ArrayTag = int16ArrayTag2;
    exports3.int32ArrayTag = int32ArrayTag2;
    exports3.int8ArrayTag = int8ArrayTag2;
    exports3.mapTag = mapTag2;
    exports3.numberTag = numberTag2;
    exports3.objectTag = objectTag2;
    exports3.regexpTag = regexpTag2;
    exports3.setTag = setTag2;
    exports3.stringTag = stringTag2;
    exports3.symbolTag = symbolTag2;
    exports3.uint16ArrayTag = uint16ArrayTag2;
    exports3.uint32ArrayTag = uint32ArrayTag2;
    exports3.uint8ArrayTag = uint8ArrayTag2;
    exports3.uint8ClampedArrayTag = uint8ClampedArrayTag2;
  })(tags$1);
  const tags = /* @__PURE__ */ getDefaultExportFromCjs(tags$1);
  var isTypedArray$2 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function isTypedArray2(x2) {
      return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
    }
    exports3.isTypedArray = isTypedArray2;
  })(isTypedArray$2);
  const isTypedArray$1 = /* @__PURE__ */ getDefaultExportFromCjs(isTypedArray$2);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const getSymbols2 = getSymbols$2;
    const getTag2 = getTag$2;
    const tags2 = tags$1;
    const isPrimitive2 = isPrimitive$2;
    const isTypedArray2 = isTypedArray$2;
    function cloneDeepWith2(obj, cloneValue) {
      return cloneDeepWithImpl2(obj, void 0, obj, /* @__PURE__ */ new Map(), cloneValue);
    }
    function cloneDeepWithImpl2(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
      const cloned = cloneValue == null ? void 0 : cloneValue(valueToClone, keyToClone, objectToClone, stack);
      if (cloned !== void 0) {
        return cloned;
      }
      if (isPrimitive2.isPrimitive(valueToClone)) {
        return valueToClone;
      }
      if (stack.has(valueToClone)) {
        return stack.get(valueToClone);
      }
      if (Array.isArray(valueToClone)) {
        const result = new Array(valueToClone.length);
        stack.set(valueToClone, result);
        for (let i = 0; i < valueToClone.length; i++) {
          result[i] = cloneDeepWithImpl2(valueToClone[i], i, objectToClone, stack, cloneValue);
        }
        if (Object.hasOwn(valueToClone, "index")) {
          result.index = valueToClone.index;
        }
        if (Object.hasOwn(valueToClone, "input")) {
          result.input = valueToClone.input;
        }
        return result;
      }
      if (valueToClone instanceof Date) {
        return new Date(valueToClone.getTime());
      }
      if (valueToClone instanceof RegExp) {
        const result = new RegExp(valueToClone.source, valueToClone.flags);
        result.lastIndex = valueToClone.lastIndex;
        return result;
      }
      if (valueToClone instanceof Map) {
        const result = /* @__PURE__ */ new Map();
        stack.set(valueToClone, result);
        for (const [key, value] of valueToClone) {
          result.set(key, cloneDeepWithImpl2(value, key, objectToClone, stack, cloneValue));
        }
        return result;
      }
      if (valueToClone instanceof Set) {
        const result = /* @__PURE__ */ new Set();
        stack.set(valueToClone, result);
        for (const value of valueToClone) {
          result.add(cloneDeepWithImpl2(value, void 0, objectToClone, stack, cloneValue));
        }
        return result;
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
        return valueToClone.subarray();
      }
      if (isTypedArray2.isTypedArray(valueToClone)) {
        const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
        stack.set(valueToClone, result);
        for (let i = 0; i < valueToClone.length; i++) {
          result[i] = cloneDeepWithImpl2(valueToClone[i], i, objectToClone, stack, cloneValue);
        }
        return result;
      }
      if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
        return valueToClone.slice(0);
      }
      if (valueToClone instanceof DataView) {
        const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
        stack.set(valueToClone, result);
        copyProperties2(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      if (typeof File !== "undefined" && valueToClone instanceof File) {
        const result = new File([valueToClone], valueToClone.name, {
          type: valueToClone.type
        });
        stack.set(valueToClone, result);
        copyProperties2(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      if (valueToClone instanceof Blob) {
        const result = new Blob([valueToClone], { type: valueToClone.type });
        stack.set(valueToClone, result);
        copyProperties2(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      if (valueToClone instanceof Error) {
        const result = new valueToClone.constructor();
        stack.set(valueToClone, result);
        result.message = valueToClone.message;
        result.name = valueToClone.name;
        result.stack = valueToClone.stack;
        result.cause = valueToClone.cause;
        copyProperties2(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      if (typeof valueToClone === "object" && isCloneableObject2(valueToClone)) {
        const result = Object.create(Object.getPrototypeOf(valueToClone));
        stack.set(valueToClone, result);
        copyProperties2(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      return valueToClone;
    }
    function copyProperties2(target, source, objectToClone = target, stack, cloneValue) {
      const keys = [...Object.keys(source), ...getSymbols2.getSymbols(source)];
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const descriptor = Object.getOwnPropertyDescriptor(target, key);
        if (descriptor == null || descriptor.writable) {
          target[key] = cloneDeepWithImpl2(source[key], key, objectToClone, stack, cloneValue);
        }
      }
    }
    function isCloneableObject2(object2) {
      switch (getTag2.getTag(object2)) {
        case tags2.argumentsTag:
        case tags2.arrayTag:
        case tags2.arrayBufferTag:
        case tags2.dataViewTag:
        case tags2.booleanTag:
        case tags2.dateTag:
        case tags2.float32ArrayTag:
        case tags2.float64ArrayTag:
        case tags2.int8ArrayTag:
        case tags2.int16ArrayTag:
        case tags2.int32ArrayTag:
        case tags2.mapTag:
        case tags2.numberTag:
        case tags2.objectTag:
        case tags2.regexpTag:
        case tags2.setTag:
        case tags2.stringTag:
        case tags2.symbolTag:
        case tags2.uint8ArrayTag:
        case tags2.uint8ClampedArrayTag:
        case tags2.uint16ArrayTag:
        case tags2.uint32ArrayTag: {
          return true;
        }
        default: {
          return false;
        }
      }
    }
    exports3.cloneDeepWith = cloneDeepWith2;
    exports3.cloneDeepWithImpl = cloneDeepWithImpl2;
    exports3.copyProperties = copyProperties2;
  })(cloneDeepWith$4);
  const cloneDeepWith$3 = /* @__PURE__ */ getDefaultExportFromCjs(cloneDeepWith$4);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const cloneDeepWith2 = cloneDeepWith$4;
    function cloneDeep2(obj) {
      return cloneDeepWith2.cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
    }
    exports3.cloneDeep = cloneDeep2;
  })(cloneDeep$4);
  const cloneDeep$3 = /* @__PURE__ */ getDefaultExportFromCjs(cloneDeep$4);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const isMatch2 = requireIsMatch();
    const cloneDeep2 = cloneDeep$4;
    function matches2(source) {
      source = cloneDeep2.cloneDeep(source);
      return (target) => {
        return isMatch2.isMatch(target, source);
      };
    }
    exports3.matches = matches2;
  })(matches$2);
  const matches$1 = /* @__PURE__ */ getDefaultExportFromCjs(matches$2);
  var matchesProperty$1 = {};
  var cloneDeep$2 = {};
  var cloneDeepWith$2 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const cloneDeepWith$12 = cloneDeepWith$4;
    const tags2 = tags$1;
    function cloneDeepWith2(obj, customizer) {
      return cloneDeepWith$12.cloneDeepWith(obj, (value, key, object2, stack) => {
        const cloned = customizer == null ? void 0 : customizer(value, key, object2, stack);
        if (cloned !== void 0) {
          return cloned;
        }
        if (typeof obj !== "object") {
          return void 0;
        }
        switch (Object.prototype.toString.call(obj)) {
          case tags2.numberTag:
          case tags2.stringTag:
          case tags2.booleanTag: {
            const result = new obj.constructor(obj == null ? void 0 : obj.valueOf());
            cloneDeepWith$12.copyProperties(result, obj);
            return result;
          }
          case tags2.argumentsTag: {
            const result = {};
            cloneDeepWith$12.copyProperties(result, obj);
            result.length = obj.length;
            result[Symbol.iterator] = obj[Symbol.iterator];
            return result;
          }
          default: {
            return void 0;
          }
        }
      });
    }
    exports3.cloneDeepWith = cloneDeepWith2;
  })(cloneDeepWith$2);
  const cloneDeepWith$1 = /* @__PURE__ */ getDefaultExportFromCjs(cloneDeepWith$2);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const cloneDeepWith2 = cloneDeepWith$2;
    function cloneDeep2(obj) {
      return cloneDeepWith2.cloneDeepWith(obj);
    }
    exports3.cloneDeep = cloneDeep2;
  })(cloneDeep$2);
  const cloneDeep$1 = /* @__PURE__ */ getDefaultExportFromCjs(cloneDeep$2);
  var has$2 = {};
  var isIndex$1 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\d*)$/;
    function isIndex2(value, length2 = Number.MAX_SAFE_INTEGER) {
      switch (typeof value) {
        case "number": {
          return Number.isInteger(value) && value >= 0 && value < length2;
        }
        case "symbol": {
          return false;
        }
        case "string": {
          return IS_UNSIGNED_INTEGER.test(value);
        }
      }
    }
    exports3.isIndex = isIndex2;
  })(isIndex$1);
  const isIndex = /* @__PURE__ */ getDefaultExportFromCjs(isIndex$1);
  var isArguments$1 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const getTag2 = getTag$2;
    function isArguments2(value) {
      return value !== null && typeof value === "object" && getTag2.getTag(value) === "[object Arguments]";
    }
    exports3.isArguments = isArguments2;
  })(isArguments$1);
  const isArguments = /* @__PURE__ */ getDefaultExportFromCjs(isArguments$1);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const isDeepKey2 = isDeepKey$1;
    const isIndex2 = isIndex$1;
    const isArguments2 = isArguments$1;
    const toPath2 = toPath$1;
    function has2(object2, path2) {
      let resolvedPath;
      if (Array.isArray(path2)) {
        resolvedPath = path2;
      } else if (typeof path2 === "string" && isDeepKey2.isDeepKey(path2) && (object2 == null ? void 0 : object2[path2]) == null) {
        resolvedPath = toPath2.toPath(path2);
      } else {
        resolvedPath = [path2];
      }
      if (resolvedPath.length === 0) {
        return false;
      }
      let current2 = object2;
      for (let i = 0; i < resolvedPath.length; i++) {
        const key = resolvedPath[i];
        if (current2 == null || !Object.hasOwn(current2, key)) {
          const isSparseIndex = (Array.isArray(current2) || isArguments2.isArguments(current2)) && isIndex2.isIndex(key) && key < current2.length;
          if (!isSparseIndex) {
            return false;
          }
        }
        current2 = current2[key];
      }
      return true;
    }
    exports3.has = has2;
  })(has$2);
  const has$1 = /* @__PURE__ */ getDefaultExportFromCjs(has$2);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const isMatch2 = requireIsMatch();
    const toKey2 = toKey$1;
    const cloneDeep2 = cloneDeep$2;
    const get2 = get$4;
    const has2 = has$2;
    function matchesProperty2(property2, source) {
      switch (typeof property2) {
        case "object": {
          if (Object.is(property2 == null ? void 0 : property2.valueOf(), -0)) {
            property2 = "-0";
          }
          break;
        }
        case "number": {
          property2 = toKey2.toKey(property2);
          break;
        }
      }
      source = cloneDeep2.cloneDeep(source);
      return function(target) {
        const result = get2.get(target, property2);
        if (result === void 0) {
          return has2.has(target, property2);
        }
        if (source === void 0) {
          return result === void 0;
        }
        return isMatch2.isMatch(result, source);
      };
    }
    exports3.matchesProperty = matchesProperty2;
  })(matchesProperty$1);
  const matchesProperty = /* @__PURE__ */ getDefaultExportFromCjs(matchesProperty$1);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const identity2 = identity$8;
    const property2 = property$1;
    const matches2 = matches$2;
    const matchesProperty2 = matchesProperty$1;
    function iteratee2(value) {
      if (value == null) {
        return identity2.identity;
      }
      switch (typeof value) {
        case "function": {
          return value;
        }
        case "object": {
          if (Array.isArray(value) && value.length === 2) {
            return matchesProperty2.matchesProperty(value[0], value[1]);
          }
          return matches2.matches(value);
        }
        case "string":
        case "symbol":
        case "number": {
          return property2.property(value);
        }
      }
    }
    exports3.iteratee = iteratee2;
  })(iteratee$1);
  const iteratee = /* @__PURE__ */ getDefaultExportFromCjs(iteratee$1);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const uniqBy$12 = uniqBy$5;
    const identity2 = identity$8;
    const isArrayLikeObject2 = isArrayLikeObject$1;
    const iteratee2 = iteratee$1;
    function uniqBy2(array2, iteratee$12 = identity2.identity) {
      if (!isArrayLikeObject2.isArrayLikeObject(array2)) {
        return [];
      }
      return uniqBy$12.uniqBy(Array.from(array2), iteratee2.iteratee(iteratee$12));
    }
    exports3.uniqBy = uniqBy2;
  })(uniqBy$6);
  const uniqBy$3 = /* @__PURE__ */ getDefaultExportFromCjs(uniqBy$6);
  var uniqBy$1 = uniqBy$6.uniqBy;
  const uniqBy$2 = /* @__PURE__ */ getDefaultExportFromCjs(uniqBy$1);
  function getUniqPayload(payload, option, defaultUniqBy2) {
    if (option === true) {
      return uniqBy$2(payload, defaultUniqBy2);
    }
    if (typeof option === "function") {
      return uniqBy$2(payload, option);
    }
    return payload;
  }
  var withSelector$5 = { exports: {} };
  var withSelector_development = {};
  var shim$1 = { exports: {} };
  var useSyncExternalStoreShim_development = {};
  var useSyncExternalStore;
  "use strict";
  /**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  (function() {
    function is2(x2, y2) {
      return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
    }
    function useSyncExternalStore$2(subscribe, getSnapshot) {
      didWarnOld18Alpha || void 0 === React$1.startTransition || (didWarnOld18Alpha = true, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var value = getSnapshot();
      if (!didWarnUncachedGetSnapshot) {
        var cachedValue = getSnapshot();
        objectIs(value, cachedValue) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), didWarnUncachedGetSnapshot = true);
      }
      cachedValue = useState({
        inst: { value, getSnapshot }
      });
      var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
      useLayoutEffect(
        function() {
          inst.value = value;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        },
        [subscribe, value, getSnapshot]
      );
      useEffect(
        function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          return subscribe(function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          });
        },
        [subscribe]
      );
      useDebugValue(value);
      return value;
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function useSyncExternalStore$1(subscribe, getSnapshot) {
      return getSnapshot();
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React$1 = React, objectIs = "function" === typeof Object.is ? Object.is : is2, useState = React$1.useState, useEffect = React$1.useEffect, useLayoutEffect = React$1.useLayoutEffect, useDebugValue = React$1.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
    useSyncExternalStore = useSyncExternalStoreShim_development.useSyncExternalStore = void 0 !== React$1.useSyncExternalStore ? React$1.useSyncExternalStore : shim2;
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
  var shim = shim$1.exports;
  "use strict";
  if (false) {
    module.exports = require("../cjs/use-sync-external-store-shim.production.js");
  } else {
    shim$1.exports = useSyncExternalStoreShim_development;
  }
  var shimExports = shim$1.exports;
  const index$1 = /* @__PURE__ */ getDefaultExportFromCjs(shimExports);
  var useSyncExternalStoreWithSelector$1;
  "use strict";
  /**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  (function() {
    function is2(x2, y2) {
      return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React$1 = React, shim2 = shimExports, objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore2 = shim2.useSyncExternalStore, useRef = React$1.useRef, useEffect = React$1.useEffect, useMemo = React$1.useMemo, useDebugValue = React$1.useDebugValue;
    useSyncExternalStoreWithSelector$1 = withSelector_development.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual2) {
      var instRef = useRef(null);
      if (null === instRef.current) {
        var inst = { hasValue: false, value: null };
        instRef.current = inst;
      } else inst = instRef.current;
      instRef = useMemo(
        function() {
          function memoizedSelector(nextSnapshot) {
            if (!hasMemo) {
              hasMemo = true;
              memoizedSnapshot = nextSnapshot;
              nextSnapshot = selector(nextSnapshot);
              if (void 0 !== isEqual2 && inst.hasValue) {
                var currentSelection = inst.value;
                if (isEqual2(currentSelection, nextSnapshot))
                  return memoizedSelection = currentSelection;
              }
              return memoizedSelection = nextSnapshot;
            }
            currentSelection = memoizedSelection;
            if (objectIs(memoizedSnapshot, nextSnapshot))
              return currentSelection;
            var nextSelection = selector(nextSnapshot);
            if (void 0 !== isEqual2 && isEqual2(currentSelection, nextSelection))
              return memoizedSnapshot = nextSnapshot, currentSelection;
            memoizedSnapshot = nextSnapshot;
            return memoizedSelection = nextSelection;
          }
          var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
          return [
            function() {
              return memoizedSelector(getSnapshot());
            },
            null === maybeGetServerSnapshot ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            }
          ];
        },
        [getSnapshot, getServerSnapshot, selector, isEqual2]
      );
      var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
      useEffect(
        function() {
          inst.hasValue = true;
          inst.value = value;
        },
        [value]
      );
      useDebugValue(value);
      return value;
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
  var withSelector$3 = withSelector$5.exports;
  "use strict";
  if (false) {
    module.exports = require("../cjs/use-sync-external-store-shim/with-selector.production.js");
  } else {
    withSelector$5.exports = withSelector_development;
  }
  var withSelectorExports$1 = withSelector$5.exports;
  const withSelector$4 = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports$1);
  var RechartsReduxContext = /* @__PURE__ */ React.createContext(null);
  var noopDispatch = (a2) => a2;
  var useAppDispatch = () => {
    var context = React.useContext(RechartsReduxContext);
    if (context) {
      return context.store.dispatch;
    }
    return noopDispatch;
  };
  var noop$7 = () => {
  };
  var addNestedSubNoop = () => noop$7;
  var refEquality$1 = (a2, b) => a2 === b;
  function useAppSelector(selector) {
    var context = React.useContext(RechartsReduxContext);
    return withSelectorExports$1.useSyncExternalStoreWithSelector(context ? context.subscription.addNestedSub : addNestedSubNoop, context ? context.store.getState : noop$7, context ? context.store.getState : noop$7, context ? selector : noop$7, refEquality$1);
  }
  var runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {
    if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
      let isInputSameAsOutput = false;
      try {
        const emptyObject2 = {};
        if (resultFunc(emptyObject2) === emptyObject2)
          isInputSameAsOutput = true;
      } catch {
      }
      if (isInputSameAsOutput) {
        let stack = void 0;
        try {
          throw new Error();
        } catch (e) {
          ;
          ({ stack } = e);
        }
        console.warn(
          "The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.",
          { stack }
        );
      }
    }
  };
  var runInputStabilityCheck = (inputSelectorResultsObject, options2, inputSelectorArgs) => {
    const { memoize: memoize2, memoizeOptions } = options2;
    const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;
    const createAnEmptyObject = memoize2(() => ({}), ...memoizeOptions);
    const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);
    if (!areInputSelectorResultsEqual) {
      let stack = void 0;
      try {
        throw new Error();
      } catch (e) {
        ;
        ({ stack } = e);
      }
      console.warn(
        "An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`",
        {
          arguments: inputSelectorArgs,
          firstInputs: inputSelectorResults,
          secondInputs: inputSelectorResultsCopy,
          stack
        }
      );
    }
  };
  var globalDevModeChecks = {
    inputStabilityCheck: "once",
    identityFunctionCheck: "once"
  };
  var setGlobalDevModeChecks = (devModeChecks) => {
    Object.assign(globalDevModeChecks, devModeChecks);
  };
  var NOT_FOUND = /* @__PURE__ */ Symbol("NOT_FOUND");
  function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
    if (typeof func !== "function") {
      throw new TypeError(errorMessage);
    }
  }
  function assertIsObject(object2, errorMessage = `expected an object, instead received ${typeof object2}`) {
    if (typeof object2 !== "object") {
      throw new TypeError(errorMessage);
    }
  }
  function assertIsArrayOfFunctions(array2, errorMessage = `expected all items to be functions, instead received the following types: `) {
    if (!array2.every((item) => typeof item === "function")) {
      const itemTypes = array2.map(
        (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
      ).join(", ");
      throw new TypeError(`${errorMessage}[${itemTypes}]`);
    }
  }
  var ensureIsArray = (item) => {
    return Array.isArray(item) ? item : [item];
  };
  function getDependencies(createSelectorArgs) {
    const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
    assertIsArrayOfFunctions(
      dependencies,
      `createSelector expects all input-selectors to be functions, but received the following types: `
    );
    return dependencies;
  }
  function collectInputSelectorResults(dependencies, inputSelectorArgs) {
    const inputSelectorResults = [];
    const { length: length2 } = dependencies;
    for (let i = 0; i < length2; i++) {
      inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
    }
    return inputSelectorResults;
  }
  var getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {
    const { identityFunctionCheck, inputStabilityCheck } = {
      ...globalDevModeChecks,
      ...devModeChecks
    };
    return {
      identityFunctionCheck: {
        shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
        run: runIdentityFunctionCheck
      },
      inputStabilityCheck: {
        shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
        run: runInputStabilityCheck
      }
    };
  };
  var $REVISION = 0;
  var CURRENT_TRACKER = null;
  var Cell$1 = class Cell {
    constructor(initialValue, isEqual2 = tripleEq) {
      __publicField(this, "revision", $REVISION);
      __publicField(this, "_value");
      __publicField(this, "_lastValue");
      __publicField(this, "_isEqual", tripleEq);
      this._value = this._lastValue = initialValue;
      this._isEqual = isEqual2;
    }
    // Whenever a storage value is read, it'll add itself to the current tracker if
    // one exists, entangling its state with that cache.
    get value() {
      CURRENT_TRACKER == null ? void 0 : CURRENT_TRACKER.add(this);
      return this._value;
    }
    // Whenever a storage value is updated, we bump the global revision clock,
    // assign the revision for this storage to the new value, _and_ we schedule a
    // rerender. This is important, and it's what makes autotracking  _pull_
    // based. We don't actively tell the caches which depend on the storage that
    // anything has happened. Instead, we recompute the caches when needed.
    set value(newValue) {
      if (this.value === newValue)
        return;
      this._value = newValue;
      this.revision = ++$REVISION;
    }
  };
  function tripleEq(a2, b) {
    return a2 === b;
  }
  var TrackingCache = class {
    constructor(fn) {
      __publicField(this, "_cachedValue");
      __publicField(this, "_cachedRevision", -1);
      __publicField(this, "_deps", []);
      __publicField(this, "hits", 0);
      __publicField(this, "fn");
      this.fn = fn;
    }
    clear() {
      this._cachedValue = void 0;
      this._cachedRevision = -1;
      this._deps = [];
      this.hits = 0;
    }
    get value() {
      if (this.revision > this._cachedRevision) {
        const { fn } = this;
        const currentTracker = /* @__PURE__ */ new Set();
        const prevTracker = CURRENT_TRACKER;
        CURRENT_TRACKER = currentTracker;
        this._cachedValue = fn();
        CURRENT_TRACKER = prevTracker;
        this.hits++;
        this._deps = Array.from(currentTracker);
        this._cachedRevision = this.revision;
      }
      CURRENT_TRACKER == null ? void 0 : CURRENT_TRACKER.add(this);
      return this._cachedValue;
    }
    get revision() {
      return Math.max(...this._deps.map((d) => d.revision), 0);
    }
  };
  function getValue$1(cell) {
    if (!(cell instanceof Cell$1)) {
      console.warn("Not a valid cell! ", cell);
    }
    return cell.value;
  }
  function setValue(storage, value) {
    if (!(storage instanceof Cell$1)) {
      throw new TypeError(
        "setValue must be passed a tracked store created with `createStorage`."
      );
    }
    storage.value = storage._lastValue = value;
  }
  function createCell(initialValue, isEqual2 = tripleEq) {
    return new Cell$1(initialValue, isEqual2);
  }
  function createCache(fn) {
    assertIsFunction(
      fn,
      "the first parameter to `createCache` must be a function"
    );
    return new TrackingCache(fn);
  }
  var neverEq = (a2, b) => false;
  function createTag() {
    return createCell(null, neverEq);
  }
  function dirtyTag(tag, value) {
    setValue(tag, value);
  }
  var consumeCollection = (node) => {
    let tag = node.collectionTag;
    if (tag === null) {
      tag = node.collectionTag = createTag();
    }
    getValue$1(tag);
  };
  var dirtyCollection = (node) => {
    const tag = node.collectionTag;
    if (tag !== null) {
      dirtyTag(tag, null);
    }
  };
  var REDUX_PROXY_LABEL = Symbol();
  var nextId = 0;
  var proto = Object.getPrototypeOf({});
  var ObjectTreeNode = class {
    constructor(value) {
      __publicField(this, "proxy", new Proxy(this, objectProxyHandler));
      __publicField(this, "tag", createTag());
      __publicField(this, "tags", {});
      __publicField(this, "children", {});
      __publicField(this, "collectionTag", null);
      __publicField(this, "id", nextId++);
      this.value = value;
      this.value = value;
      this.tag.value = value;
    }
  };
  var objectProxyHandler = {
    get(node, key) {
      function calculateResult() {
        const { value } = node;
        const childValue = Reflect.get(value, key);
        if (typeof key === "symbol") {
          return childValue;
        }
        if (key in proto) {
          return childValue;
        }
        if (typeof childValue === "object" && childValue !== null) {
          let childNode = node.children[key];
          if (childNode === void 0) {
            childNode = node.children[key] = createNode(childValue);
          }
          if (childNode.tag) {
            getValue$1(childNode.tag);
          }
          return childNode.proxy;
        } else {
          let tag = node.tags[key];
          if (tag === void 0) {
            tag = node.tags[key] = createTag();
            tag.value = childValue;
          }
          getValue$1(tag);
          return childValue;
        }
      }
      const res = calculateResult();
      return res;
    },
    ownKeys(node) {
      consumeCollection(node);
      return Reflect.ownKeys(node.value);
    },
    getOwnPropertyDescriptor(node, prop) {
      return Reflect.getOwnPropertyDescriptor(node.value, prop);
    },
    has(node, prop) {
      return Reflect.has(node.value, prop);
    }
  };
  var ArrayTreeNode = class {
    constructor(value) {
      __publicField(this, "proxy", new Proxy([this], arrayProxyHandler));
      __publicField(this, "tag", createTag());
      __publicField(this, "tags", {});
      __publicField(this, "children", {});
      __publicField(this, "collectionTag", null);
      __publicField(this, "id", nextId++);
      this.value = value;
      this.value = value;
      this.tag.value = value;
    }
  };
  var arrayProxyHandler = {
    get([node], key) {
      if (key === "length") {
        consumeCollection(node);
      }
      return objectProxyHandler.get(node, key);
    },
    ownKeys([node]) {
      return objectProxyHandler.ownKeys(node);
    },
    getOwnPropertyDescriptor([node], prop) {
      return objectProxyHandler.getOwnPropertyDescriptor(node, prop);
    },
    has([node], prop) {
      return objectProxyHandler.has(node, prop);
    }
  };
  function createNode(value) {
    if (Array.isArray(value)) {
      return new ArrayTreeNode(value);
    }
    return new ObjectTreeNode(value);
  }
  function updateNode(node, newValue) {
    const { value, tags: tags2, children } = node;
    node.value = newValue;
    if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {
      dirtyCollection(node);
    } else {
      if (value !== newValue) {
        let oldKeysSize = 0;
        let newKeysSize = 0;
        let anyKeysAdded = false;
        for (const _key in value) {
          oldKeysSize++;
        }
        for (const key in newValue) {
          newKeysSize++;
          if (!(key in value)) {
            anyKeysAdded = true;
            break;
          }
        }
        const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;
        if (isDifferent) {
          dirtyCollection(node);
        }
      }
    }
    for (const key in tags2) {
      const childValue = value[key];
      const newChildValue = newValue[key];
      if (childValue !== newChildValue) {
        dirtyCollection(node);
        dirtyTag(tags2[key], newChildValue);
      }
      if (typeof newChildValue === "object" && newChildValue !== null) {
        delete tags2[key];
      }
    }
    for (const key in children) {
      const childNode = children[key];
      const newChildValue = newValue[key];
      const childValue = childNode.value;
      if (childValue === newChildValue) {
        continue;
      } else if (typeof newChildValue === "object" && newChildValue !== null) {
        updateNode(childNode, newChildValue);
      } else {
        deleteNode(childNode);
        delete children[key];
      }
    }
  }
  function deleteNode(node) {
    if (node.tag) {
      dirtyTag(node.tag, null);
    }
    dirtyCollection(node);
    for (const key in node.tags) {
      dirtyTag(node.tags[key], null);
    }
    for (const key in node.children) {
      deleteNode(node.children[key]);
    }
  }
  function createSingletonCache(equals) {
    let entry;
    return {
      get(key) {
        if (entry && equals(entry.key, key)) {
          return entry.value;
        }
        return NOT_FOUND;
      },
      put(key, value) {
        entry = { key, value };
      },
      getEntries() {
        return entry ? [entry] : [];
      },
      clear() {
        entry = void 0;
      }
    };
  }
  function createLruCache(maxSize, equals) {
    let entries = [];
    function get2(key) {
      const cacheIndex = entries.findIndex((entry) => equals(key, entry.key));
      if (cacheIndex > -1) {
        const entry = entries[cacheIndex];
        if (cacheIndex > 0) {
          entries.splice(cacheIndex, 1);
          entries.unshift(entry);
        }
        return entry.value;
      }
      return NOT_FOUND;
    }
    function put(key, value) {
      if (get2(key) === NOT_FOUND) {
        entries.unshift({ key, value });
        if (entries.length > maxSize) {
          entries.pop();
        }
      }
    }
    function getEntries() {
      return entries;
    }
    function clear() {
      entries = [];
    }
    return { get: get2, put, getEntries, clear };
  }
  var referenceEqualityCheck = (a2, b) => a2 === b;
  function createCacheKeyComparator(equalityCheck) {
    return function areArgumentsShallowlyEqual(prev, next) {
      if (prev === null || next === null || prev.length !== next.length) {
        return false;
      }
      const { length: length2 } = prev;
      for (let i = 0; i < length2; i++) {
        if (!equalityCheck(prev[i], next[i])) {
          return false;
        }
      }
      return true;
    };
  }
  function lruMemoize(func, equalityCheckOrOptions) {
    const providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : { equalityCheck: equalityCheckOrOptions };
    const {
      equalityCheck = referenceEqualityCheck,
      maxSize = 1,
      resultEqualityCheck
    } = providedOptions;
    const comparator = createCacheKeyComparator(equalityCheck);
    let resultsCount = 0;
    const cache = maxSize <= 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
    function memoized() {
      let value = cache.get(arguments);
      if (value === NOT_FOUND) {
        value = func.apply(null, arguments);
        resultsCount++;
        if (resultEqualityCheck) {
          const entries = cache.getEntries();
          const matchingEntry = entries.find(
            (entry) => resultEqualityCheck(entry.value, value)
          );
          if (matchingEntry) {
            value = matchingEntry.value;
            resultsCount !== 0 && resultsCount--;
          }
        }
        cache.put(arguments, value);
      }
      return value;
    }
    memoized.clearCache = () => {
      cache.clear();
      memoized.resetResultsCount();
    };
    memoized.resultsCount = () => resultsCount;
    memoized.resetResultsCount = () => {
      resultsCount = 0;
    };
    return memoized;
  }
  function autotrackMemoize(func) {
    const node = createNode(
      []
    );
    let lastArgs = null;
    const shallowEqual2 = createCacheKeyComparator(referenceEqualityCheck);
    const cache = createCache(() => {
      const res = func.apply(null, node.proxy);
      return res;
    });
    function memoized() {
      if (!shallowEqual2(lastArgs, arguments)) {
        updateNode(node, arguments);
        lastArgs = arguments;
      }
      return cache.value;
    }
    memoized.clearCache = () => {
      return cache.clear();
    };
    return memoized;
  }
  var StrongRef = class {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value;
    }
  };
  var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
  var UNTERMINATED = 0;
  var TERMINATED = 1;
  function createCacheNode() {
    return {
      s: UNTERMINATED,
      v: void 0,
      o: null,
      p: null
    };
  }
  function weakMapMemoize(func, options2 = {}) {
    let fnNode = createCacheNode();
    const { resultEqualityCheck } = options2;
    let lastResult2;
    let resultsCount = 0;
    function memoized() {
      var _a;
      let cacheNode = fnNode;
      const { length: length2 } = arguments;
      for (let i = 0, l = length2; i < l; i++) {
        const arg = arguments[i];
        if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
          let objectCache = cacheNode.o;
          if (objectCache === null) {
            cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
          }
          const objectNode = objectCache.get(arg);
          if (objectNode === void 0) {
            cacheNode = createCacheNode();
            objectCache.set(arg, cacheNode);
          } else {
            cacheNode = objectNode;
          }
        } else {
          let primitiveCache = cacheNode.p;
          if (primitiveCache === null) {
            cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
          }
          const primitiveNode = primitiveCache.get(arg);
          if (primitiveNode === void 0) {
            cacheNode = createCacheNode();
            primitiveCache.set(arg, cacheNode);
          } else {
            cacheNode = primitiveNode;
          }
        }
      }
      const terminatedNode = cacheNode;
      let result;
      if (cacheNode.s === TERMINATED) {
        result = cacheNode.v;
      } else {
        result = func.apply(null, arguments);
        resultsCount++;
        if (resultEqualityCheck) {
          const lastResultValue = ((_a = lastResult2 == null ? void 0 : lastResult2.deref) == null ? void 0 : _a.call(lastResult2)) ?? lastResult2;
          if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
            result = lastResultValue;
            resultsCount !== 0 && resultsCount--;
          }
          const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
          lastResult2 = needsWeakRef ? new Ref(result) : result;
        }
      }
      terminatedNode.s = TERMINATED;
      terminatedNode.v = result;
      return result;
    }
    memoized.clearCache = () => {
      fnNode = createCacheNode();
      memoized.resetResultsCount();
    };
    memoized.resultsCount = () => resultsCount;
    memoized.resetResultsCount = () => {
      resultsCount = 0;
    };
    return memoized;
  }
  function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
    const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
      memoize: memoizeOrOptions,
      memoizeOptions: memoizeOptionsFromArgs
    } : memoizeOrOptions;
    const createSelector2 = (...createSelectorArgs) => {
      let recomputations = 0;
      let dependencyRecomputations = 0;
      let lastResult2;
      let directlyPassedOptions = {};
      let resultFunc = createSelectorArgs.pop();
      if (typeof resultFunc === "object") {
        directlyPassedOptions = resultFunc;
        resultFunc = createSelectorArgs.pop();
      }
      assertIsFunction(
        resultFunc,
        `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
      );
      const combinedOptions = {
        ...createSelectorCreatorOptions,
        ...directlyPassedOptions
      };
      const {
        memoize: memoize2,
        memoizeOptions = [],
        argsMemoize = weakMapMemoize,
        argsMemoizeOptions = [],
        devModeChecks = {}
      } = combinedOptions;
      const finalMemoizeOptions = ensureIsArray(memoizeOptions);
      const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
      const dependencies = getDependencies(createSelectorArgs);
      const memoizedResultFunc = memoize2(function recomputationWrapper() {
        recomputations++;
        return resultFunc.apply(
          null,
          arguments
        );
      }, ...finalMemoizeOptions);
      let firstRun = true;
      const selector = argsMemoize(function dependenciesChecker() {
        dependencyRecomputations++;
        const inputSelectorResults = collectInputSelectorResults(
          dependencies,
          arguments
        );
        lastResult2 = memoizedResultFunc.apply(null, inputSelectorResults);
        if (true) {
          const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);
          if (identityFunctionCheck.shouldRun) {
            identityFunctionCheck.run(
              resultFunc,
              inputSelectorResults,
              lastResult2
            );
          }
          if (inputStabilityCheck.shouldRun) {
            const inputSelectorResultsCopy = collectInputSelectorResults(
              dependencies,
              arguments
            );
            inputStabilityCheck.run(
              { inputSelectorResults, inputSelectorResultsCopy },
              { memoize: memoize2, memoizeOptions: finalMemoizeOptions },
              arguments
            );
          }
          if (firstRun)
            firstRun = false;
        }
        return lastResult2;
      }, ...finalArgsMemoizeOptions);
      return Object.assign(selector, {
        resultFunc,
        memoizedResultFunc,
        dependencies,
        dependencyRecomputations: () => dependencyRecomputations,
        resetDependencyRecomputations: () => {
          dependencyRecomputations = 0;
        },
        lastResult: () => lastResult2,
        recomputations: () => recomputations,
        resetRecomputations: () => {
          recomputations = 0;
        },
        memoize: memoize2,
        argsMemoize
      });
    };
    Object.assign(createSelector2, {
      withTypes: () => createSelector2
    });
    return createSelector2;
  }
  var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
  var createStructuredSelector = Object.assign(
    (inputSelectorsObject, selectorCreator = createSelector) => {
      assertIsObject(
        inputSelectorsObject,
        `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
      );
      const inputSelectorKeys = Object.keys(inputSelectorsObject);
      const dependencies = inputSelectorKeys.map(
        (key) => inputSelectorsObject[key]
      );
      const structuredSelector = selectorCreator(
        dependencies,
        (...inputSelectorResults) => {
          return inputSelectorResults.reduce((composition, value, index2) => {
            composition[inputSelectorKeys[index2]] = value;
            return composition;
          }, {});
        }
      );
      return structuredSelector;
    },
    { withTypes: () => createStructuredSelector }
  );
  var sortBy$4 = {};
  var orderBy$2 = {};
  var compareValues$2 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function getPriority(a2) {
      if (typeof a2 === "symbol") {
        return 1;
      }
      if (a2 === null) {
        return 2;
      }
      if (a2 === void 0) {
        return 3;
      }
      if (a2 !== a2) {
        return 4;
      }
      return 0;
    }
    const compareValues2 = (a2, b, order) => {
      if (a2 !== b) {
        const aPriority = getPriority(a2);
        const bPriority = getPriority(b);
        if (aPriority === bPriority && aPriority === 0) {
          if (a2 < b) {
            return order === "desc" ? 1 : -1;
          }
          if (a2 > b) {
            return order === "desc" ? -1 : 1;
          }
        }
        return order === "desc" ? bPriority - aPriority : aPriority - bPriority;
      }
      return 0;
    };
    exports3.compareValues = compareValues2;
  })(compareValues$2);
  const compareValues$1 = /* @__PURE__ */ getDefaultExportFromCjs(compareValues$2);
  var isKey$1 = {};
  var isSymbol$3 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function isSymbol2(value) {
      return typeof value === "symbol" || value instanceof Symbol;
    }
    exports3.isSymbol = isSymbol2;
  })(isSymbol$3);
  const isSymbol$2 = /* @__PURE__ */ getDefaultExportFromCjs(isSymbol$3);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const isSymbol2 = isSymbol$3;
    const regexIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    const regexIsPlainProp = /^\w*$/;
    function isKey2(value, object2) {
      if (Array.isArray(value)) {
        return false;
      }
      if (typeof value === "number" || typeof value === "boolean" || value == null || isSymbol2.isSymbol(value)) {
        return true;
      }
      return typeof value === "string" && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value)) || object2 != null && Object.hasOwn(object2, value);
    }
    exports3.isKey = isKey2;
  })(isKey$1);
  const isKey = /* @__PURE__ */ getDefaultExportFromCjs(isKey$1);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const compareValues2 = compareValues$2;
    const isKey2 = isKey$1;
    const toPath2 = toPath$1;
    function orderBy2(collection, criteria, orders, guard) {
      if (collection == null) {
        return [];
      }
      orders = guard ? void 0 : orders;
      if (!Array.isArray(collection)) {
        collection = Object.values(collection);
      }
      if (!Array.isArray(criteria)) {
        criteria = criteria == null ? [null] : [criteria];
      }
      if (criteria.length === 0) {
        criteria = [null];
      }
      if (!Array.isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      orders = orders.map((order) => String(order));
      const getValueByNestedPath = (object2, path2) => {
        let target = object2;
        for (let i = 0; i < path2.length && target != null; ++i) {
          target = target[path2[i]];
        }
        return target;
      };
      const getValueByCriterion = (criterion, object2) => {
        if (object2 == null || criterion == null) {
          return object2;
        }
        if (typeof criterion === "object" && "key" in criterion) {
          if (Object.hasOwn(object2, criterion.key)) {
            return object2[criterion.key];
          }
          return getValueByNestedPath(object2, criterion.path);
        }
        if (typeof criterion === "function") {
          return criterion(object2);
        }
        if (Array.isArray(criterion)) {
          return getValueByNestedPath(object2, criterion);
        }
        if (typeof object2 === "object") {
          return object2[criterion];
        }
        return object2;
      };
      const preparedCriteria = criteria.map((criterion) => {
        if (Array.isArray(criterion) && criterion.length === 1) {
          criterion = criterion[0];
        }
        if (criterion == null || typeof criterion === "function" || Array.isArray(criterion) || isKey2.isKey(criterion)) {
          return criterion;
        }
        return { key: criterion, path: toPath2.toPath(criterion) };
      });
      const preparedCollection = collection.map((item) => ({
        original: item,
        criteria: preparedCriteria.map((criterion) => getValueByCriterion(criterion, item))
      }));
      return preparedCollection.slice().sort((a2, b) => {
        for (let i = 0; i < preparedCriteria.length; i++) {
          const comparedResult = compareValues2.compareValues(a2.criteria[i], b.criteria[i], orders[i]);
          if (comparedResult !== 0) {
            return comparedResult;
          }
        }
        return 0;
      }).map((item) => item.original);
    }
    exports3.orderBy = orderBy2;
  })(orderBy$2);
  const orderBy$1 = /* @__PURE__ */ getDefaultExportFromCjs(orderBy$2);
  var flatten$4 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function flatten2(arr, depth = 1) {
      const result = [];
      const flooredDepth = Math.floor(depth);
      const recursive = (arr2, currentDepth) => {
        for (let i = 0; i < arr2.length; i++) {
          const item = arr2[i];
          if (Array.isArray(item) && currentDepth < flooredDepth) {
            recursive(item, currentDepth + 1);
          } else {
            result.push(item);
          }
        }
      };
      recursive(arr, 0);
      return result;
    }
    exports3.flatten = flatten2;
  })(flatten$4);
  const flatten$3 = /* @__PURE__ */ getDefaultExportFromCjs(flatten$4);
  var isIterateeCall$1 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const isIndex2 = isIndex$1;
    const isArrayLike2 = isArrayLike$1;
    const isObject2 = isObject$1;
    const eq2 = eq$2;
    function isIterateeCall2(value, index2, object2) {
      if (!isObject2.isObject(object2)) {
        return false;
      }
      if (typeof index2 === "number" && isArrayLike2.isArrayLike(object2) && isIndex2.isIndex(index2) && index2 < object2.length || typeof index2 === "string" && index2 in object2) {
        return eq2.eq(object2[index2], value);
      }
      return false;
    }
    exports3.isIterateeCall = isIterateeCall2;
  })(isIterateeCall$1);
  const isIterateeCall = /* @__PURE__ */ getDefaultExportFromCjs(isIterateeCall$1);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const orderBy2 = orderBy$2;
    const flatten2 = flatten$4;
    const isIterateeCall2 = isIterateeCall$1;
    function sortBy2(collection, ...criteria) {
      const length2 = criteria.length;
      if (length2 > 1 && isIterateeCall2.isIterateeCall(collection, criteria[0], criteria[1])) {
        criteria = [];
      } else if (length2 > 2 && isIterateeCall2.isIterateeCall(criteria[0], criteria[1], criteria[2])) {
        criteria = [criteria[0]];
      }
      return orderBy2.orderBy(collection, flatten2.flatten(criteria), ["asc"]);
    }
    exports3.sortBy = sortBy2;
  })(sortBy$4);
  const sortBy$3 = /* @__PURE__ */ getDefaultExportFromCjs(sortBy$4);
  var sortBy$1 = sortBy$4.sortBy;
  const sortBy$2 = /* @__PURE__ */ getDefaultExportFromCjs(sortBy$1);
  var selectLegendSettings = (state) => state.legend.settings;
  var selectLegendSize = (state) => state.legend.size;
  var selectAllLegendPayload2DArray = (state) => state.legend.payload;
  var selectLegendPayload = createSelector([selectAllLegendPayload2DArray, selectLegendSettings], (payloads, _ref2) => {
    var {
      itemSorter
    } = _ref2;
    var flat = payloads.flat(1);
    return itemSorter ? sortBy$2(flat, itemSorter) : flat;
  });
  function useLegendPayload() {
    return useAppSelector(selectLegendPayload);
  }
  var EPS$1 = 1;
  function useElementOffset() {
    var extraDependencies = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var [lastBoundingBox, setLastBoundingBox] = React.useState({
      height: 0,
      left: 0,
      top: 0,
      width: 0
    });
    var updateBoundingBox = React.useCallback((node) => {
      if (node != null) {
        var rect = node.getBoundingClientRect();
        var box = {
          height: rect.height,
          left: rect.left,
          top: rect.top,
          width: rect.width
        };
        if (Math.abs(box.height - lastBoundingBox.height) > EPS$1 || Math.abs(box.left - lastBoundingBox.left) > EPS$1 || Math.abs(box.top - lastBoundingBox.top) > EPS$1 || Math.abs(box.width - lastBoundingBox.width) > EPS$1) {
          setLastBoundingBox({
            height: box.height,
            left: box.left,
            top: box.top,
            width: box.width
          });
        }
      }
    }, [lastBoundingBox.width, lastBoundingBox.height, lastBoundingBox.top, lastBoundingBox.left, ...extraDependencies]);
    return [lastBoundingBox, updateBoundingBox];
  }
  function formatProdErrorMessage$1(code) {
    return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
  }
  var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
  var symbol_observable_default = $$observable;
  var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
  var ActionTypes = {
    INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,
    REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,
    PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
  };
  var actionTypes_default = ActionTypes;
  function isPlainObject$a(obj) {
    if (typeof obj !== "object" || obj === null)
      return false;
    let proto2 = obj;
    while (Object.getPrototypeOf(proto2) !== null) {
      proto2 = Object.getPrototypeOf(proto2);
    }
    return Object.getPrototypeOf(obj) === proto2 || Object.getPrototypeOf(obj) === null;
  }
  function miniKindOf(val) {
    if (val === void 0)
      return "undefined";
    if (val === null)
      return "null";
    const type = typeof val;
    switch (type) {
      case "boolean":
      case "string":
      case "number":
      case "symbol":
      case "function": {
        return type;
      }
    }
    if (Array.isArray(val))
      return "array";
    if (isDate$1(val))
      return "date";
    if (isError$1(val))
      return "error";
    const constructorName = ctorName(val);
    switch (constructorName) {
      case "Symbol":
      case "Promise":
      case "WeakMap":
      case "WeakSet":
      case "Map":
      case "Set":
        return constructorName;
    }
    return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
  }
  function ctorName(val) {
    return typeof val.constructor === "function" ? val.constructor.name : null;
  }
  function isError$1(val) {
    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
  }
  function isDate$1(val) {
    if (val instanceof Date)
      return true;
    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
  }
  function kindOf(val) {
    let typeOfVal = typeof val;
    if (true) {
      typeOfVal = miniKindOf(val);
    }
    return typeOfVal;
  }
  function createStore(reducer2, preloadedState2, enhancer) {
    if (typeof reducer2 !== "function") {
      throw new Error(false ? formatProdErrorMessage$1(2) : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer2)}'`);
    }
    if (typeof preloadedState2 === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
      throw new Error(false ? formatProdErrorMessage$1(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
    }
    if (typeof preloadedState2 === "function" && typeof enhancer === "undefined") {
      enhancer = preloadedState2;
      preloadedState2 = void 0;
    }
    if (typeof enhancer !== "undefined") {
      if (typeof enhancer !== "function") {
        throw new Error(false ? formatProdErrorMessage$1(1) : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);
      }
      return enhancer(createStore)(reducer2, preloadedState2);
    }
    let currentReducer = reducer2;
    let currentState = preloadedState2;
    let currentListeners = /* @__PURE__ */ new Map();
    let nextListeners = currentListeners;
    let listenerIdCounter = 0;
    let isDispatching = false;
    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = /* @__PURE__ */ new Map();
        currentListeners.forEach((listener2, key) => {
          nextListeners.set(key, listener2);
        });
      }
    }
    function getState() {
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage$1(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
      }
      return currentState;
    }
    function subscribe(listener2) {
      if (typeof listener2 !== "function") {
        throw new Error(false ? formatProdErrorMessage$1(4) : `Expected the listener to be a function. Instead, received: '${kindOf(listener2)}'`);
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage$1(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      let isSubscribed = true;
      ensureCanMutateNextListeners();
      const listenerId = listenerIdCounter++;
      nextListeners.set(listenerId, listener2);
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }
        if (isDispatching) {
          throw new Error(false ? formatProdErrorMessage$1(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        }
        isSubscribed = false;
        ensureCanMutateNextListeners();
        nextListeners.delete(listenerId);
        currentListeners = null;
      };
    }
    function dispatch(action) {
      if (!isPlainObject$a(action)) {
        throw new Error(false ? formatProdErrorMessage$1(7) : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
      }
      if (typeof action.type === "undefined") {
        throw new Error(false ? formatProdErrorMessage$1(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
      }
      if (typeof action.type !== "string") {
        throw new Error(false ? formatProdErrorMessage$1(17) : `Action "type" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage$1(9) : "Reducers may not dispatch actions.");
      }
      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }
      const listeners = currentListeners = nextListeners;
      listeners.forEach((listener2) => {
        listener2();
      });
      return action;
    }
    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== "function") {
        throw new Error(false ? formatProdErrorMessage$1(10) : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);
      }
      currentReducer = nextReducer;
      dispatch({
        type: actionTypes_default.REPLACE
      });
    }
    function observable() {
      const outerSubscribe = subscribe;
      return {
        /**
         * The minimal observable subscription method.
         * @param observer Any object that can be used as an observer.
         * The observer object should have a `next` method.
         * @returns An object with an `unsubscribe` method that can
         * be used to unsubscribe the observable from the store, and prevent further
         * emission of values from the observable.
         */
        subscribe(observer) {
          if (typeof observer !== "object" || observer === null) {
            throw new Error(false ? formatProdErrorMessage$1(11) : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);
          }
          function observeState() {
            const observerAsObserver = observer;
            if (observerAsObserver.next) {
              observerAsObserver.next(getState());
            }
          }
          observeState();
          const unsubscribe = outerSubscribe(observeState);
          return {
            unsubscribe
          };
        },
        [symbol_observable_default]() {
          return this;
        }
      };
    }
    dispatch({
      type: actionTypes_default.INIT
    });
    const store = {
      dispatch,
      subscribe,
      getState,
      replaceReducer,
      [symbol_observable_default]: observable
    };
    return store;
  }
  function legacy_createStore(reducer2, preloadedState2, enhancer) {
    return createStore(reducer2, preloadedState2, enhancer);
  }
  function warning$1(message) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
      console.error(message);
    }
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
  function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
    const reducerKeys = Object.keys(reducers);
    const argumentName = action && action.type === actionTypes_default.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
    if (reducerKeys.length === 0) {
      return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
    }
    if (!isPlainObject$a(inputState)) {
      return `The ${argumentName} has unexpected type of "${kindOf(inputState)}". Expected argument to be an object with the following keys: "${reducerKeys.join('", "')}"`;
    }
    const unexpectedKeys = Object.keys(inputState).filter((key) => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);
    unexpectedKeys.forEach((key) => {
      unexpectedKeyCache[key] = true;
    });
    if (action && action.type === actionTypes_default.REPLACE)
      return;
    if (unexpectedKeys.length > 0) {
      return `Unexpected ${unexpectedKeys.length > 1 ? "keys" : "key"} "${unexpectedKeys.join('", "')}" found in ${argumentName}. Expected to find one of the known reducer keys instead: "${reducerKeys.join('", "')}". Unexpected keys will be ignored.`;
    }
  }
  function assertReducerShape(reducers) {
    Object.keys(reducers).forEach((key) => {
      const reducer2 = reducers[key];
      const initialState2 = reducer2(void 0, {
        type: actionTypes_default.INIT
      });
      if (typeof initialState2 === "undefined") {
        throw new Error(false ? formatProdErrorMessage$1(12) : `The slice reducer for key "${key}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
      }
      if (typeof reducer2(void 0, {
        type: actionTypes_default.PROBE_UNKNOWN_ACTION()
      }) === "undefined") {
        throw new Error(false ? formatProdErrorMessage$1(13) : `The slice reducer for key "${key}" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
      }
    });
  }
  function combineReducers(reducers) {
    const reducerKeys = Object.keys(reducers);
    const finalReducers = {};
    for (let i = 0; i < reducerKeys.length; i++) {
      const key = reducerKeys[i];
      if (true) {
        if (typeof reducers[key] === "undefined") {
          warning$1(`No reducer provided for key "${key}"`);
        }
      }
      if (typeof reducers[key] === "function") {
        finalReducers[key] = reducers[key];
      }
    }
    const finalReducerKeys = Object.keys(finalReducers);
    let unexpectedKeyCache;
    if (true) {
      unexpectedKeyCache = {};
    }
    let shapeAssertionError;
    try {
      assertReducerShape(finalReducers);
    } catch (e) {
      shapeAssertionError = e;
    }
    return function combination(state = {}, action) {
      if (shapeAssertionError) {
        throw shapeAssertionError;
      }
      if (true) {
        const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
        if (warningMessage) {
          warning$1(warningMessage);
        }
      }
      let hasChanged = false;
      const nextState = {};
      for (let i = 0; i < finalReducerKeys.length; i++) {
        const key = finalReducerKeys[i];
        const reducer2 = finalReducers[key];
        const previousStateForKey = state[key];
        const nextStateForKey = reducer2(previousStateForKey, action);
        if (typeof nextStateForKey === "undefined") {
          const actionType = action && action.type;
          throw new Error(false ? formatProdErrorMessage$1(14) : `When called with an action of type ${actionType ? `"${String(actionType)}"` : "(unknown type)"}, the slice reducer for key "${key}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
        }
        nextState[key] = nextStateForKey;
        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      }
      hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
      return hasChanged ? nextState : state;
    };
  }
  function bindActionCreator(actionCreator, dispatch) {
    return function(...args) {
      return dispatch(actionCreator.apply(this, args));
    };
  }
  function bindActionCreators$1(actionCreators, dispatch) {
    if (typeof actionCreators === "function") {
      return bindActionCreator(actionCreators, dispatch);
    }
    if (typeof actionCreators !== "object" || actionCreators === null) {
      throw new Error(false ? formatProdErrorMessage$1(16) : `bindActionCreators expected an object or a function, but instead received: '${kindOf(actionCreators)}'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?`);
    }
    const boundActionCreators = {};
    for (const key in actionCreators) {
      const actionCreator = actionCreators[key];
      if (typeof actionCreator === "function") {
        boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
      }
    }
    return boundActionCreators;
  }
  function compose$1(...funcs) {
    if (funcs.length === 0) {
      return (arg) => arg;
    }
    if (funcs.length === 1) {
      return funcs[0];
    }
    return funcs.reduce((a2, b) => (...args) => a2(b(...args)));
  }
  function applyMiddleware(...middlewares) {
    return (createStore2) => (reducer2, preloadedState2) => {
      const store = createStore2(reducer2, preloadedState2);
      let dispatch = () => {
        throw new Error(false ? formatProdErrorMessage$1(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
      };
      const middlewareAPI = {
        getState: store.getState,
        dispatch: (action, ...args) => dispatch(action, ...args)
      };
      const chain = middlewares.map((middleware) => middleware(middlewareAPI));
      dispatch = compose$1(...chain)(store.dispatch);
      return {
        ...store,
        dispatch
      };
    };
  }
  function isAction(action) {
    return isPlainObject$a(action) && "type" in action && typeof action.type === "string";
  }
  var NOTHING = Symbol.for("immer-nothing");
  var DRAFTABLE = Symbol.for("immer-draftable");
  var DRAFT_STATE = Symbol.for("immer-state");
  var errors = true ? [
    // All error codes, starting by 0:
    function(plugin) {
      return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
    },
    function(thing) {
      return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
    },
    "This object has been frozen and should not be mutated",
    function(data) {
      return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
    },
    "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
    "Immer forbids circular references",
    "The first or second argument to `produce` must be a function",
    "The third argument to `produce` must be a function or undefined",
    "First argument to `createDraft` must be a plain object, an array, or an immerable object",
    "First argument to `finishDraft` must be a draft returned by `createDraft`",
    function(thing) {
      return `'current' expects a draft, got: ${thing}`;
    },
    "Object.defineProperty() cannot be used on an Immer draft",
    "Object.setPrototypeOf() cannot be used on an Immer draft",
    "Immer only supports deleting array indices",
    "Immer only supports setting array indices and the 'length' property",
    function(thing) {
      return `'original' expects a draft, got: ${thing}`;
    }
    // Note: if more errors are added, the errorOffset in Patches.ts should be increased
    // See Patches.ts for additional errors
  ] : [];
  function die(error, ...args) {
    if (true) {
      const e = errors[error];
      const msg = typeof e === "function" ? e.apply(null, args) : e;
      throw new Error(`[Immer] ${msg}`);
    }
    throw new Error(
      `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
    );
  }
  var getPrototypeOf$1 = Object.getPrototypeOf;
  function isDraft(value) {
    return !!value && !!value[DRAFT_STATE];
  }
  function isDraftable(value) {
    var _a;
    if (!value)
      return false;
    return isPlainObject$9(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a = value.constructor) == null ? void 0 : _a[DRAFTABLE]) || isMap$1(value) || isSet$1(value);
  }
  var objectCtorString = Object.prototype.constructor.toString();
  function isPlainObject$9(value) {
    if (!value || typeof value !== "object")
      return false;
    const proto2 = getPrototypeOf$1(value);
    if (proto2 === null) {
      return true;
    }
    const Ctor = Object.hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
    if (Ctor === Object)
      return true;
    return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
  }
  function original$1(value) {
    if (!isDraft(value))
      die(15, value);
    return value[DRAFT_STATE].base_;
  }
  function each(obj, iter) {
    if (getArchtype(obj) === 0) {
      Reflect.ownKeys(obj).forEach((key) => {
        iter(key, obj[key], obj);
      });
    } else {
      obj.forEach((entry, index2) => iter(index2, entry, obj));
    }
  }
  function getArchtype(thing) {
    const state = thing[DRAFT_STATE];
    return state ? state.type_ : Array.isArray(thing) ? 1 : isMap$1(thing) ? 2 : isSet$1(thing) ? 3 : 0;
  }
  function has(thing, prop) {
    return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
  }
  function get(thing, prop) {
    return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];
  }
  function set$1(thing, propOrOldValue, value) {
    const t = getArchtype(thing);
    if (t === 2)
      thing.set(propOrOldValue, value);
    else if (t === 3) {
      thing.add(value);
    } else
      thing[propOrOldValue] = value;
  }
  function is$1(x2, y2) {
    if (x2 === y2) {
      return x2 !== 0 || 1 / x2 === 1 / y2;
    } else {
      return x2 !== x2 && y2 !== y2;
    }
  }
  function isMap$1(target) {
    return target instanceof Map;
  }
  function isSet$1(target) {
    return target instanceof Set;
  }
  function latest(state) {
    return state.copy_ || state.base_;
  }
  function shallowCopy(base, strict) {
    if (isMap$1(base)) {
      return new Map(base);
    }
    if (isSet$1(base)) {
      return new Set(base);
    }
    if (Array.isArray(base))
      return Array.prototype.slice.call(base);
    const isPlain2 = isPlainObject$9(base);
    if (strict === true || strict === "class_only" && !isPlain2) {
      const descriptors = Object.getOwnPropertyDescriptors(base);
      delete descriptors[DRAFT_STATE];
      let keys = Reflect.ownKeys(descriptors);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const desc = descriptors[key];
        if (desc.writable === false) {
          desc.writable = true;
          desc.configurable = true;
        }
        if (desc.get || desc.set)
          descriptors[key] = {
            configurable: true,
            writable: true,
            // could live with !!desc.set as well here...
            enumerable: desc.enumerable,
            value: base[key]
          };
      }
      return Object.create(getPrototypeOf$1(base), descriptors);
    } else {
      const proto2 = getPrototypeOf$1(base);
      if (proto2 !== null && isPlain2) {
        return { ...base };
      }
      const obj = Object.create(proto2);
      return Object.assign(obj, base);
    }
  }
  function freeze(obj, deep = false) {
    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
      return obj;
    if (getArchtype(obj) > 1) {
      obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
    }
    Object.freeze(obj);
    if (deep)
      Object.entries(obj).forEach(([key, value]) => freeze(value, true));
    return obj;
  }
  function dontMutateFrozenCollections() {
    die(2);
  }
  function isFrozen(obj) {
    return Object.isFrozen(obj);
  }
  var plugins = {};
  function getPlugin(pluginKey) {
    const plugin = plugins[pluginKey];
    if (!plugin) {
      die(0, pluginKey);
    }
    return plugin;
  }
  function loadPlugin(pluginKey, implementation) {
    if (!plugins[pluginKey])
      plugins[pluginKey] = implementation;
  }
  var currentScope;
  function getCurrentScope() {
    return currentScope;
  }
  function createScope(parent_, immer_) {
    return {
      drafts_: [],
      parent_,
      immer_,
      // Whenever the modified draft contains a draft from another scope, we
      // need to prevent auto-freezing so the unowned draft can be finalized.
      canAutoFreeze_: true,
      unfinalizedDrafts_: 0
    };
  }
  function usePatchesInScope(scope, patchListener) {
    if (patchListener) {
      getPlugin("Patches");
      scope.patches_ = [];
      scope.inversePatches_ = [];
      scope.patchListener_ = patchListener;
    }
  }
  function revokeScope(scope) {
    leaveScope(scope);
    scope.drafts_.forEach(revokeDraft);
    scope.drafts_ = null;
  }
  function leaveScope(scope) {
    if (scope === currentScope) {
      currentScope = scope.parent_;
    }
  }
  function enterScope(immer2) {
    return currentScope = createScope(currentScope, immer2);
  }
  function revokeDraft(draft) {
    const state = draft[DRAFT_STATE];
    if (state.type_ === 0 || state.type_ === 1)
      state.revoke_();
    else
      state.revoked_ = true;
  }
  function processResult(result, scope) {
    scope.unfinalizedDrafts_ = scope.drafts_.length;
    const baseDraft = scope.drafts_[0];
    const isReplaced = result !== void 0 && result !== baseDraft;
    if (isReplaced) {
      if (baseDraft[DRAFT_STATE].modified_) {
        revokeScope(scope);
        die(4);
      }
      if (isDraftable(result)) {
        result = finalize(scope, result);
        if (!scope.parent_)
          maybeFreeze(scope, result);
      }
      if (scope.patches_) {
        getPlugin("Patches").generateReplacementPatches_(
          baseDraft[DRAFT_STATE].base_,
          result,
          scope.patches_,
          scope.inversePatches_
        );
      }
    } else {
      result = finalize(scope, baseDraft, []);
    }
    revokeScope(scope);
    if (scope.patches_) {
      scope.patchListener_(scope.patches_, scope.inversePatches_);
    }
    return result !== NOTHING ? result : void 0;
  }
  function finalize(rootScope, value, path2) {
    if (isFrozen(value))
      return value;
    const state = value[DRAFT_STATE];
    if (!state) {
      each(
        value,
        (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path2)
      );
      return value;
    }
    if (state.scope_ !== rootScope)
      return value;
    if (!state.modified_) {
      maybeFreeze(rootScope, state.base_, true);
      return state.base_;
    }
    if (!state.finalized_) {
      state.finalized_ = true;
      state.scope_.unfinalizedDrafts_--;
      const result = state.copy_;
      let resultEach = result;
      let isSet2 = false;
      if (state.type_ === 3) {
        resultEach = new Set(result);
        result.clear();
        isSet2 = true;
      }
      each(
        resultEach,
        (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path2, isSet2)
      );
      maybeFreeze(rootScope, result, false);
      if (path2 && rootScope.patches_) {
        getPlugin("Patches").generatePatches_(
          state,
          path2,
          rootScope.patches_,
          rootScope.inversePatches_
        );
      }
    }
    return state.copy_;
  }
  function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
    if (childValue === targetObject)
      die(5);
    if (isDraft(childValue)) {
      const path2 = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
      !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
      const res = finalize(rootScope, childValue, path2);
      set$1(targetObject, prop, res);
      if (isDraft(res)) {
        rootScope.canAutoFreeze_ = false;
      } else
        return;
    } else if (targetIsSet) {
      targetObject.add(childValue);
    }
    if (isDraftable(childValue) && !isFrozen(childValue)) {
      if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
        return;
      }
      finalize(rootScope, childValue);
      if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
        maybeFreeze(rootScope, childValue);
    }
  }
  function maybeFreeze(scope, value, deep = false) {
    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
      freeze(value, deep);
    }
  }
  function createProxyProxy(base, parent) {
    const isArray2 = Array.isArray(base);
    const state = {
      type_: isArray2 ? 1 : 0,
      // Track which produce call this is associated with.
      scope_: parent ? parent.scope_ : getCurrentScope(),
      // True for both shallow and deep changes.
      modified_: false,
      // Used during finalization.
      finalized_: false,
      // Track which properties have been assigned (true) or deleted (false).
      assigned_: {},
      // The parent draft state.
      parent_: parent,
      // The base state.
      base_: base,
      // The base proxy.
      draft_: null,
      // set below
      // The base copy with any updated values.
      copy_: null,
      // Called by the `produce` function.
      revoke_: null,
      isManual_: false
    };
    let target = state;
    let traps = objectTraps;
    if (isArray2) {
      target = [state];
      traps = arrayTraps;
    }
    const { revoke, proxy } = Proxy.revocable(target, traps);
    state.draft_ = proxy;
    state.revoke_ = revoke;
    return proxy;
  }
  var objectTraps = {
    get(state, prop) {
      if (prop === DRAFT_STATE)
        return state;
      const source = latest(state);
      if (!has(source, prop)) {
        return readPropFromProto(state, source, prop);
      }
      const value = source[prop];
      if (state.finalized_ || !isDraftable(value)) {
        return value;
      }
      if (value === peek(state.base_, prop)) {
        prepareCopy(state);
        return state.copy_[prop] = createProxy(value, state);
      }
      return value;
    },
    has(state, prop) {
      return prop in latest(state);
    },
    ownKeys(state) {
      return Reflect.ownKeys(latest(state));
    },
    set(state, prop, value) {
      const desc = getDescriptorFromProto(latest(state), prop);
      if (desc == null ? void 0 : desc.set) {
        desc.set.call(state.draft_, value);
        return true;
      }
      if (!state.modified_) {
        const current2 = peek(latest(state), prop);
        const currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
        if (currentState && currentState.base_ === value) {
          state.copy_[prop] = value;
          state.assigned_[prop] = false;
          return true;
        }
        if (is$1(value, current2) && (value !== void 0 || has(state.base_, prop)))
          return true;
        prepareCopy(state);
        markChanged(state);
      }
      if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
      (value !== void 0 || prop in state.copy_) || // special case: NaN
      Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
        return true;
      state.copy_[prop] = value;
      state.assigned_[prop] = true;
      return true;
    },
    deleteProperty(state, prop) {
      if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
        state.assigned_[prop] = false;
        prepareCopy(state);
        markChanged(state);
      } else {
        delete state.assigned_[prop];
      }
      if (state.copy_) {
        delete state.copy_[prop];
      }
      return true;
    },
    // Note: We never coerce `desc.value` into an Immer draft, because we can't make
    // the same guarantee in ES5 mode.
    getOwnPropertyDescriptor(state, prop) {
      const owner = latest(state);
      const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
      if (!desc)
        return desc;
      return {
        writable: true,
        configurable: state.type_ !== 1 || prop !== "length",
        enumerable: desc.enumerable,
        value: owner[prop]
      };
    },
    defineProperty() {
      die(11);
    },
    getPrototypeOf(state) {
      return getPrototypeOf$1(state.base_);
    },
    setPrototypeOf() {
      die(12);
    }
  };
  var arrayTraps = {};
  each(objectTraps, (key, fn) => {
    arrayTraps[key] = function() {
      arguments[0] = arguments[0][0];
      return fn.apply(this, arguments);
    };
  });
  arrayTraps.deleteProperty = function(state, prop) {
    if (isNaN(parseInt(prop)))
      die(13);
    return arrayTraps.set.call(this, state, prop, void 0);
  };
  arrayTraps.set = function(state, prop, value) {
    if (prop !== "length" && isNaN(parseInt(prop)))
      die(14);
    return objectTraps.set.call(this, state[0], prop, value, state[0]);
  };
  function peek(draft, prop) {
    const state = draft[DRAFT_STATE];
    const source = state ? latest(state) : draft;
    return source[prop];
  }
  function readPropFromProto(state, source, prop) {
    var _a;
    const desc = getDescriptorFromProto(source, prop);
    return desc ? `value` in desc ? desc.value : (
      // This is a very special case, if the prop is a getter defined by the
      // prototype, we should invoke it with the draft as context!
      (_a = desc.get) == null ? void 0 : _a.call(state.draft_)
    ) : void 0;
  }
  function getDescriptorFromProto(source, prop) {
    if (!(prop in source))
      return void 0;
    let proto2 = getPrototypeOf$1(source);
    while (proto2) {
      const desc = Object.getOwnPropertyDescriptor(proto2, prop);
      if (desc)
        return desc;
      proto2 = getPrototypeOf$1(proto2);
    }
    return void 0;
  }
  function markChanged(state) {
    if (!state.modified_) {
      state.modified_ = true;
      if (state.parent_) {
        markChanged(state.parent_);
      }
    }
  }
  function prepareCopy(state) {
    if (!state.copy_) {
      state.copy_ = shallowCopy(
        state.base_,
        state.scope_.immer_.useStrictShallowCopy_
      );
    }
  }
  var Immer2 = class {
    constructor(config2) {
      this.autoFreeze_ = true;
      this.useStrictShallowCopy_ = false;
      this.produce = (base, recipe, patchListener) => {
        if (typeof base === "function" && typeof recipe !== "function") {
          const defaultBase = recipe;
          recipe = base;
          const self2 = this;
          return function curriedProduce(base2 = defaultBase, ...args) {
            return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
          };
        }
        if (typeof recipe !== "function")
          die(6);
        if (patchListener !== void 0 && typeof patchListener !== "function")
          die(7);
        let result;
        if (isDraftable(base)) {
          const scope = enterScope(this);
          const proxy = createProxy(base, void 0);
          let hasError = true;
          try {
            result = recipe(proxy);
            hasError = false;
          } finally {
            if (hasError)
              revokeScope(scope);
            else
              leaveScope(scope);
          }
          usePatchesInScope(scope, patchListener);
          return processResult(result, scope);
        } else if (!base || typeof base !== "object") {
          result = recipe(base);
          if (result === void 0)
            result = base;
          if (result === NOTHING)
            result = void 0;
          if (this.autoFreeze_)
            freeze(result, true);
          if (patchListener) {
            const p = [];
            const ip = [];
            getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
            patchListener(p, ip);
          }
          return result;
        } else
          die(1, base);
      };
      this.produceWithPatches = (base, recipe) => {
        if (typeof base === "function") {
          return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
        }
        let patches, inversePatches;
        const result = this.produce(base, recipe, (p, ip) => {
          patches = p;
          inversePatches = ip;
        });
        return [result, patches, inversePatches];
      };
      if (typeof (config2 == null ? void 0 : config2.autoFreeze) === "boolean")
        this.setAutoFreeze(config2.autoFreeze);
      if (typeof (config2 == null ? void 0 : config2.useStrictShallowCopy) === "boolean")
        this.setUseStrictShallowCopy(config2.useStrictShallowCopy);
    }
    createDraft(base) {
      if (!isDraftable(base))
        die(8);
      if (isDraft(base))
        base = current(base);
      const scope = enterScope(this);
      const proxy = createProxy(base, void 0);
      proxy[DRAFT_STATE].isManual_ = true;
      leaveScope(scope);
      return proxy;
    }
    finishDraft(draft, patchListener) {
      const state = draft && draft[DRAFT_STATE];
      if (!state || !state.isManual_)
        die(9);
      const { scope_: scope } = state;
      usePatchesInScope(scope, patchListener);
      return processResult(void 0, scope);
    }
    /**
     * Pass true to automatically freeze all copies created by Immer.
     *
     * By default, auto-freezing is enabled.
     */
    setAutoFreeze(value) {
      this.autoFreeze_ = value;
    }
    /**
     * Pass true to enable strict shallow copy.
     *
     * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
     */
    setUseStrictShallowCopy(value) {
      this.useStrictShallowCopy_ = value;
    }
    applyPatches(base, patches) {
      let i;
      for (i = patches.length - 1; i >= 0; i--) {
        const patch = patches[i];
        if (patch.path.length === 0 && patch.op === "replace") {
          base = patch.value;
          break;
        }
      }
      if (i > -1) {
        patches = patches.slice(i + 1);
      }
      const applyPatchesImpl = getPlugin("Patches").applyPatches_;
      if (isDraft(base)) {
        return applyPatchesImpl(base, patches);
      }
      return this.produce(
        base,
        (draft) => applyPatchesImpl(draft, patches)
      );
    }
  };
  function createProxy(value, parent) {
    const draft = isMap$1(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet$1(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
    const scope = parent ? parent.scope_ : getCurrentScope();
    scope.drafts_.push(draft);
    return draft;
  }
  function current(value) {
    if (!isDraft(value))
      die(10, value);
    return currentImpl(value);
  }
  function currentImpl(value) {
    if (!isDraftable(value) || isFrozen(value))
      return value;
    const state = value[DRAFT_STATE];
    let copy2;
    if (state) {
      if (!state.modified_)
        return state.base_;
      state.finalized_ = true;
      copy2 = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
    } else {
      copy2 = shallowCopy(value, true);
    }
    each(copy2, (key, childValue) => {
      set$1(copy2, key, currentImpl(childValue));
    });
    if (state) {
      state.finalized_ = false;
    }
    return copy2;
  }
  function enablePatches() {
    const errorOffset = 16;
    if (true) {
      errors.push(
        'Sets cannot have "replace" patches.',
        function(op) {
          return "Unsupported patch operation: " + op;
        },
        function(path2) {
          return "Cannot apply patch, path doesn't resolve: " + path2;
        },
        "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
      );
    }
    const REPLACE = "replace";
    const ADD = "add";
    const REMOVE = "remove";
    function generatePatches_(state, basePath, patches, inversePatches) {
      switch (state.type_) {
        case 0:
        case 2:
          return generatePatchesFromAssigned(
            state,
            basePath,
            patches,
            inversePatches
          );
        case 1:
          return generateArrayPatches(state, basePath, patches, inversePatches);
        case 3:
          return generateSetPatches(
            state,
            basePath,
            patches,
            inversePatches
          );
      }
    }
    function generateArrayPatches(state, basePath, patches, inversePatches) {
      let { base_, assigned_ } = state;
      let copy_ = state.copy_;
      if (copy_.length < base_.length) {
        ;
        [base_, copy_] = [copy_, base_];
        [patches, inversePatches] = [inversePatches, patches];
      }
      for (let i = 0; i < base_.length; i++) {
        if (assigned_[i] && copy_[i] !== base_[i]) {
          const path2 = basePath.concat([i]);
          patches.push({
            op: REPLACE,
            path: path2,
            // Need to maybe clone it, as it can in fact be the original value
            // due to the base/copy inversion at the start of this function
            value: clonePatchValueIfNeeded(copy_[i])
          });
          inversePatches.push({
            op: REPLACE,
            path: path2,
            value: clonePatchValueIfNeeded(base_[i])
          });
        }
      }
      for (let i = base_.length; i < copy_.length; i++) {
        const path2 = basePath.concat([i]);
        patches.push({
          op: ADD,
          path: path2,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: clonePatchValueIfNeeded(copy_[i])
        });
      }
      for (let i = copy_.length - 1; base_.length <= i; --i) {
        const path2 = basePath.concat([i]);
        inversePatches.push({
          op: REMOVE,
          path: path2
        });
      }
    }
    function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
      const { base_, copy_ } = state;
      each(state.assigned_, (key, assignedValue) => {
        const origValue = get(base_, key);
        const value = get(copy_, key);
        const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
        if (origValue === value && op === REPLACE)
          return;
        const path2 = basePath.concat(key);
        patches.push(op === REMOVE ? { op, path: path2 } : { op, path: path2, value });
        inversePatches.push(
          op === ADD ? { op: REMOVE, path: path2 } : op === REMOVE ? { op: ADD, path: path2, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path: path2, value: clonePatchValueIfNeeded(origValue) }
        );
      });
    }
    function generateSetPatches(state, basePath, patches, inversePatches) {
      let { base_, copy_ } = state;
      let i = 0;
      base_.forEach((value) => {
        if (!copy_.has(value)) {
          const path2 = basePath.concat([i]);
          patches.push({
            op: REMOVE,
            path: path2,
            value
          });
          inversePatches.unshift({
            op: ADD,
            path: path2,
            value
          });
        }
        i++;
      });
      i = 0;
      copy_.forEach((value) => {
        if (!base_.has(value)) {
          const path2 = basePath.concat([i]);
          patches.push({
            op: ADD,
            path: path2,
            value
          });
          inversePatches.unshift({
            op: REMOVE,
            path: path2,
            value
          });
        }
        i++;
      });
    }
    function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
      patches.push({
        op: REPLACE,
        path: [],
        value: replacement === NOTHING ? void 0 : replacement
      });
      inversePatches.push({
        op: REPLACE,
        path: [],
        value: baseValue
      });
    }
    function applyPatches_(draft, patches) {
      patches.forEach((patch) => {
        const { path: path2, op } = patch;
        let base = draft;
        for (let i = 0; i < path2.length - 1; i++) {
          const parentType = getArchtype(base);
          let p = path2[i];
          if (typeof p !== "string" && typeof p !== "number") {
            p = "" + p;
          }
          if ((parentType === 0 || parentType === 1) && (p === "__proto__" || p === "constructor"))
            die(errorOffset + 3);
          if (typeof base === "function" && p === "prototype")
            die(errorOffset + 3);
          base = get(base, p);
          if (typeof base !== "object")
            die(errorOffset + 2, path2.join("/"));
        }
        const type = getArchtype(base);
        const value = deepClonePatchValue(patch.value);
        const key = path2[path2.length - 1];
        switch (op) {
          case REPLACE:
            switch (type) {
              case 2:
                return base.set(key, value);
              case 3:
                die(errorOffset);
              default:
                return base[key] = value;
            }
          case ADD:
            switch (type) {
              case 1:
                return key === "-" ? base.push(value) : base.splice(key, 0, value);
              case 2:
                return base.set(key, value);
              case 3:
                return base.add(value);
              default:
                return base[key] = value;
            }
          case REMOVE:
            switch (type) {
              case 1:
                return base.splice(key, 1);
              case 2:
                return base.delete(key);
              case 3:
                return base.delete(patch.value);
              default:
                return delete base[key];
            }
          default:
            die(errorOffset + 1, op);
        }
      });
      return draft;
    }
    function deepClonePatchValue(obj) {
      if (!isDraftable(obj))
        return obj;
      if (Array.isArray(obj))
        return obj.map(deepClonePatchValue);
      if (isMap$1(obj))
        return new Map(
          Array.from(obj.entries()).map(([k2, v]) => [k2, deepClonePatchValue(v)])
        );
      if (isSet$1(obj))
        return new Set(Array.from(obj).map(deepClonePatchValue));
      const cloned = Object.create(getPrototypeOf$1(obj));
      for (const key in obj)
        cloned[key] = deepClonePatchValue(obj[key]);
      if (has(obj, DRAFTABLE))
        cloned[DRAFTABLE] = obj[DRAFTABLE];
      return cloned;
    }
    function clonePatchValueIfNeeded(obj) {
      if (isDraft(obj)) {
        return deepClonePatchValue(obj);
      } else
        return obj;
    }
    loadPlugin("Patches", {
      applyPatches_,
      generatePatches_,
      generateReplacementPatches_
    });
  }
  function enableMapSet() {
    class DraftMap extends Map {
      constructor(target, parent) {
        super();
        this[DRAFT_STATE] = {
          type_: 2,
          parent_: parent,
          scope_: parent ? parent.scope_ : getCurrentScope(),
          modified_: false,
          finalized_: false,
          copy_: void 0,
          assigned_: void 0,
          base_: target,
          draft_: this,
          isManual_: false,
          revoked_: false
        };
      }
      get size() {
        return latest(this[DRAFT_STATE]).size;
      }
      has(key) {
        return latest(this[DRAFT_STATE]).has(key);
      }
      set(key, value) {
        const state = this[DRAFT_STATE];
        assertUnrevoked(state);
        if (!latest(state).has(key) || latest(state).get(key) !== value) {
          prepareMapCopy(state);
          markChanged(state);
          state.assigned_.set(key, true);
          state.copy_.set(key, value);
          state.assigned_.set(key, true);
        }
        return this;
      }
      delete(key) {
        if (!this.has(key)) {
          return false;
        }
        const state = this[DRAFT_STATE];
        assertUnrevoked(state);
        prepareMapCopy(state);
        markChanged(state);
        if (state.base_.has(key)) {
          state.assigned_.set(key, false);
        } else {
          state.assigned_.delete(key);
        }
        state.copy_.delete(key);
        return true;
      }
      clear() {
        const state = this[DRAFT_STATE];
        assertUnrevoked(state);
        if (latest(state).size) {
          prepareMapCopy(state);
          markChanged(state);
          state.assigned_ = /* @__PURE__ */ new Map();
          each(state.base_, (key) => {
            state.assigned_.set(key, false);
          });
          state.copy_.clear();
        }
      }
      forEach(cb, thisArg) {
        const state = this[DRAFT_STATE];
        latest(state).forEach((_value, key, _map) => {
          cb.call(thisArg, this.get(key), key, this);
        });
      }
      get(key) {
        const state = this[DRAFT_STATE];
        assertUnrevoked(state);
        const value = latest(state).get(key);
        if (state.finalized_ || !isDraftable(value)) {
          return value;
        }
        if (value !== state.base_.get(key)) {
          return value;
        }
        const draft = createProxy(value, state);
        prepareMapCopy(state);
        state.copy_.set(key, draft);
        return draft;
      }
      keys() {
        return latest(this[DRAFT_STATE]).keys();
      }
      values() {
        const iterator = this.keys();
        return {
          [Symbol.iterator]: () => this.values(),
          next: () => {
            const r2 = iterator.next();
            if (r2.done)
              return r2;
            const value = this.get(r2.value);
            return {
              done: false,
              value
            };
          }
        };
      }
      entries() {
        const iterator = this.keys();
        return {
          [Symbol.iterator]: () => this.entries(),
          next: () => {
            const r2 = iterator.next();
            if (r2.done)
              return r2;
            const value = this.get(r2.value);
            return {
              done: false,
              value: [r2.value, value]
            };
          }
        };
      }
      [(DRAFT_STATE, Symbol.iterator)]() {
        return this.entries();
      }
    }
    function proxyMap_(target, parent) {
      return new DraftMap(target, parent);
    }
    function prepareMapCopy(state) {
      if (!state.copy_) {
        state.assigned_ = /* @__PURE__ */ new Map();
        state.copy_ = new Map(state.base_);
      }
    }
    class DraftSet extends Set {
      constructor(target, parent) {
        super();
        this[DRAFT_STATE] = {
          type_: 3,
          parent_: parent,
          scope_: parent ? parent.scope_ : getCurrentScope(),
          modified_: false,
          finalized_: false,
          copy_: void 0,
          base_: target,
          draft_: this,
          drafts_: /* @__PURE__ */ new Map(),
          revoked_: false,
          isManual_: false
        };
      }
      get size() {
        return latest(this[DRAFT_STATE]).size;
      }
      has(value) {
        const state = this[DRAFT_STATE];
        assertUnrevoked(state);
        if (!state.copy_) {
          return state.base_.has(value);
        }
        if (state.copy_.has(value))
          return true;
        if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))
          return true;
        return false;
      }
      add(value) {
        const state = this[DRAFT_STATE];
        assertUnrevoked(state);
        if (!this.has(value)) {
          prepareSetCopy(state);
          markChanged(state);
          state.copy_.add(value);
        }
        return this;
      }
      delete(value) {
        if (!this.has(value)) {
          return false;
        }
        const state = this[DRAFT_STATE];
        assertUnrevoked(state);
        prepareSetCopy(state);
        markChanged(state);
        return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : (
          /* istanbul ignore next */
          false
        ));
      }
      clear() {
        const state = this[DRAFT_STATE];
        assertUnrevoked(state);
        if (latest(state).size) {
          prepareSetCopy(state);
          markChanged(state);
          state.copy_.clear();
        }
      }
      values() {
        const state = this[DRAFT_STATE];
        assertUnrevoked(state);
        prepareSetCopy(state);
        return state.copy_.values();
      }
      entries() {
        const state = this[DRAFT_STATE];
        assertUnrevoked(state);
        prepareSetCopy(state);
        return state.copy_.entries();
      }
      keys() {
        return this.values();
      }
      [(DRAFT_STATE, Symbol.iterator)]() {
        return this.values();
      }
      forEach(cb, thisArg) {
        const iterator = this.values();
        let result = iterator.next();
        while (!result.done) {
          cb.call(thisArg, result.value, result.value, this);
          result = iterator.next();
        }
      }
    }
    function proxySet_(target, parent) {
      return new DraftSet(target, parent);
    }
    function prepareSetCopy(state) {
      if (!state.copy_) {
        state.copy_ = /* @__PURE__ */ new Set();
        state.base_.forEach((value) => {
          if (isDraftable(value)) {
            const draft = createProxy(value, state);
            state.drafts_.set(value, draft);
            state.copy_.add(draft);
          } else {
            state.copy_.add(value);
          }
        });
      }
    }
    function assertUnrevoked(state) {
      if (state.revoked_)
        die(3, JSON.stringify(latest(state)));
    }
    loadPlugin("MapSet", { proxyMap_, proxySet_ });
  }
  var immer = new Immer2();
  var produce = immer.produce;
  var produceWithPatches = immer.produceWithPatches.bind(
    immer
  );
  var setAutoFreeze = immer.setAutoFreeze.bind(immer);
  var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);
  var applyPatches = immer.applyPatches.bind(immer);
  var createDraft = immer.createDraft.bind(immer);
  var finishDraft = immer.finishDraft.bind(immer);
  function castDraft(value) {
    return value;
  }
  function castImmutable(value) {
    return value;
  }
  function createThunkMiddleware(extraArgument) {
    const middleware = ({ dispatch, getState }) => (next) => (action) => {
      if (typeof action === "function") {
        return action(dispatch, getState, extraArgument);
      }
      return next(action);
    };
    return middleware;
  }
  var thunk = createThunkMiddleware();
  var withExtraArgument = createThunkMiddleware;
  var createDraftSafeSelectorCreator = (...args) => {
    const createSelector2 = createSelectorCreator(...args);
    const createDraftSafeSelector2 = Object.assign((...args2) => {
      const selector = createSelector2(...args2);
      const wrappedSelector = (value, ...rest2) => selector(isDraft(value) ? current(value) : value, ...rest2);
      Object.assign(wrappedSelector, selector);
      return wrappedSelector;
    }, {
      withTypes: () => createDraftSafeSelector2
    });
    return createDraftSafeSelector2;
  };
  var createDraftSafeSelector = /* @__PURE__ */ createDraftSafeSelectorCreator(weakMapMemoize);
  var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
    if (arguments.length === 0) return void 0;
    if (typeof arguments[0] === "object") return compose$1;
    return compose$1.apply(null, arguments);
  };
  var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
    return function(noop3) {
      return noop3;
    };
  };
  var hasMatchFunction = (v) => {
    return v && typeof v.match === "function";
  };
  function createAction(type, prepareAction) {
    function actionCreator(...args) {
      if (prepareAction) {
        let prepared = prepareAction(...args);
        if (!prepared) {
          throw new Error(false ? formatProdErrorMessage(0) : "prepareAction did not return an object");
        }
        return {
          type,
          payload: prepared.payload,
          ..."meta" in prepared && {
            meta: prepared.meta
          },
          ..."error" in prepared && {
            error: prepared.error
          }
        };
      }
      return {
        type,
        payload: args[0]
      };
    }
    actionCreator.toString = () => `${type}`;
    actionCreator.type = type;
    actionCreator.match = (action) => isAction(action) && action.type === type;
    return actionCreator;
  }
  function isActionCreator(action) {
    return typeof action === "function" && "type" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
    hasMatchFunction(action);
  }
  function isFSA(action) {
    return isAction(action) && Object.keys(action).every(isValidKey);
  }
  function isValidKey(key) {
    return ["type", "payload", "error", "meta"].indexOf(key) > -1;
  }
  function getMessage(type) {
    const splitType = type ? `${type}`.split("/") : [];
    const actionName = splitType[splitType.length - 1] || "actionCreator";
    return `Detected an action creator with type "${type || "unknown"}" being dispatched. 
Make sure you're calling the action creator before dispatching, i.e. \`dispatch(${actionName}())\` instead of \`dispatch(${actionName})\`. This is necessary even if the action has no payload.`;
  }
  function createActionCreatorInvariantMiddleware(options2 = {}) {
    if (false) {
      return () => (next) => (action) => next(action);
    }
    const {
      isActionCreator: isActionCreator2 = isActionCreator
    } = options2;
    return () => (next) => (action) => {
      if (isActionCreator2(action)) {
        console.warn(getMessage(action.type));
      }
      return next(action);
    };
  }
  function getTimeMeasureUtils(maxDelay, fnName) {
    let elapsed = 0;
    return {
      measureTime(fn) {
        const started = Date.now();
        try {
          return fn();
        } finally {
          const finished = Date.now();
          elapsed += finished - started;
        }
      },
      warnIfExceeded() {
        if (elapsed > maxDelay) {
          console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
        }
      }
    };
  }
  var Tuple = class _Tuple extends Array {
    constructor(...items) {
      super(...items);
      Object.setPrototypeOf(this, _Tuple.prototype);
    }
    static get [Symbol.species]() {
      return _Tuple;
    }
    concat(...arr) {
      return super.concat.apply(this, arr);
    }
    prepend(...arr) {
      if (arr.length === 1 && Array.isArray(arr[0])) {
        return new _Tuple(...arr[0].concat(this));
      }
      return new _Tuple(...arr.concat(this));
    }
  };
  function freezeDraftable(val) {
    return isDraftable(val) ? produce(val, () => {
    }) : val;
  }
  function getOrInsertComputed(map2, key, compute) {
    if (map2.has(key)) return map2.get(key);
    return map2.set(key, compute(key)).get(key);
  }
  function isImmutableDefault(value) {
    return typeof value !== "object" || value == null || Object.isFrozen(value);
  }
  function trackForMutations(isImmutable, ignorePaths, obj) {
    const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
    return {
      detectMutations() {
        return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
      }
    };
  }
  function trackProperties(isImmutable, ignorePaths = [], obj, path2 = "", checkedObjects = /* @__PURE__ */ new Set()) {
    const tracked = {
      value: obj
    };
    if (!isImmutable(obj) && !checkedObjects.has(obj)) {
      checkedObjects.add(obj);
      tracked.children = {};
      for (const key in obj) {
        const childPath = path2 ? path2 + "." + key : key;
        if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
          continue;
        }
        tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
      }
    }
    return tracked;
  }
  function detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path2 = "") {
    const prevObj = trackedProperty ? trackedProperty.value : void 0;
    const sameRef = prevObj === obj;
    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
      return {
        wasMutated: true,
        path: path2
      };
    }
    if (isImmutable(prevObj) || isImmutable(obj)) {
      return {
        wasMutated: false
      };
    }
    const keysToDetect = {};
    for (let key in trackedProperty.children) {
      keysToDetect[key] = true;
    }
    for (let key in obj) {
      keysToDetect[key] = true;
    }
    const hasIgnoredPaths = ignoredPaths.length > 0;
    for (let key in keysToDetect) {
      const nestedPath = path2 ? path2 + "." + key : key;
      if (hasIgnoredPaths) {
        const hasMatches = ignoredPaths.some((ignored) => {
          if (ignored instanceof RegExp) {
            return ignored.test(nestedPath);
          }
          return nestedPath === ignored;
        });
        if (hasMatches) {
          continue;
        }
      }
      const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);
      if (result.wasMutated) {
        return result;
      }
    }
    return {
      wasMutated: false
    };
  }
  function createImmutableStateInvariantMiddleware(options2 = {}) {
    if (false) {
      return () => (next) => (action) => next(action);
    } else {
      let stringify2 = function(obj, serializer, indent, decycler) {
        return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);
      }, getSerialize2 = function(serializer, decycler) {
        let stack = [], keys = [];
        if (!decycler) decycler = function(_, value) {
          if (stack[0] === value) return "[Circular ~]";
          return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
        };
        return function(key, value) {
          if (stack.length > 0) {
            var thisPos = stack.indexOf(this);
            ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
            ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
            if (~stack.indexOf(value)) value = decycler.call(this, key, value);
          } else stack.push(value);
          return serializer == null ? value : serializer.call(this, key, value);
        };
      };
      var stringify = stringify2, getSerialize = getSerialize2;
      let {
        isImmutable = isImmutableDefault,
        ignoredPaths,
        warnAfter = 32
      } = options2;
      const track = trackForMutations.bind(null, isImmutable, ignoredPaths);
      return ({
        getState
      }) => {
        let state = getState();
        let tracker = track(state);
        let result;
        return (next) => (action) => {
          const measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
          measureUtils.measureTime(() => {
            state = getState();
            result = tracker.detectMutations();
            tracker = track(state);
            if (result.wasMutated) {
              throw new Error(false ? formatProdErrorMessage(19) : `A state mutation was detected between dispatches, in the path '${result.path || ""}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
            }
          });
          const dispatchedAction = next(action);
          measureUtils.measureTime(() => {
            state = getState();
            result = tracker.detectMutations();
            tracker = track(state);
            if (result.wasMutated) {
              throw new Error(false ? formatProdErrorMessage(20) : `A state mutation was detected inside a dispatch, in the path: ${result.path || ""}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
            }
          });
          measureUtils.warnIfExceeded();
          return dispatchedAction;
        };
      };
    }
  }
  function isPlain(val) {
    const type = typeof val;
    return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject$a(val);
  }
  function findNonSerializableValue(value, path2 = "", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {
    let foundNestedSerializable;
    if (!isSerializable(value)) {
      return {
        keyPath: path2 || "<root>",
        value
      };
    }
    if (typeof value !== "object" || value === null) {
      return false;
    }
    if (cache == null ? void 0 : cache.has(value)) return false;
    const entries = getEntries != null ? getEntries(value) : Object.entries(value);
    const hasIgnoredPaths = ignoredPaths.length > 0;
    for (const [key, nestedValue] of entries) {
      const nestedPath = path2 ? path2 + "." + key : key;
      if (hasIgnoredPaths) {
        const hasMatches = ignoredPaths.some((ignored) => {
          if (ignored instanceof RegExp) {
            return ignored.test(nestedPath);
          }
          return nestedPath === ignored;
        });
        if (hasMatches) {
          continue;
        }
      }
      if (!isSerializable(nestedValue)) {
        return {
          keyPath: nestedPath,
          value: nestedValue
        };
      }
      if (typeof nestedValue === "object") {
        foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);
        if (foundNestedSerializable) {
          return foundNestedSerializable;
        }
      }
    }
    if (cache && isNestedFrozen(value)) cache.add(value);
    return false;
  }
  function isNestedFrozen(value) {
    if (!Object.isFrozen(value)) return false;
    for (const nestedValue of Object.values(value)) {
      if (typeof nestedValue !== "object" || nestedValue === null) continue;
      if (!isNestedFrozen(nestedValue)) return false;
    }
    return true;
  }
  function createSerializableStateInvariantMiddleware(options2 = {}) {
    if (false) {
      return () => (next) => (action) => next(action);
    } else {
      const {
        isSerializable = isPlain,
        getEntries,
        ignoredActions = [],
        ignoredActionPaths = ["meta.arg", "meta.baseQueryMeta"],
        ignoredPaths = [],
        warnAfter = 32,
        ignoreState = false,
        ignoreActions = false,
        disableCache = false
      } = options2;
      const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
      return (storeAPI) => (next) => (action) => {
        if (!isAction(action)) {
          return next(action);
        }
        const result = next(action);
        const measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
        if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {
          measureUtils.measureTime(() => {
            const foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths, cache);
            if (foundActionNonSerializableValue) {
              const {
                keyPath,
                value
              } = foundActionNonSerializableValue;
              console.error(`A non-serializable value was detected in an action, in the path: \`${keyPath}\`. Value:`, value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
            }
          });
        }
        if (!ignoreState) {
          measureUtils.measureTime(() => {
            const state = storeAPI.getState();
            const foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths, cache);
            if (foundStateNonSerializableValue) {
              const {
                keyPath,
                value
              } = foundStateNonSerializableValue;
              console.error(`A non-serializable value was detected in the state, in the path: \`${keyPath}\`. Value:`, value, `
Take a look at the reducer(s) handling this action type: ${action.type}.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);
            }
          });
          measureUtils.warnIfExceeded();
        }
        return result;
      };
    }
  }
  function isBoolean$1(x2) {
    return typeof x2 === "boolean";
  }
  var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options2) {
    const {
      thunk: thunk$1 = true,
      immutableCheck = true,
      serializableCheck = true,
      actionCreatorCheck = true
    } = options2 ?? {};
    let middlewareArray = new Tuple();
    if (thunk$1) {
      if (isBoolean$1(thunk$1)) {
        middlewareArray.push(thunk);
      } else {
        middlewareArray.push(withExtraArgument(thunk$1.extraArgument));
      }
    }
    if (true) {
      if (immutableCheck) {
        let immutableOptions = {};
        if (!isBoolean$1(immutableCheck)) {
          immutableOptions = immutableCheck;
        }
        middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
      }
      if (serializableCheck) {
        let serializableOptions = {};
        if (!isBoolean$1(serializableCheck)) {
          serializableOptions = serializableCheck;
        }
        middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
      }
      if (actionCreatorCheck) {
        let actionCreatorOptions = {};
        if (!isBoolean$1(actionCreatorCheck)) {
          actionCreatorOptions = actionCreatorCheck;
        }
        middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));
      }
    }
    return middlewareArray;
  };
  var SHOULD_AUTOBATCH = "RTK_autoBatch";
  var prepareAutoBatched = () => (payload) => ({
    payload,
    meta: {
      [SHOULD_AUTOBATCH]: true
    }
  });
  var createQueueWithTimer = (timeout2) => {
    return (notify) => {
      setTimeout(notify, timeout2);
    };
  };
  var autoBatchEnhancer = (options2 = {
    type: "raf"
  }) => (next) => (...args) => {
    const store = next(...args);
    let notifying = true;
    let shouldNotifyAtEndOfTick = false;
    let notificationQueued = false;
    const listeners = /* @__PURE__ */ new Set();
    const queueCallback = options2.type === "tick" ? queueMicrotask : options2.type === "raf" ? (
      // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
      typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)
    ) : options2.type === "callback" ? options2.queueNotification : createQueueWithTimer(options2.timeout);
    const notifyListeners = () => {
      notificationQueued = false;
      if (shouldNotifyAtEndOfTick) {
        shouldNotifyAtEndOfTick = false;
        listeners.forEach((l) => l());
      }
    };
    return Object.assign({}, store, {
      // Override the base `store.subscribe` method to keep original listeners
      // from running if we're delaying notifications
      subscribe(listener2) {
        const wrappedListener = () => notifying && listener2();
        const unsubscribe = store.subscribe(wrappedListener);
        listeners.add(listener2);
        return () => {
          unsubscribe();
          listeners.delete(listener2);
        };
      },
      // Override the base `store.dispatch` method so that we can check actions
      // for the `shouldAutoBatch` flag and determine if batching is active
      dispatch(action) {
        var _a;
        try {
          notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);
          shouldNotifyAtEndOfTick = !notifying;
          if (shouldNotifyAtEndOfTick) {
            if (!notificationQueued) {
              notificationQueued = true;
              queueCallback(notifyListeners);
            }
          }
          return store.dispatch(action);
        } finally {
          notifying = true;
        }
      }
    });
  };
  var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options2) {
    const {
      autoBatch = true
    } = options2 ?? {};
    let enhancerArray = new Tuple(middlewareEnhancer);
    if (autoBatch) {
      enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
    }
    return enhancerArray;
  };
  function configureStore(options2) {
    const getDefaultMiddleware = buildGetDefaultMiddleware();
    const {
      reducer: reducer2 = void 0,
      middleware,
      devTools = true,
      duplicateMiddlewareCheck = true,
      preloadedState: preloadedState2 = void 0,
      enhancers = void 0
    } = options2 || {};
    let rootReducer2;
    if (typeof reducer2 === "function") {
      rootReducer2 = reducer2;
    } else if (isPlainObject$a(reducer2)) {
      rootReducer2 = combineReducers(reducer2);
    } else {
      throw new Error(false ? formatProdErrorMessage(1) : "`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
    }
    if (middleware && typeof middleware !== "function") {
      throw new Error(false ? formatProdErrorMessage(2) : "`middleware` field must be a callback");
    }
    let finalMiddleware;
    if (typeof middleware === "function") {
      finalMiddleware = middleware(getDefaultMiddleware);
      if (!Array.isArray(finalMiddleware)) {
        throw new Error(false ? formatProdErrorMessage(3) : "when using a middleware builder function, an array of middleware must be returned");
      }
    } else {
      finalMiddleware = getDefaultMiddleware();
    }
    if (finalMiddleware.some((item) => typeof item !== "function")) {
      throw new Error(false ? formatProdErrorMessage(4) : "each middleware provided to configureStore must be a function");
    }
    if (duplicateMiddlewareCheck) {
      let middlewareReferences = /* @__PURE__ */ new Set();
      finalMiddleware.forEach((middleware2) => {
        if (middlewareReferences.has(middleware2)) {
          throw new Error(false ? formatProdErrorMessage(42) : "Duplicate middleware references found when creating the store. Ensure that each middleware is only included once.");
        }
        middlewareReferences.add(middleware2);
      });
    }
    let finalCompose = compose$1;
    if (devTools) {
      finalCompose = composeWithDevTools({
        // Enable capture of stack traces for dispatched Redux actions
        trace: true,
        ...typeof devTools === "object" && devTools
      });
    }
    const middlewareEnhancer = applyMiddleware(...finalMiddleware);
    const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
    if (enhancers && typeof enhancers !== "function") {
      throw new Error(false ? formatProdErrorMessage(5) : "`enhancers` field must be a callback");
    }
    let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
    if (!Array.isArray(storeEnhancers)) {
      throw new Error(false ? formatProdErrorMessage(6) : "`enhancers` callback must return an array");
    }
    if (storeEnhancers.some((item) => typeof item !== "function")) {
      throw new Error(false ? formatProdErrorMessage(7) : "each enhancer provided to configureStore must be a function");
    }
    if (finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {
      console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
    }
    const composedEnhancer = finalCompose(...storeEnhancers);
    return createStore(rootReducer2, preloadedState2, composedEnhancer);
  }
  function executeReducerBuilderCallback(builderCallback) {
    const actionsMap = {};
    const actionMatchers = [];
    let defaultCaseReducer;
    const builder = {
      addCase(typeOrActionCreator, reducer2) {
        if (true) {
          if (actionMatchers.length > 0) {
            throw new Error(false ? formatProdErrorMessage(26) : "`builder.addCase` should only be called before calling `builder.addMatcher`");
          }
          if (defaultCaseReducer) {
            throw new Error(false ? formatProdErrorMessage(27) : "`builder.addCase` should only be called before calling `builder.addDefaultCase`");
          }
        }
        const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
        if (!type) {
          throw new Error(false ? formatProdErrorMessage(28) : "`builder.addCase` cannot be called with an empty action type");
        }
        if (type in actionsMap) {
          throw new Error(false ? formatProdErrorMessage(29) : `\`builder.addCase\` cannot be called with two reducers for the same action type '${type}'`);
        }
        actionsMap[type] = reducer2;
        return builder;
      },
      addMatcher(matcher, reducer2) {
        if (true) {
          if (defaultCaseReducer) {
            throw new Error(false ? formatProdErrorMessage(30) : "`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
          }
        }
        actionMatchers.push({
          matcher,
          reducer: reducer2
        });
        return builder;
      },
      addDefaultCase(reducer2) {
        if (true) {
          if (defaultCaseReducer) {
            throw new Error(false ? formatProdErrorMessage(31) : "`builder.addDefaultCase` can only be called once");
          }
        }
        defaultCaseReducer = reducer2;
        return builder;
      }
    };
    builderCallback(builder);
    return [actionsMap, actionMatchers, defaultCaseReducer];
  }
  function isStateFunction(x2) {
    return typeof x2 === "function";
  }
  function createReducer(initialState2, mapOrBuilderCallback) {
    if (true) {
      if (typeof mapOrBuilderCallback === "object") {
        throw new Error(false ? formatProdErrorMessage(8) : "The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
      }
    }
    let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
    let getInitialState;
    if (isStateFunction(initialState2)) {
      getInitialState = () => freezeDraftable(initialState2());
    } else {
      const frozenInitialState = freezeDraftable(initialState2);
      getInitialState = () => frozenInitialState;
    }
    function reducer2(state = getInitialState(), action) {
      let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
        matcher
      }) => matcher(action)).map(({
        reducer: reducer22
      }) => reducer22)];
      if (caseReducers.filter((cr) => !!cr).length === 0) {
        caseReducers = [finalDefaultCaseReducer];
      }
      return caseReducers.reduce((previousState, caseReducer) => {
        if (caseReducer) {
          if (isDraft(previousState)) {
            const draft = previousState;
            const result = caseReducer(draft, action);
            if (result === void 0) {
              return previousState;
            }
            return result;
          } else if (!isDraftable(previousState)) {
            const result = caseReducer(previousState, action);
            if (result === void 0) {
              if (previousState === null) {
                return previousState;
              }
              throw Error("A case reducer on a non-draftable value must not return undefined");
            }
            return result;
          } else {
            return produce(previousState, (draft) => {
              return caseReducer(draft, action);
            });
          }
        }
        return previousState;
      }, state);
    }
    reducer2.getInitialState = getInitialState;
    return reducer2;
  }
  var matches = (matcher, action) => {
    if (hasMatchFunction(matcher)) {
      return matcher.match(action);
    } else {
      return matcher(action);
    }
  };
  function isAnyOf(...matchers) {
    return (action) => {
      return matchers.some((matcher) => matches(matcher, action));
    };
  }
  function isAllOf(...matchers) {
    return (action) => {
      return matchers.every((matcher) => matches(matcher, action));
    };
  }
  function hasExpectedRequestMetadata(action, validStatus) {
    if (!action || !action.meta) return false;
    const hasValidRequestId = typeof action.meta.requestId === "string";
    const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;
    return hasValidRequestId && hasValidRequestStatus;
  }
  function isAsyncThunkArray(a2) {
    return typeof a2[0] === "function" && "pending" in a2[0] && "fulfilled" in a2[0] && "rejected" in a2[0];
  }
  function isPending(...asyncThunks) {
    if (asyncThunks.length === 0) {
      return (action) => hasExpectedRequestMetadata(action, ["pending"]);
    }
    if (!isAsyncThunkArray(asyncThunks)) {
      return isPending()(asyncThunks[0]);
    }
    return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.pending));
  }
  function isRejected(...asyncThunks) {
    if (asyncThunks.length === 0) {
      return (action) => hasExpectedRequestMetadata(action, ["rejected"]);
    }
    if (!isAsyncThunkArray(asyncThunks)) {
      return isRejected()(asyncThunks[0]);
    }
    return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.rejected));
  }
  function isRejectedWithValue(...asyncThunks) {
    const hasFlag = (action) => {
      return action && action.meta && action.meta.rejectedWithValue;
    };
    if (asyncThunks.length === 0) {
      return isAllOf(isRejected(...asyncThunks), hasFlag);
    }
    if (!isAsyncThunkArray(asyncThunks)) {
      return isRejectedWithValue()(asyncThunks[0]);
    }
    return isAllOf(isRejected(...asyncThunks), hasFlag);
  }
  function isFulfilled(...asyncThunks) {
    if (asyncThunks.length === 0) {
      return (action) => hasExpectedRequestMetadata(action, ["fulfilled"]);
    }
    if (!isAsyncThunkArray(asyncThunks)) {
      return isFulfilled()(asyncThunks[0]);
    }
    return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.fulfilled));
  }
  function isAsyncThunkAction(...asyncThunks) {
    if (asyncThunks.length === 0) {
      return (action) => hasExpectedRequestMetadata(action, ["pending", "fulfilled", "rejected"]);
    }
    if (!isAsyncThunkArray(asyncThunks)) {
      return isAsyncThunkAction()(asyncThunks[0]);
    }
    return isAnyOf(...asyncThunks.flatMap((asyncThunk) => [asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled]));
  }
  var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
  var nanoid = (size = 21) => {
    let id = "";
    let i = size;
    while (i--) {
      id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
  };
  var commonProperties = ["name", "message", "stack", "code"];
  var RejectWithValue = class {
    constructor(payload, meta) {
      /*
      type-only property to distinguish between RejectWithValue and FulfillWithMeta
      does not exist at runtime
      */
      __publicField(this, "_type");
      this.payload = payload;
      this.meta = meta;
    }
  };
  var FulfillWithMeta = class {
    constructor(payload, meta) {
      /*
      type-only property to distinguish between RejectWithValue and FulfillWithMeta
      does not exist at runtime
      */
      __publicField(this, "_type");
      this.payload = payload;
      this.meta = meta;
    }
  };
  var miniSerializeError = (value) => {
    if (typeof value === "object" && value !== null) {
      const simpleError = {};
      for (const property2 of commonProperties) {
        if (typeof value[property2] === "string") {
          simpleError[property2] = value[property2];
        }
      }
      return simpleError;
    }
    return {
      message: String(value)
    };
  };
  var externalAbortMessage = "External signal was aborted";
  var createAsyncThunk = /* @__PURE__ */ (() => {
    function createAsyncThunk2(typePrefix, payloadCreator, options2) {
      const fulfilled = createAction(typePrefix + "/fulfilled", (payload, requestId, arg, meta) => ({
        payload,
        meta: {
          ...meta || {},
          arg,
          requestId,
          requestStatus: "fulfilled"
        }
      }));
      const pending = createAction(typePrefix + "/pending", (requestId, arg, meta) => ({
        payload: void 0,
        meta: {
          ...meta || {},
          arg,
          requestId,
          requestStatus: "pending"
        }
      }));
      const rejected = createAction(typePrefix + "/rejected", (error, requestId, arg, payload, meta) => ({
        payload,
        error: (options2 && options2.serializeError || miniSerializeError)(error || "Rejected"),
        meta: {
          ...meta || {},
          arg,
          requestId,
          rejectedWithValue: !!payload,
          requestStatus: "rejected",
          aborted: (error == null ? void 0 : error.name) === "AbortError",
          condition: (error == null ? void 0 : error.name) === "ConditionError"
        }
      }));
      function actionCreator(arg, {
        signal
      } = {}) {
        return (dispatch, getState, extra) => {
          const requestId = (options2 == null ? void 0 : options2.idGenerator) ? options2.idGenerator(arg) : nanoid();
          const abortController = new AbortController();
          let abortHandler;
          let abortReason;
          function abort(reason) {
            abortReason = reason;
            abortController.abort();
          }
          if (signal) {
            if (signal.aborted) {
              abort(externalAbortMessage);
            } else {
              signal.addEventListener("abort", () => abort(externalAbortMessage), {
                once: true
              });
            }
          }
          const promise = async function() {
            var _a, _b;
            let finalAction;
            try {
              let conditionResult = (_a = options2 == null ? void 0 : options2.condition) == null ? void 0 : _a.call(options2, arg, {
                getState,
                extra
              });
              if (isThenable(conditionResult)) {
                conditionResult = await conditionResult;
              }
              if (conditionResult === false || abortController.signal.aborted) {
                throw {
                  name: "ConditionError",
                  message: "Aborted due to condition callback returning false."
                };
              }
              const abortedPromise = new Promise((_, reject) => {
                abortHandler = () => {
                  reject({
                    name: "AbortError",
                    message: abortReason || "Aborted"
                  });
                };
                abortController.signal.addEventListener("abort", abortHandler);
              });
              dispatch(pending(requestId, arg, (_b = options2 == null ? void 0 : options2.getPendingMeta) == null ? void 0 : _b.call(options2, {
                requestId,
                arg
              }, {
                getState,
                extra
              })));
              finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
                dispatch,
                getState,
                extra,
                requestId,
                signal: abortController.signal,
                abort,
                rejectWithValue: (value, meta) => {
                  return new RejectWithValue(value, meta);
                },
                fulfillWithValue: (value, meta) => {
                  return new FulfillWithMeta(value, meta);
                }
              })).then((result) => {
                if (result instanceof RejectWithValue) {
                  throw result;
                }
                if (result instanceof FulfillWithMeta) {
                  return fulfilled(result.payload, requestId, arg, result.meta);
                }
                return fulfilled(result, requestId, arg);
              })]);
            } catch (err) {
              finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);
            } finally {
              if (abortHandler) {
                abortController.signal.removeEventListener("abort", abortHandler);
              }
            }
            const skipDispatch = options2 && !options2.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
            if (!skipDispatch) {
              dispatch(finalAction);
            }
            return finalAction;
          }();
          return Object.assign(promise, {
            abort,
            requestId,
            arg,
            unwrap() {
              return promise.then(unwrapResult);
            }
          });
        };
      }
      return Object.assign(actionCreator, {
        pending,
        rejected,
        fulfilled,
        settled: isAnyOf(rejected, fulfilled),
        typePrefix
      });
    }
    createAsyncThunk2.withTypes = () => createAsyncThunk2;
    return createAsyncThunk2;
  })();
  function unwrapResult(action) {
    if (action.meta && action.meta.rejectedWithValue) {
      throw action.payload;
    }
    if (action.error) {
      throw action.error;
    }
    return action.payload;
  }
  function isThenable(value) {
    return value !== null && typeof value === "object" && typeof value.then === "function";
  }
  var asyncThunkSymbol = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
  var asyncThunkCreator = {
    [asyncThunkSymbol]: createAsyncThunk
  };
  var ReducerType = /* @__PURE__ */ ((ReducerType2) => {
    ReducerType2["reducer"] = "reducer";
    ReducerType2["reducerWithPrepare"] = "reducerWithPrepare";
    ReducerType2["asyncThunk"] = "asyncThunk";
    return ReducerType2;
  })(ReducerType || {});
  function getType(slice2, actionKey) {
    return `${slice2}/${actionKey}`;
  }
  function buildCreateSlice({
    creators
  } = {}) {
    var _a;
    const cAT = (_a = creators == null ? void 0 : creators.asyncThunk) == null ? void 0 : _a[asyncThunkSymbol];
    return function createSlice2(options2) {
      const {
        name,
        reducerPath = name
      } = options2;
      if (!name) {
        throw new Error(false ? formatProdErrorMessage(11) : "`name` is a required option for createSlice");
      }
      if (typeof process !== "undefined" && true) {
        if (options2.initialState === void 0) {
          console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
        }
      }
      const reducers = (typeof options2.reducers === "function" ? options2.reducers(buildReducerCreators()) : options2.reducers) || {};
      const reducerNames = Object.keys(reducers);
      const context = {
        sliceCaseReducersByName: {},
        sliceCaseReducersByType: {},
        actionCreators: {},
        sliceMatchers: []
      };
      const contextMethods = {
        addCase(typeOrActionCreator, reducer22) {
          const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
          if (!type) {
            throw new Error(false ? formatProdErrorMessage(12) : "`context.addCase` cannot be called with an empty action type");
          }
          if (type in context.sliceCaseReducersByType) {
            throw new Error(false ? formatProdErrorMessage(13) : "`context.addCase` cannot be called with two reducers for the same action type: " + type);
          }
          context.sliceCaseReducersByType[type] = reducer22;
          return contextMethods;
        },
        addMatcher(matcher, reducer22) {
          context.sliceMatchers.push({
            matcher,
            reducer: reducer22
          });
          return contextMethods;
        },
        exposeAction(name2, actionCreator) {
          context.actionCreators[name2] = actionCreator;
          return contextMethods;
        },
        exposeCaseReducer(name2, reducer22) {
          context.sliceCaseReducersByName[name2] = reducer22;
          return contextMethods;
        }
      };
      reducerNames.forEach((reducerName) => {
        const reducerDefinition = reducers[reducerName];
        const reducerDetails = {
          reducerName,
          type: getType(name, reducerName),
          createNotation: typeof options2.reducers === "function"
        };
        if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
          handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
        } else {
          handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
        }
      });
      function buildReducer() {
        if (true) {
          if (typeof options2.extraReducers === "object") {
            throw new Error(false ? formatProdErrorMessage(14) : "The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
          }
        }
        const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options2.extraReducers === "function" ? executeReducerBuilderCallback(options2.extraReducers) : [options2.extraReducers];
        const finalCaseReducers = {
          ...extraReducers,
          ...context.sliceCaseReducersByType
        };
        return createReducer(options2.initialState, (builder) => {
          for (let key in finalCaseReducers) {
            builder.addCase(key, finalCaseReducers[key]);
          }
          for (let sM of context.sliceMatchers) {
            builder.addMatcher(sM.matcher, sM.reducer);
          }
          for (let m of actionMatchers) {
            builder.addMatcher(m.matcher, m.reducer);
          }
          if (defaultCaseReducer) {
            builder.addDefaultCase(defaultCaseReducer);
          }
        });
      }
      const selectSelf = (state) => state;
      const injectedSelectorCache = /* @__PURE__ */ new Map();
      const injectedStateCache = /* @__PURE__ */ new WeakMap();
      let _reducer;
      function reducer2(state, action) {
        if (!_reducer) _reducer = buildReducer();
        return _reducer(state, action);
      }
      function getInitialState() {
        if (!_reducer) _reducer = buildReducer();
        return _reducer.getInitialState();
      }
      function makeSelectorProps(reducerPath2, injected = false) {
        function selectSlice(state) {
          let sliceState = state[reducerPath2];
          if (typeof sliceState === "undefined") {
            if (injected) {
              sliceState = getOrInsertComputed(injectedStateCache, selectSlice, getInitialState);
            } else if (true) {
              throw new Error(false ? formatProdErrorMessage(15) : "selectSlice returned undefined for an uninjected slice reducer");
            }
          }
          return sliceState;
        }
        function getSelectors(selectState = selectSelf) {
          const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());
          return getOrInsertComputed(selectorCache, selectState, () => {
            const map2 = {};
            for (const [name2, selector] of Object.entries(options2.selectors ?? {})) {
              map2[name2] = wrapSelector(selector, selectState, () => getOrInsertComputed(injectedStateCache, selectState, getInitialState), injected);
            }
            return map2;
          });
        }
        return {
          reducerPath: reducerPath2,
          getSelectors,
          get selectors() {
            return getSelectors(selectSlice);
          },
          selectSlice
        };
      }
      const slice2 = {
        name,
        reducer: reducer2,
        actions: context.actionCreators,
        caseReducers: context.sliceCaseReducersByName,
        getInitialState,
        ...makeSelectorProps(reducerPath),
        injectInto(injectable, {
          reducerPath: pathOpt,
          ...config2
        } = {}) {
          const newReducerPath = pathOpt ?? reducerPath;
          injectable.inject({
            reducerPath: newReducerPath,
            reducer: reducer2
          }, config2);
          return {
            ...slice2,
            ...makeSelectorProps(newReducerPath, true)
          };
        }
      };
      return slice2;
    };
  }
  function wrapSelector(selector, selectState, getInitialState, injected) {
    function wrapper(rootState, ...args) {
      let sliceState = selectState(rootState);
      if (typeof sliceState === "undefined") {
        if (injected) {
          sliceState = getInitialState();
        } else if (true) {
          throw new Error(false ? formatProdErrorMessage(16) : "selectState returned undefined for an uninjected slice reducer");
        }
      }
      return selector(sliceState, ...args);
    }
    wrapper.unwrapped = selector;
    return wrapper;
  }
  var createSlice = /* @__PURE__ */ buildCreateSlice();
  function buildReducerCreators() {
    function asyncThunk(payloadCreator, config2) {
      return {
        _reducerDefinitionType: "asyncThunk",
        payloadCreator,
        ...config2
      };
    }
    asyncThunk.withTypes = () => asyncThunk;
    return {
      reducer(caseReducer) {
        return Object.assign({
          // hack so the wrapping function has the same name as the original
          // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
          [caseReducer.name](...args) {
            return caseReducer(...args);
          }
        }[caseReducer.name], {
          _reducerDefinitionType: "reducer"
          /* reducer */
        });
      },
      preparedReducer(prepare, reducer2) {
        return {
          _reducerDefinitionType: "reducerWithPrepare",
          prepare,
          reducer: reducer2
        };
      },
      asyncThunk
    };
  }
  function handleNormalReducerDefinition({
    type,
    reducerName,
    createNotation
  }, maybeReducerWithPrepare, context) {
    let caseReducer;
    let prepareCallback;
    if ("reducer" in maybeReducerWithPrepare) {
      if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
        throw new Error(false ? formatProdErrorMessage(17) : "Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
      }
      caseReducer = maybeReducerWithPrepare.reducer;
      prepareCallback = maybeReducerWithPrepare.prepare;
    } else {
      caseReducer = maybeReducerWithPrepare;
    }
    context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
  }
  function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
    return reducerDefinition._reducerDefinitionType === "asyncThunk";
  }
  function isCaseReducerWithPrepareDefinition(reducerDefinition) {
    return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
  }
  function handleThunkCaseReducerDefinition({
    type,
    reducerName
  }, reducerDefinition, context, cAT) {
    if (!cAT) {
      throw new Error(false ? formatProdErrorMessage(18) : "Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
    }
    const {
      payloadCreator,
      fulfilled,
      pending,
      rejected,
      settled,
      options: options2
    } = reducerDefinition;
    const thunk2 = cAT(type, payloadCreator, options2);
    context.exposeAction(reducerName, thunk2);
    if (fulfilled) {
      context.addCase(thunk2.fulfilled, fulfilled);
    }
    if (pending) {
      context.addCase(thunk2.pending, pending);
    }
    if (rejected) {
      context.addCase(thunk2.rejected, rejected);
    }
    if (settled) {
      context.addMatcher(thunk2.settled, settled);
    }
    context.exposeCaseReducer(reducerName, {
      fulfilled: fulfilled || noop$6,
      pending: pending || noop$6,
      rejected: rejected || noop$6,
      settled: settled || noop$6
    });
  }
  function noop$6() {
  }
  function getInitialEntityState() {
    return {
      ids: [],
      entities: {}
    };
  }
  function createInitialStateFactory(stateAdapter) {
    function getInitialState(additionalState = {}, entities) {
      const state = Object.assign(getInitialEntityState(), additionalState);
      return entities ? stateAdapter.setAll(state, entities) : state;
    }
    return {
      getInitialState
    };
  }
  function createSelectorsFactory() {
    function getSelectors(selectState, options2 = {}) {
      const {
        createSelector: createSelector2 = createDraftSafeSelector
      } = options2;
      const selectIds = (state) => state.ids;
      const selectEntities = (state) => state.entities;
      const selectAll = createSelector2(selectIds, selectEntities, (ids, entities) => ids.map((id) => entities[id]));
      const selectId = (_, id) => id;
      const selectById = (entities, id) => entities[id];
      const selectTotal = createSelector2(selectIds, (ids) => ids.length);
      if (!selectState) {
        return {
          selectIds,
          selectEntities,
          selectAll,
          selectTotal,
          selectById: createSelector2(selectEntities, selectId, selectById)
        };
      }
      const selectGlobalizedEntities = createSelector2(selectState, selectEntities);
      return {
        selectIds: createSelector2(selectState, selectIds),
        selectEntities: selectGlobalizedEntities,
        selectAll: createSelector2(selectState, selectAll),
        selectTotal: createSelector2(selectState, selectTotal),
        selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)
      };
    }
    return {
      getSelectors
    };
  }
  var isDraftTyped = isDraft;
  function createSingleArgumentStateOperator(mutator) {
    const operator = createStateOperator((_, state) => mutator(state));
    return function operation(state) {
      return operator(state, void 0);
    };
  }
  function createStateOperator(mutator) {
    return function operation(state, arg) {
      function isPayloadActionArgument(arg2) {
        return isFSA(arg2);
      }
      const runMutator = (draft) => {
        if (isPayloadActionArgument(arg)) {
          mutator(arg.payload, draft);
        } else {
          mutator(arg, draft);
        }
      };
      if (isDraftTyped(state)) {
        runMutator(state);
        return state;
      }
      return produce(state, runMutator);
    };
  }
  function selectIdValue(entity, selectId) {
    const key = selectId(entity);
    if (key === void 0) {
      console.warn("The entity passed to the `selectId` implementation returned undefined.", "You should probably provide your own `selectId` implementation.", "The entity that was passed:", entity, "The `selectId` implementation:", selectId.toString());
    }
    return key;
  }
  function ensureEntitiesArray(entities) {
    if (!Array.isArray(entities)) {
      entities = Object.values(entities);
    }
    return entities;
  }
  function getCurrent(value) {
    return isDraft(value) ? current(value) : value;
  }
  function splitAddedUpdatedEntities(newEntities, selectId, state) {
    newEntities = ensureEntitiesArray(newEntities);
    const existingIdsArray = getCurrent(state.ids);
    const existingIds = new Set(existingIdsArray);
    const added = [];
    const addedIds = /* @__PURE__ */ new Set([]);
    const updated = [];
    for (const entity of newEntities) {
      const id = selectIdValue(entity, selectId);
      if (existingIds.has(id) || addedIds.has(id)) {
        updated.push({
          id,
          changes: entity
        });
      } else {
        addedIds.add(id);
        added.push(entity);
      }
    }
    return [added, updated, existingIdsArray];
  }
  function createUnsortedStateAdapter(selectId) {
    function addOneMutably(entity, state) {
      const key = selectIdValue(entity, selectId);
      if (key in state.entities) {
        return;
      }
      state.ids.push(key);
      state.entities[key] = entity;
    }
    function addManyMutably(newEntities, state) {
      newEntities = ensureEntitiesArray(newEntities);
      for (const entity of newEntities) {
        addOneMutably(entity, state);
      }
    }
    function setOneMutably(entity, state) {
      const key = selectIdValue(entity, selectId);
      if (!(key in state.entities)) {
        state.ids.push(key);
      }
      ;
      state.entities[key] = entity;
    }
    function setManyMutably(newEntities, state) {
      newEntities = ensureEntitiesArray(newEntities);
      for (const entity of newEntities) {
        setOneMutably(entity, state);
      }
    }
    function setAllMutably(newEntities, state) {
      newEntities = ensureEntitiesArray(newEntities);
      state.ids = [];
      state.entities = {};
      addManyMutably(newEntities, state);
    }
    function removeOneMutably(key, state) {
      return removeManyMutably([key], state);
    }
    function removeManyMutably(keys, state) {
      let didMutate = false;
      keys.forEach((key) => {
        if (key in state.entities) {
          delete state.entities[key];
          didMutate = true;
        }
      });
      if (didMutate) {
        state.ids = state.ids.filter((id) => id in state.entities);
      }
    }
    function removeAllMutably(state) {
      Object.assign(state, {
        ids: [],
        entities: {}
      });
    }
    function takeNewKey(keys, update, state) {
      const original3 = state.entities[update.id];
      if (original3 === void 0) {
        return false;
      }
      const updated = Object.assign({}, original3, update.changes);
      const newKey = selectIdValue(updated, selectId);
      const hasNewKey = newKey !== update.id;
      if (hasNewKey) {
        keys[update.id] = newKey;
        delete state.entities[update.id];
      }
      ;
      state.entities[newKey] = updated;
      return hasNewKey;
    }
    function updateOneMutably(update, state) {
      return updateManyMutably([update], state);
    }
    function updateManyMutably(updates, state) {
      const newKeys = {};
      const updatesPerEntity = {};
      updates.forEach((update) => {
        var _a;
        if (update.id in state.entities) {
          updatesPerEntity[update.id] = {
            id: update.id,
            // Spreads ignore falsy values, so this works even if there isn't
            // an existing update already at this key
            changes: {
              ...(_a = updatesPerEntity[update.id]) == null ? void 0 : _a.changes,
              ...update.changes
            }
          };
        }
      });
      updates = Object.values(updatesPerEntity);
      const didMutateEntities = updates.length > 0;
      if (didMutateEntities) {
        const didMutateIds = updates.filter((update) => takeNewKey(newKeys, update, state)).length > 0;
        if (didMutateIds) {
          state.ids = Object.values(state.entities).map((e) => selectIdValue(e, selectId));
        }
      }
    }
    function upsertOneMutably(entity, state) {
      return upsertManyMutably([entity], state);
    }
    function upsertManyMutably(newEntities, state) {
      const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);
      addManyMutably(added, state);
      updateManyMutably(updated, state);
    }
    return {
      removeAll: createSingleArgumentStateOperator(removeAllMutably),
      addOne: createStateOperator(addOneMutably),
      addMany: createStateOperator(addManyMutably),
      setOne: createStateOperator(setOneMutably),
      setMany: createStateOperator(setManyMutably),
      setAll: createStateOperator(setAllMutably),
      updateOne: createStateOperator(updateOneMutably),
      updateMany: createStateOperator(updateManyMutably),
      upsertOne: createStateOperator(upsertOneMutably),
      upsertMany: createStateOperator(upsertManyMutably),
      removeOne: createStateOperator(removeOneMutably),
      removeMany: createStateOperator(removeManyMutably)
    };
  }
  function findInsertIndex(sortedItems, item, comparisonFunction) {
    let lowIndex = 0;
    let highIndex = sortedItems.length;
    while (lowIndex < highIndex) {
      let middleIndex = lowIndex + highIndex >>> 1;
      const currentItem = sortedItems[middleIndex];
      const res = comparisonFunction(item, currentItem);
      if (res >= 0) {
        lowIndex = middleIndex + 1;
      } else {
        highIndex = middleIndex;
      }
    }
    return lowIndex;
  }
  function insert(sortedItems, item, comparisonFunction) {
    const insertAtIndex = findInsertIndex(sortedItems, item, comparisonFunction);
    sortedItems.splice(insertAtIndex, 0, item);
    return sortedItems;
  }
  function createSortedStateAdapter(selectId, comparer) {
    const {
      removeOne,
      removeMany,
      removeAll
    } = createUnsortedStateAdapter(selectId);
    function addOneMutably(entity, state) {
      return addManyMutably([entity], state);
    }
    function addManyMutably(newEntities, state, existingIds) {
      newEntities = ensureEntitiesArray(newEntities);
      const existingKeys = new Set(existingIds ?? getCurrent(state.ids));
      const models = newEntities.filter((model) => !existingKeys.has(selectIdValue(model, selectId)));
      if (models.length !== 0) {
        mergeFunction(state, models);
      }
    }
    function setOneMutably(entity, state) {
      return setManyMutably([entity], state);
    }
    function setManyMutably(newEntities, state) {
      newEntities = ensureEntitiesArray(newEntities);
      if (newEntities.length !== 0) {
        for (const item of newEntities) {
          delete state.entities[selectId(item)];
        }
        mergeFunction(state, newEntities);
      }
    }
    function setAllMutably(newEntities, state) {
      newEntities = ensureEntitiesArray(newEntities);
      state.entities = {};
      state.ids = [];
      addManyMutably(newEntities, state, []);
    }
    function updateOneMutably(update, state) {
      return updateManyMutably([update], state);
    }
    function updateManyMutably(updates, state) {
      let appliedUpdates = false;
      let replacedIds = false;
      for (let update of updates) {
        const entity = state.entities[update.id];
        if (!entity) {
          continue;
        }
        appliedUpdates = true;
        Object.assign(entity, update.changes);
        const newId = selectId(entity);
        if (update.id !== newId) {
          replacedIds = true;
          delete state.entities[update.id];
          const oldIndex = state.ids.indexOf(update.id);
          state.ids[oldIndex] = newId;
          state.entities[newId] = entity;
        }
      }
      if (appliedUpdates) {
        mergeFunction(state, [], appliedUpdates, replacedIds);
      }
    }
    function upsertOneMutably(entity, state) {
      return upsertManyMutably([entity], state);
    }
    function upsertManyMutably(newEntities, state) {
      const [added, updated, existingIdsArray] = splitAddedUpdatedEntities(newEntities, selectId, state);
      if (added.length) {
        addManyMutably(added, state, existingIdsArray);
      }
      if (updated.length) {
        updateManyMutably(updated, state);
      }
    }
    function areArraysEqual(a2, b) {
      if (a2.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a2.length; i++) {
        if (a2[i] === b[i]) {
          continue;
        }
        return false;
      }
      return true;
    }
    const mergeFunction = (state, addedItems, appliedUpdates, replacedIds) => {
      const currentEntities = getCurrent(state.entities);
      const currentIds = getCurrent(state.ids);
      const stateEntities = state.entities;
      let ids = currentIds;
      if (replacedIds) {
        ids = new Set(currentIds);
      }
      let sortedEntities = [];
      for (const id of ids) {
        const entity = currentEntities[id];
        if (entity) {
          sortedEntities.push(entity);
        }
      }
      const wasPreviouslyEmpty = sortedEntities.length === 0;
      for (const item of addedItems) {
        stateEntities[selectId(item)] = item;
        if (!wasPreviouslyEmpty) {
          insert(sortedEntities, item, comparer);
        }
      }
      if (wasPreviouslyEmpty) {
        sortedEntities = addedItems.slice().sort(comparer);
      } else if (appliedUpdates) {
        sortedEntities.sort(comparer);
      }
      const newSortedIds = sortedEntities.map(selectId);
      if (!areArraysEqual(currentIds, newSortedIds)) {
        state.ids = newSortedIds;
      }
    };
    return {
      removeOne,
      removeMany,
      removeAll,
      addOne: createStateOperator(addOneMutably),
      updateOne: createStateOperator(updateOneMutably),
      upsertOne: createStateOperator(upsertOneMutably),
      setOne: createStateOperator(setOneMutably),
      setMany: createStateOperator(setManyMutably),
      setAll: createStateOperator(setAllMutably),
      addMany: createStateOperator(addManyMutably),
      updateMany: createStateOperator(updateManyMutably),
      upsertMany: createStateOperator(upsertManyMutably)
    };
  }
  function createEntityAdapter(options2 = {}) {
    const {
      selectId,
      sortComparer
    } = {
      sortComparer: false,
      selectId: (instance) => instance.id,
      ...options2
    };
    const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);
    const stateFactory = createInitialStateFactory(stateAdapter);
    const selectorsFactory = createSelectorsFactory();
    return {
      selectId,
      sortComparer,
      ...stateFactory,
      ...selectorsFactory,
      ...stateAdapter
    };
  }
  var task = "task";
  var listener = "listener";
  var completed = "completed";
  var cancelled = "cancelled";
  var taskCancelled = `task-${cancelled}`;
  var taskCompleted = `task-${completed}`;
  var listenerCancelled = `${listener}-${cancelled}`;
  var listenerCompleted = `${listener}-${completed}`;
  var TaskAbortError = class {
    constructor(code) {
      __publicField(this, "name", "TaskAbortError");
      __publicField(this, "message");
      this.code = code;
      this.message = `${task} ${cancelled} (reason: ${code})`;
    }
  };
  var assertFunction = (func, expected) => {
    if (typeof func !== "function") {
      throw new TypeError(false ? formatProdErrorMessage(32) : `${expected} is not a function`);
    }
  };
  var noop2 = () => {
  };
  var catchRejection = (promise, onError = noop2) => {
    promise.catch(onError);
    return promise;
  };
  var addAbortSignalListener = (abortSignal, callback) => {
    abortSignal.addEventListener("abort", callback, {
      once: true
    });
    return () => abortSignal.removeEventListener("abort", callback);
  };
  var abortControllerWithReason = (abortController, reason) => {
    const signal = abortController.signal;
    if (signal.aborted) {
      return;
    }
    if (!("reason" in signal)) {
      Object.defineProperty(signal, "reason", {
        enumerable: true,
        value: reason,
        configurable: true,
        writable: true
      });
    }
    ;
    abortController.abort(reason);
  };
  var validateActive = (signal) => {
    if (signal.aborted) {
      const {
        reason
      } = signal;
      throw new TaskAbortError(reason);
    }
  };
  function raceWithSignal(signal, promise) {
    let cleanup = noop2;
    return new Promise((resolve, reject) => {
      const notifyRejection = () => reject(new TaskAbortError(signal.reason));
      if (signal.aborted) {
        notifyRejection();
        return;
      }
      cleanup = addAbortSignalListener(signal, notifyRejection);
      promise.finally(() => cleanup()).then(resolve, reject);
    }).finally(() => {
      cleanup = noop2;
    });
  }
  var runTask = async (task2, cleanUp) => {
    try {
      await Promise.resolve();
      const value = await task2();
      return {
        status: "ok",
        value
      };
    } catch (error) {
      return {
        status: error instanceof TaskAbortError ? "cancelled" : "rejected",
        error
      };
    } finally {
      cleanUp == null ? void 0 : cleanUp();
    }
  };
  var createPause = (signal) => {
    return (promise) => {
      return catchRejection(raceWithSignal(signal, promise).then((output) => {
        validateActive(signal);
        return output;
      }));
    };
  };
  var createDelay = (signal) => {
    const pause = createPause(signal);
    return (timeoutMs) => {
      return pause(new Promise((resolve) => setTimeout(resolve, timeoutMs)));
    };
  };
  var {
    assign
  } = Object;
  var INTERNAL_NIL_TOKEN = {};
  var alm = "listenerMiddleware";
  var createFork = (parentAbortSignal, parentBlockingPromises) => {
    const linkControllers = (controller) => addAbortSignalListener(parentAbortSignal, () => abortControllerWithReason(controller, parentAbortSignal.reason));
    return (taskExecutor, opts) => {
      assertFunction(taskExecutor, "taskExecutor");
      const childAbortController = new AbortController();
      linkControllers(childAbortController);
      const result = runTask(async () => {
        validateActive(parentAbortSignal);
        validateActive(childAbortController.signal);
        const result2 = await taskExecutor({
          pause: createPause(childAbortController.signal),
          delay: createDelay(childAbortController.signal),
          signal: childAbortController.signal
        });
        validateActive(childAbortController.signal);
        return result2;
      }, () => abortControllerWithReason(childAbortController, taskCompleted));
      if (opts == null ? void 0 : opts.autoJoin) {
        parentBlockingPromises.push(result.catch(noop2));
      }
      return {
        result: createPause(parentAbortSignal)(result),
        cancel() {
          abortControllerWithReason(childAbortController, taskCancelled);
        }
      };
    };
  };
  var createTakePattern = (startListening, signal) => {
    const take2 = async (predicate, timeout2) => {
      validateActive(signal);
      let unsubscribe = () => {
      };
      const tuplePromise = new Promise((resolve, reject) => {
        let stopListening = startListening({
          predicate,
          effect: (action, listenerApi) => {
            listenerApi.unsubscribe();
            resolve([action, listenerApi.getState(), listenerApi.getOriginalState()]);
          }
        });
        unsubscribe = () => {
          stopListening();
          reject();
        };
      });
      const promises = [tuplePromise];
      if (timeout2 != null) {
        promises.push(new Promise((resolve) => setTimeout(resolve, timeout2, null)));
      }
      try {
        const output = await raceWithSignal(signal, Promise.race(promises));
        validateActive(signal);
        return output;
      } finally {
        unsubscribe();
      }
    };
    return (predicate, timeout2) => catchRejection(take2(predicate, timeout2));
  };
  var getListenerEntryPropsFrom = (options2) => {
    let {
      type,
      actionCreator,
      matcher,
      predicate,
      effect
    } = options2;
    if (type) {
      predicate = createAction(type).match;
    } else if (actionCreator) {
      type = actionCreator.type;
      predicate = actionCreator.match;
    } else if (matcher) {
      predicate = matcher;
    } else if (predicate) {
    } else {
      throw new Error(false ? formatProdErrorMessage(21) : "Creating or removing a listener requires one of the known fields for matching an action");
    }
    assertFunction(effect, "options.listener");
    return {
      predicate,
      type,
      effect
    };
  };
  var createListenerEntry = /* @__PURE__ */ assign((options2) => {
    const {
      type,
      predicate,
      effect
    } = getListenerEntryPropsFrom(options2);
    const entry = {
      id: nanoid(),
      effect,
      type,
      predicate,
      pending: /* @__PURE__ */ new Set(),
      unsubscribe: () => {
        throw new Error(false ? formatProdErrorMessage(22) : "Unsubscribe not initialized");
      }
    };
    return entry;
  }, {
    withTypes: () => createListenerEntry
  });
  var findListenerEntry = (listenerMap, options2) => {
    const {
      type,
      effect,
      predicate
    } = getListenerEntryPropsFrom(options2);
    return Array.from(listenerMap.values()).find((entry) => {
      const matchPredicateOrType = typeof type === "string" ? entry.type === type : entry.predicate === predicate;
      return matchPredicateOrType && entry.effect === effect;
    });
  };
  var cancelActiveListeners = (entry) => {
    entry.pending.forEach((controller) => {
      abortControllerWithReason(controller, listenerCancelled);
    });
  };
  var createClearListenerMiddleware = (listenerMap) => {
    return () => {
      listenerMap.forEach(cancelActiveListeners);
      listenerMap.clear();
    };
  };
  var safelyNotifyError = (errorHandler, errorToNotify, errorInfo) => {
    try {
      errorHandler(errorToNotify, errorInfo);
    } catch (errorHandlerError) {
      setTimeout(() => {
        throw errorHandlerError;
      }, 0);
    }
  };
  var addListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/add`), {
    withTypes: () => addListener
  });
  var clearAllListeners = /* @__PURE__ */ createAction(`${alm}/removeAll`);
  var removeListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/remove`), {
    withTypes: () => removeListener
  });
  var defaultErrorHandler = (...args) => {
    console.error(`${alm}/error`, ...args);
  };
  var createListenerMiddleware = (middlewareOptions = {}) => {
    const listenerMap = /* @__PURE__ */ new Map();
    const {
      extra,
      onError = defaultErrorHandler
    } = middlewareOptions;
    assertFunction(onError, "onError");
    const insertEntry = (entry) => {
      entry.unsubscribe = () => listenerMap.delete(entry.id);
      listenerMap.set(entry.id, entry);
      return (cancelOptions) => {
        entry.unsubscribe();
        if (cancelOptions == null ? void 0 : cancelOptions.cancelActive) {
          cancelActiveListeners(entry);
        }
      };
    };
    const startListening = (options2) => {
      const entry = findListenerEntry(listenerMap, options2) ?? createListenerEntry(options2);
      return insertEntry(entry);
    };
    assign(startListening, {
      withTypes: () => startListening
    });
    const stopListening = (options2) => {
      const entry = findListenerEntry(listenerMap, options2);
      if (entry) {
        entry.unsubscribe();
        if (options2.cancelActive) {
          cancelActiveListeners(entry);
        }
      }
      return !!entry;
    };
    assign(stopListening, {
      withTypes: () => stopListening
    });
    const notifyListener = async (entry, action, api2, getOriginalState) => {
      const internalTaskController = new AbortController();
      const take2 = createTakePattern(startListening, internalTaskController.signal);
      const autoJoinPromises = [];
      try {
        entry.pending.add(internalTaskController);
        await Promise.resolve(entry.effect(
          action,
          // Use assign() rather than ... to avoid extra helper functions added to bundle
          assign({}, api2, {
            getOriginalState,
            condition: (predicate, timeout2) => take2(predicate, timeout2).then(Boolean),
            take: take2,
            delay: createDelay(internalTaskController.signal),
            pause: createPause(internalTaskController.signal),
            extra,
            signal: internalTaskController.signal,
            fork: createFork(internalTaskController.signal, autoJoinPromises),
            unsubscribe: entry.unsubscribe,
            subscribe: () => {
              listenerMap.set(entry.id, entry);
            },
            cancelActiveListeners: () => {
              entry.pending.forEach((controller, _, set2) => {
                if (controller !== internalTaskController) {
                  abortControllerWithReason(controller, listenerCancelled);
                  set2.delete(controller);
                }
              });
            },
            cancel: () => {
              abortControllerWithReason(internalTaskController, listenerCancelled);
              entry.pending.delete(internalTaskController);
            },
            throwIfCancelled: () => {
              validateActive(internalTaskController.signal);
            }
          })
        ));
      } catch (listenerError) {
        if (!(listenerError instanceof TaskAbortError)) {
          safelyNotifyError(onError, listenerError, {
            raisedBy: "effect"
          });
        }
      } finally {
        await Promise.all(autoJoinPromises);
        abortControllerWithReason(internalTaskController, listenerCompleted);
        entry.pending.delete(internalTaskController);
      }
    };
    const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);
    const middleware = (api2) => (next) => (action) => {
      if (!isAction(action)) {
        return next(action);
      }
      if (addListener.match(action)) {
        return startListening(action.payload);
      }
      if (clearAllListeners.match(action)) {
        clearListenerMiddleware();
        return;
      }
      if (removeListener.match(action)) {
        return stopListening(action.payload);
      }
      let originalState = api2.getState();
      const getOriginalState = () => {
        if (originalState === INTERNAL_NIL_TOKEN) {
          throw new Error(false ? formatProdErrorMessage(23) : `${alm}: getOriginalState can only be called synchronously`);
        }
        return originalState;
      };
      let result;
      try {
        result = next(action);
        if (listenerMap.size > 0) {
          const currentState = api2.getState();
          const listenerEntries = Array.from(listenerMap.values());
          for (const entry of listenerEntries) {
            let runListener = false;
            try {
              runListener = entry.predicate(action, currentState, originalState);
            } catch (predicateError) {
              runListener = false;
              safelyNotifyError(onError, predicateError, {
                raisedBy: "predicate"
              });
            }
            if (!runListener) {
              continue;
            }
            notifyListener(entry, action, api2, getOriginalState);
          }
        }
      } finally {
        originalState = INTERNAL_NIL_TOKEN;
      }
      return result;
    };
    return {
      middleware,
      startListening,
      stopListening,
      clearListeners: clearListenerMiddleware
    };
  };
  var createMiddlewareEntry = (middleware) => ({
    middleware,
    applied: /* @__PURE__ */ new Map()
  });
  var matchInstance = (instanceId) => (action) => {
    var _a;
    return ((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a.instanceId) === instanceId;
  };
  var createDynamicMiddleware = () => {
    const instanceId = nanoid();
    const middlewareMap = /* @__PURE__ */ new Map();
    const withMiddleware = Object.assign(createAction("dynamicMiddleware/add", (...middlewares) => ({
      payload: middlewares,
      meta: {
        instanceId
      }
    })), {
      withTypes: () => withMiddleware
    });
    const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {
      middlewares.forEach((middleware2) => {
        getOrInsertComputed(middlewareMap, middleware2, createMiddlewareEntry);
      });
    }, {
      withTypes: () => addMiddleware
    });
    const getFinalMiddleware = (api2) => {
      const appliedMiddleware = Array.from(middlewareMap.values()).map((entry) => getOrInsertComputed(entry.applied, api2, entry.middleware));
      return compose$1(...appliedMiddleware);
    };
    const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));
    const middleware = (api2) => (next) => (action) => {
      if (isWithMiddleware(action)) {
        addMiddleware(...action.payload);
        return api2.dispatch;
      }
      return getFinalMiddleware(api2)(next)(action);
    };
    return {
      middleware,
      addMiddleware,
      withMiddleware,
      instanceId
    };
  };
  var isSliceLike = (maybeSliceLike) => "reducerPath" in maybeSliceLike && typeof maybeSliceLike.reducerPath === "string";
  var getReducers = (slices) => slices.flatMap((sliceOrMap) => isSliceLike(sliceOrMap) ? [[sliceOrMap.reducerPath, sliceOrMap.reducer]] : Object.entries(sliceOrMap));
  var ORIGINAL_STATE = Symbol.for("rtk-state-proxy-original");
  var isStateProxy = (value) => !!value && !!value[ORIGINAL_STATE];
  var stateProxyMap = /* @__PURE__ */ new WeakMap();
  var createStateProxy = (state, reducerMap, initialStateCache) => getOrInsertComputed(stateProxyMap, state, () => new Proxy(state, {
    get: (target, prop, receiver) => {
      if (prop === ORIGINAL_STATE) return target;
      const result = Reflect.get(target, prop, receiver);
      if (typeof result === "undefined") {
        const cached = initialStateCache[prop];
        if (typeof cached !== "undefined") return cached;
        const reducer2 = reducerMap[prop];
        if (reducer2) {
          const reducerResult = reducer2(void 0, {
            type: nanoid()
          });
          if (typeof reducerResult === "undefined") {
            throw new Error(false ? formatProdErrorMessage(24) : `The slice reducer for key "${prop.toString()}" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
          }
          initialStateCache[prop] = reducerResult;
          return reducerResult;
        }
      }
      return result;
    }
  }));
  var original = (state) => {
    if (!isStateProxy(state)) {
      throw new Error(false ? formatProdErrorMessage(25) : "original must be used on state Proxy");
    }
    return state[ORIGINAL_STATE];
  };
  var emptyObject = {};
  var noopReducer = (state = emptyObject) => state;
  function combineSlices(...slices) {
    const reducerMap = Object.fromEntries(getReducers(slices));
    const getReducer = () => Object.keys(reducerMap).length ? combineReducers(reducerMap) : noopReducer;
    let reducer2 = getReducer();
    function combinedReducer(state, action) {
      return reducer2(state, action);
    }
    combinedReducer.withLazyLoadedSlices = () => combinedReducer;
    const initialStateCache = {};
    const inject = (slice2, config2 = {}) => {
      const {
        reducerPath,
        reducer: reducerToInject
      } = slice2;
      const currentReducer = reducerMap[reducerPath];
      if (!config2.overrideExisting && currentReducer && currentReducer !== reducerToInject) {
        if (typeof process !== "undefined" && true) {
          console.error(`called \`inject\` to override already-existing reducer ${reducerPath} without specifying \`overrideExisting: true\``);
        }
        return combinedReducer;
      }
      if (config2.overrideExisting && currentReducer !== reducerToInject) {
        delete initialStateCache[reducerPath];
      }
      reducerMap[reducerPath] = reducerToInject;
      reducer2 = getReducer();
      return combinedReducer;
    };
    const selector = Object.assign(function makeSelector(selectorFn, selectState) {
      return function selector2(state, ...args) {
        return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap, initialStateCache), ...args);
      };
    }, {
      original
    });
    return Object.assign(combinedReducer, {
      inject,
      selector
    });
  }
  function formatProdErrorMessage(code) {
    return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
  }
  var initialState$a = {
    layoutType: "horizontal",
    width: 0,
    height: 0,
    margin: {
      top: 5,
      right: 5,
      bottom: 5,
      left: 5
    },
    scale: 1
  };
  var chartLayoutSlice = createSlice({
    name: "chartLayout",
    initialState: initialState$a,
    reducers: {
      setLayout(state, action) {
        state.layoutType = action.payload;
      },
      setChartSize(state, action) {
        state.width = action.payload.width;
        state.height = action.payload.height;
      },
      setMargin(state, action) {
        state.margin.top = action.payload.top;
        state.margin.right = action.payload.right;
        state.margin.bottom = action.payload.bottom;
        state.margin.left = action.payload.left;
      },
      setScale(state, action) {
        state.scale = action.payload;
      }
    }
  });
  var {
    setMargin,
    setLayout,
    setChartSize,
    setScale
  } = chartLayoutSlice.actions;
  var chartLayoutReducer = chartLayoutSlice.reducer;
  function ownKeys$V(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$V(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$V(Object(t), true).forEach(function(r3) {
        _defineProperty$Z(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$V(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$Z(e, r2, t) {
    return (r2 = _toPropertyKey$Z(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$Z(t) {
    var i = _toPrimitive$Z(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$Z(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var RADIAN$1 = Math.PI / 180;
  var degreeToRadian = (angle) => angle * Math.PI / 180;
  var radianToDegree = (angleInRadian) => angleInRadian * 180 / Math.PI;
  var polarToCartesian = (cx, cy, radius, angle) => ({
    x: cx + Math.cos(-RADIAN$1 * angle) * radius,
    y: cy + Math.sin(-RADIAN$1 * angle) * radius
  });
  var getMaxRadius = function getMaxRadius2(width, height) {
    var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      width: 0,
      height: 0,
      brushBottom: 0
    };
    return Math.min(Math.abs(width - (offset.left || 0) - (offset.right || 0)), Math.abs(height - (offset.top || 0) - (offset.bottom || 0))) / 2;
  };
  var distanceBetweenPoints = (point2, anotherPoint) => {
    var {
      x: x1,
      y: y1
    } = point2;
    var {
      x: x2,
      y: y2
    } = anotherPoint;
    return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
  };
  var getAngleOfPoint = (_ref2, _ref22) => {
    var {
      x: x2,
      y: y2
    } = _ref2;
    var {
      cx,
      cy
    } = _ref22;
    var radius = distanceBetweenPoints({
      x: x2,
      y: y2
    }, {
      x: cx,
      y: cy
    });
    if (radius <= 0) {
      return {
        radius,
        angle: 0
      };
    }
    var cos2 = (x2 - cx) / radius;
    var angleInRadian = Math.acos(cos2);
    if (y2 > cy) {
      angleInRadian = 2 * Math.PI - angleInRadian;
    }
    return {
      radius,
      angle: radianToDegree(angleInRadian),
      angleInRadian
    };
  };
  var formatAngleOfSector = (_ref3) => {
    var {
      startAngle,
      endAngle
    } = _ref3;
    var startCnt = Math.floor(startAngle / 360);
    var endCnt = Math.floor(endAngle / 360);
    var min2 = Math.min(startCnt, endCnt);
    return {
      startAngle: startAngle - min2 * 360,
      endAngle: endAngle - min2 * 360
    };
  };
  var reverseFormatAngleOfSector = (angle, _ref4) => {
    var {
      startAngle,
      endAngle
    } = _ref4;
    var startCnt = Math.floor(startAngle / 360);
    var endCnt = Math.floor(endAngle / 360);
    var min2 = Math.min(startCnt, endCnt);
    return angle + min2 * 360;
  };
  var inRangeOfSector = (_ref5, viewBox) => {
    var {
      x: x2,
      y: y2
    } = _ref5;
    var {
      radius,
      angle
    } = getAngleOfPoint({
      x: x2,
      y: y2
    }, viewBox);
    var {
      innerRadius,
      outerRadius
    } = viewBox;
    if (radius < innerRadius || radius > outerRadius) {
      return null;
    }
    if (radius === 0) {
      return null;
    }
    var {
      startAngle,
      endAngle
    } = formatAngleOfSector(viewBox);
    var formatAngle = angle;
    var inRange2;
    if (startAngle <= endAngle) {
      while (formatAngle > endAngle) {
        formatAngle -= 360;
      }
      while (formatAngle < startAngle) {
        formatAngle += 360;
      }
      inRange2 = formatAngle >= startAngle && formatAngle <= endAngle;
    } else {
      while (formatAngle > startAngle) {
        formatAngle -= 360;
      }
      while (formatAngle < endAngle) {
        formatAngle += 360;
      }
      inRange2 = formatAngle >= endAngle && formatAngle <= startAngle;
    }
    if (inRange2) {
      return _objectSpread$V(_objectSpread$V({}, viewBox), {}, {
        radius,
        angle: reverseFormatAngleOfSector(formatAngle, viewBox)
      });
    }
    return null;
  };
  var getTickClassName = (tick) => !/* @__PURE__ */ React.isValidElement(tick) && typeof tick !== "function" && typeof tick !== "boolean" && tick != null ? tick.className : "";
  function getSliced(arr, startIndex, endIndex) {
    if (!Array.isArray(arr)) {
      return arr;
    }
    if (arr && startIndex + endIndex !== 0) {
      return arr.slice(startIndex, endIndex + 1);
    }
    return arr;
  }
  function ownKeys$U(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$U(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$U(Object(t), true).forEach(function(r3) {
        _defineProperty$Y(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$U(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$Y(e, r2, t) {
    return (r2 = _toPropertyKey$Y(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$Y(t) {
    var i = _toPrimitive$Y(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$Y(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function getValueByDataKey(obj, dataKey, defaultValue) {
    if (isNullish(obj) || isNullish(dataKey)) {
      return defaultValue;
    }
    if (isNumOrStr(dataKey)) {
      return get$2(obj, dataKey, defaultValue);
    }
    if (typeof dataKey === "function") {
      return dataKey(obj);
    }
    return defaultValue;
  }
  var calculateActiveTickIndex = (coordinate, ticks2, unsortedTicks, axisType, range2) => {
    var _ticks$length;
    var index2 = -1;
    var len = (_ticks$length = ticks2 === null || ticks2 === void 0 ? void 0 : ticks2.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;
    if (len <= 1 || coordinate == null) {
      return 0;
    }
    if (axisType === "angleAxis" && range2 != null && Math.abs(Math.abs(range2[1] - range2[0]) - 360) <= 1e-6) {
      for (var i = 0; i < len; i++) {
        var before2 = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;
        var cur = unsortedTicks[i].coordinate;
        var after2 = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;
        var sameDirectionCoord = void 0;
        if (mathSign(cur - before2) !== mathSign(after2 - cur)) {
          var diffInterval = [];
          if (mathSign(after2 - cur) === mathSign(range2[1] - range2[0])) {
            sameDirectionCoord = after2;
            var curInRange = cur + range2[1] - range2[0];
            diffInterval[0] = Math.min(curInRange, (curInRange + before2) / 2);
            diffInterval[1] = Math.max(curInRange, (curInRange + before2) / 2);
          } else {
            sameDirectionCoord = before2;
            var afterInRange = after2 + range2[1] - range2[0];
            diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);
            diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);
          }
          var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];
          if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {
            ({
              index: index2
            } = unsortedTicks[i]);
            break;
          }
        } else {
          var minValue = Math.min(before2, after2);
          var maxValue = Math.max(before2, after2);
          if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2) {
            ({
              index: index2
            } = unsortedTicks[i]);
            break;
          }
        }
      }
    } else if (ticks2) {
      for (var _i = 0; _i < len; _i++) {
        if (_i === 0 && coordinate <= (ticks2[_i].coordinate + ticks2[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks2[_i].coordinate + ticks2[_i - 1].coordinate) / 2 && coordinate <= (ticks2[_i].coordinate + ticks2[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks2[_i].coordinate + ticks2[_i - 1].coordinate) / 2) {
          ({
            index: index2
          } = ticks2[_i]);
          break;
        }
      }
    }
    return index2;
  };
  var appendOffsetOfLegend = (offset, legendSettings, legendSize) => {
    if (legendSettings && legendSize) {
      var {
        width: boxWidth,
        height: boxHeight
      } = legendSize;
      var {
        align,
        verticalAlign,
        layout
      } = legendSettings;
      if ((layout === "vertical" || layout === "horizontal" && verticalAlign === "middle") && align !== "center" && isNumber(offset[align])) {
        return _objectSpread$U(_objectSpread$U({}, offset), {}, {
          [align]: offset[align] + (boxWidth || 0)
        });
      }
      if ((layout === "horizontal" || layout === "vertical" && align === "center") && verticalAlign !== "middle" && isNumber(offset[verticalAlign])) {
        return _objectSpread$U(_objectSpread$U({}, offset), {}, {
          [verticalAlign]: offset[verticalAlign] + (boxHeight || 0)
        });
      }
    }
    return offset;
  };
  var isCategoricalAxis = (layout, axisType) => layout === "horizontal" && axisType === "xAxis" || layout === "vertical" && axisType === "yAxis" || layout === "centric" && axisType === "angleAxis" || layout === "radial" && axisType === "radiusAxis";
  var getCoordinatesOfGrid = (ticks2, minValue, maxValue, syncWithTicks) => {
    if (syncWithTicks) {
      return ticks2.map((entry) => entry.coordinate);
    }
    var hasMin, hasMax;
    var values = ticks2.map((entry) => {
      if (entry.coordinate === minValue) {
        hasMin = true;
      }
      if (entry.coordinate === maxValue) {
        hasMax = true;
      }
      return entry.coordinate;
    });
    if (!hasMin) {
      values.push(minValue);
    }
    if (!hasMax) {
      values.push(maxValue);
    }
    return values;
  };
  var getTicksOfAxis = (axis, isGrid, isAll) => {
    if (!axis) {
      return null;
    }
    var {
      duplicateDomain,
      type,
      range: range2,
      scale,
      realScaleType,
      isCategorical,
      categoricalDomain,
      tickCount,
      ticks: ticks2,
      niceTicks,
      axisType
    } = axis;
    if (!scale) {
      return null;
    }
    var offsetForBand = realScaleType === "scaleBand" && scale.bandwidth ? scale.bandwidth() / 2 : 2;
    var offset = (isGrid || isAll) && type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
    offset = axisType === "angleAxis" && range2 && range2.length >= 2 ? mathSign(range2[0] - range2[1]) * 2 * offset : offset;
    if (isGrid && (ticks2 || niceTicks)) {
      var result = (ticks2 || niceTicks || []).map((entry, index2) => {
        var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
        return {
          // If the scaleContent is not a number, the coordinate will be NaN.
          // That could be the case for example with a PointScale and a string as domain.
          coordinate: scale(scaleContent) + offset,
          value: entry,
          offset,
          index: index2
        };
      });
      return result.filter((row) => !isNan(row.coordinate));
    }
    if (isCategorical && categoricalDomain) {
      return categoricalDomain.map((entry, index2) => ({
        coordinate: scale(entry) + offset,
        value: entry,
        index: index2,
        offset
      }));
    }
    if (scale.ticks && !isAll && tickCount != null) {
      return scale.ticks(tickCount).map((entry, index2) => ({
        coordinate: scale(entry) + offset,
        value: entry,
        offset,
        index: index2
      }));
    }
    return scale.domain().map((entry, index2) => ({
      coordinate: scale(entry) + offset,
      value: duplicateDomain ? duplicateDomain[entry] : entry,
      index: index2,
      offset
    }));
  };
  var EPS = 1e-4;
  var checkDomainOfScale = (scale) => {
    var domain = scale.domain();
    if (!domain || domain.length <= 2) {
      return;
    }
    var len = domain.length;
    var range2 = scale.range();
    var minValue = Math.min(range2[0], range2[1]) - EPS;
    var maxValue = Math.max(range2[0], range2[1]) + EPS;
    var first = scale(domain[0]);
    var last2 = scale(domain[len - 1]);
    if (first < minValue || first > maxValue || last2 < minValue || last2 > maxValue) {
      scale.domain([domain[0], domain[len - 1]]);
    }
  };
  var truncateByDomain = (value, domain) => {
    if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {
      return value;
    }
    var minValue = Math.min(domain[0], domain[1]);
    var maxValue = Math.max(domain[0], domain[1]);
    var result = [value[0], value[1]];
    if (!isNumber(value[0]) || value[0] < minValue) {
      result[0] = minValue;
    }
    if (!isNumber(value[1]) || value[1] > maxValue) {
      result[1] = maxValue;
    }
    if (result[0] > maxValue) {
      result[0] = maxValue;
    }
    if (result[1] < minValue) {
      result[1] = minValue;
    }
    return result;
  };
  var offsetSign = (series) => {
    var n = series.length;
    if (n <= 0) {
      return;
    }
    for (var j = 0, m = series[0].length; j < m; ++j) {
      var positive = 0;
      var negative = 0;
      for (var i = 0; i < n; ++i) {
        var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
        if (value >= 0) {
          series[i][j][0] = positive;
          series[i][j][1] = positive + value;
          positive = series[i][j][1];
        } else {
          series[i][j][0] = negative;
          series[i][j][1] = negative + value;
          negative = series[i][j][1];
        }
      }
    }
  };
  var offsetPositive = (series) => {
    var n = series.length;
    if (n <= 0) {
      return;
    }
    for (var j = 0, m = series[0].length; j < m; ++j) {
      var positive = 0;
      for (var i = 0; i < n; ++i) {
        var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
        if (value >= 0) {
          series[i][j][0] = positive;
          series[i][j][1] = positive + value;
          positive = series[i][j][1];
        } else {
          series[i][j][0] = 0;
          series[i][j][1] = 0;
        }
      }
    }
  };
  var STACK_OFFSET_MAP = {
    sign: offsetSign,
    // @ts-expect-error definitelytyped types are incorrect
    expand: stackOffsetExpand,
    // @ts-expect-error definitelytyped types are incorrect
    none: stackOffsetNone,
    // @ts-expect-error definitelytyped types are incorrect
    silhouette: stackOffsetSilhouette,
    // @ts-expect-error definitelytyped types are incorrect
    wiggle: stackOffsetWiggle,
    positive: offsetPositive
  };
  var getStackedData = (data, dataKeys, offsetType) => {
    var offsetAccessor = STACK_OFFSET_MAP[offsetType];
    var stack = shapeStack().keys(dataKeys).value((d, key) => +getValueByDataKey(d, key, 0)).order(stackOrderNone).offset(offsetAccessor);
    return stack(data);
  };
  function getNormalizedStackId(publicStackId) {
    return publicStackId == null ? void 0 : String(publicStackId);
  }
  function getCateCoordinateOfLine(_ref2) {
    var {
      axis,
      ticks: ticks2,
      bandSize,
      entry,
      index: index2,
      dataKey
    } = _ref2;
    if (axis.type === "category") {
      if (!axis.allowDuplicatedCategory && axis.dataKey && !isNullish(entry[axis.dataKey])) {
        var matchedTick = findEntryInArray(ticks2, "value", entry[axis.dataKey]);
        if (matchedTick) {
          return matchedTick.coordinate + bandSize / 2;
        }
      }
      return ticks2[index2] ? ticks2[index2].coordinate + bandSize / 2 : null;
    }
    var value = getValueByDataKey(entry, !isNullish(dataKey) ? dataKey : axis.dataKey);
    return !isNullish(value) ? axis.scale(value) : null;
  }
  var getCateCoordinateOfBar = (_ref2) => {
    var {
      axis,
      ticks: ticks2,
      offset,
      bandSize,
      entry,
      index: index2
    } = _ref2;
    if (axis.type === "category") {
      return ticks2[index2] ? ticks2[index2].coordinate + offset : null;
    }
    var value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index2]);
    return !isNullish(value) ? axis.scale(value) - bandSize / 2 + offset : null;
  };
  var getBaseValueOfBar = (_ref3) => {
    var {
      numericAxis
    } = _ref3;
    var domain = numericAxis.scale.domain();
    if (numericAxis.type === "number") {
      var minValue = Math.min(domain[0], domain[1]);
      var maxValue = Math.max(domain[0], domain[1]);
      if (minValue <= 0 && maxValue >= 0) {
        return 0;
      }
      if (maxValue < 0) {
        return maxValue;
      }
      return minValue;
    }
    return domain[0];
  };
  var getDomainOfSingle = (data) => {
    var flat = data.flat(2).filter(isNumber);
    return [Math.min(...flat), Math.max(...flat)];
  };
  var makeDomainFinite = (domain) => {
    return [domain[0] === Infinity ? 0 : domain[0], domain[1] === -Infinity ? 0 : domain[1]];
  };
  var getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {
    if (stackGroups == null) {
      return void 0;
    }
    return makeDomainFinite(Object.keys(stackGroups).reduce((result, stackId) => {
      var group2 = stackGroups[stackId];
      var {
        stackedData
      } = group2;
      var domain = stackedData.reduce((res, entry) => {
        var sliced = getSliced(entry, startIndex, endIndex);
        var s2 = getDomainOfSingle(sliced);
        return [Math.min(res[0], s2[0]), Math.max(res[1], s2[1])];
      }, [Infinity, -Infinity]);
      return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];
    }, [Infinity, -Infinity]));
  };
  var MIN_VALUE_REG = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
  var MAX_VALUE_REG = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
  var getBandSizeOfAxis = (axis, ticks2, isBar) => {
    if (axis && axis.scale && axis.scale.bandwidth) {
      var bandWidth = axis.scale.bandwidth();
      if (!isBar || bandWidth > 0) {
        return bandWidth;
      }
    }
    if (axis && ticks2 && ticks2.length >= 2) {
      var orderedTicks = sortBy$2(ticks2, (o) => o.coordinate);
      var bandSize = Infinity;
      for (var i = 1, len = orderedTicks.length; i < len; i++) {
        var cur = orderedTicks[i];
        var prev = orderedTicks[i - 1];
        bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);
      }
      return bandSize === Infinity ? 0 : bandSize;
    }
    return isBar ? void 0 : 0;
  };
  function getTooltipEntry(_ref4) {
    var {
      tooltipEntrySettings,
      dataKey,
      payload,
      value,
      name
    } = _ref4;
    return _objectSpread$U(_objectSpread$U({}, tooltipEntrySettings), {}, {
      dataKey,
      payload,
      value,
      name
    });
  }
  function getTooltipNameProp(nameFromItem, dataKey) {
    if (nameFromItem) {
      return String(nameFromItem);
    }
    if (typeof dataKey === "string") {
      return dataKey;
    }
    return void 0;
  }
  function inRange$1(x2, y2, layout, polarViewBox, offset) {
    if (layout === "horizontal" || layout === "vertical") {
      var isInRange = x2 >= offset.left && x2 <= offset.left + offset.width && y2 >= offset.top && y2 <= offset.top + offset.height;
      return isInRange ? {
        x: x2,
        y: y2
      } : null;
    }
    if (polarViewBox) {
      return inRangeOfSector({
        x: x2,
        y: y2
      }, polarViewBox);
    }
    return null;
  }
  var getActiveCoordinate = (layout, tooltipTicks, activeIndex, rangeObj) => {
    var entry = tooltipTicks.find((tick) => tick && tick.index === activeIndex);
    if (entry) {
      if (layout === "horizontal") {
        return {
          x: entry.coordinate,
          y: rangeObj.y
        };
      }
      if (layout === "vertical") {
        return {
          x: rangeObj.x,
          y: entry.coordinate
        };
      }
      if (layout === "centric") {
        var _angle = entry.coordinate;
        var {
          radius: _radius
        } = rangeObj;
        return _objectSpread$U(_objectSpread$U(_objectSpread$U({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {
          angle: _angle,
          radius: _radius
        });
      }
      var radius = entry.coordinate;
      var {
        angle
      } = rangeObj;
      return _objectSpread$U(_objectSpread$U(_objectSpread$U({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {
        angle,
        radius
      });
    }
    return {
      x: 0,
      y: 0
    };
  };
  var calculateTooltipPos = (rangeObj, layout) => {
    if (layout === "horizontal") {
      return rangeObj.x;
    }
    if (layout === "vertical") {
      return rangeObj.y;
    }
    if (layout === "centric") {
      return rangeObj.angle;
    }
    return rangeObj.radius;
  };
  var selectChartWidth = (state) => state.layout.width;
  var selectChartHeight = (state) => state.layout.height;
  var selectContainerScale = (state) => state.layout.scale;
  var selectMargin = (state) => state.layout.margin;
  var selectAllXAxes = createSelector((state) => state.cartesianAxis.xAxis, (xAxisMap) => {
    return Object.values(xAxisMap);
  });
  var selectAllYAxes = createSelector((state) => state.cartesianAxis.yAxis, (yAxisMap) => {
    return Object.values(yAxisMap);
  });
  var COLOR_PANEL = ["#1890FF", "#66B5FF", "#41D9C7", "#2FC25B", "#6EDB8F", "#9AE65C", "#FACC14", "#E6965C", "#57AD71", "#223273", "#738AE6", "#7564CC", "#8543E0", "#A877ED", "#5C8EE6", "#13C2C2", "#70E0E0", "#5CA3E6", "#3436C7", "#8082FF", "#DD81E6", "#F04864", "#FA7D92", "#D598D9"];
  var DATA_ITEM_INDEX_ATTRIBUTE_NAME = "data-recharts-item-index";
  var DATA_ITEM_DATAKEY_ATTRIBUTE_NAME = "data-recharts-item-data-key";
  var DEFAULT_Y_AXIS_WIDTH = 60;
  function ownKeys$T(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$T(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$T(Object(t), true).forEach(function(r3) {
        _defineProperty$X(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$T(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$X(e, r2, t) {
    return (r2 = _toPropertyKey$X(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$X(t) {
    var i = _toPrimitive$X(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$X(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var selectBrushHeight = (state) => state.brush.height;
  var selectChartOffsetInternal = createSelector([selectChartWidth, selectChartHeight, selectMargin, selectBrushHeight, selectAllXAxes, selectAllYAxes, selectLegendSettings, selectLegendSize], (chartWidth, chartHeight, margin, brushHeight, xAxes, yAxes, legendSettings, legendSize) => {
    var offsetH = yAxes.reduce((result, entry) => {
      var {
        orientation
      } = entry;
      if (!entry.mirror && !entry.hide) {
        var width = typeof entry.width === "number" ? entry.width : DEFAULT_Y_AXIS_WIDTH;
        return _objectSpread$T(_objectSpread$T({}, result), {}, {
          [orientation]: result[orientation] + width
        });
      }
      return result;
    }, {
      left: margin.left || 0,
      right: margin.right || 0
    });
    var offsetV = xAxes.reduce((result, entry) => {
      var {
        orientation
      } = entry;
      if (!entry.mirror && !entry.hide) {
        return _objectSpread$T(_objectSpread$T({}, result), {}, {
          [orientation]: get$2(result, "".concat(orientation)) + entry.height
        });
      }
      return result;
    }, {
      top: margin.top || 0,
      bottom: margin.bottom || 0
    });
    var offset = _objectSpread$T(_objectSpread$T({}, offsetV), offsetH);
    var brushBottom = offset.bottom;
    offset.bottom += brushHeight;
    offset = appendOffsetOfLegend(offset, legendSettings, legendSize);
    var offsetWidth = chartWidth - offset.left - offset.right;
    var offsetHeight = chartHeight - offset.top - offset.bottom;
    return _objectSpread$T(_objectSpread$T({
      brushBottom
    }, offset), {}, {
      // never return negative values for height and width
      width: Math.max(offsetWidth, 0),
      height: Math.max(offsetHeight, 0)
    });
  });
  var selectChartViewBox = createSelector(selectChartOffsetInternal, (offset) => ({
    x: offset.left,
    y: offset.top,
    width: offset.width,
    height: offset.height
  }));
  var selectAxisViewBox = createSelector(selectChartWidth, selectChartHeight, (width, height) => ({
    x: 0,
    y: 0,
    width,
    height
  }));
  var PanoramaContext = /* @__PURE__ */ React.createContext(null);
  var useIsPanorama = () => React.useContext(PanoramaContext) != null;
  var PanoramaContextProvider = (_ref2) => {
    var {
      children
    } = _ref2;
    return /* @__PURE__ */ React__namespace.createElement(PanoramaContext.Provider, {
      value: true
    }, children);
  };
  var selectBrushSettings = (state) => state.brush;
  var selectBrushDimensions = createSelector([selectBrushSettings, selectChartOffsetInternal, selectMargin], (brushSettings, offset, margin) => ({
    height: brushSettings.height,
    x: isNumber(brushSettings.x) ? brushSettings.x : offset.left,
    y: isNumber(brushSettings.y) ? brushSettings.y : offset.top + offset.height + offset.brushBottom - ((margin === null || margin === void 0 ? void 0 : margin.bottom) || 0),
    width: isNumber(brushSettings.width) ? brushSettings.width : offset.width
  }));
  var useViewBox = () => {
    var _useAppSelector;
    var panorama = useIsPanorama();
    var rootViewBox = useAppSelector(selectChartViewBox);
    var brushDimensions = useAppSelector(selectBrushDimensions);
    var brushPadding = (_useAppSelector = useAppSelector(selectBrushSettings)) === null || _useAppSelector === void 0 ? void 0 : _useAppSelector.padding;
    if (!panorama || !brushDimensions || !brushPadding) {
      return rootViewBox;
    }
    return {
      width: brushDimensions.width - brushPadding.left - brushPadding.right,
      height: brushDimensions.height - brushPadding.top - brushPadding.bottom,
      x: brushPadding.left,
      y: brushPadding.top
    };
  };
  var manyComponentsThrowErrorsIfOffsetIsUndefined = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    width: 0,
    height: 0,
    brushBottom: 0
  };
  var useOffsetInternal = () => {
    var _useAppSelector2;
    return (_useAppSelector2 = useAppSelector(selectChartOffsetInternal)) !== null && _useAppSelector2 !== void 0 ? _useAppSelector2 : manyComponentsThrowErrorsIfOffsetIsUndefined;
  };
  var useChartWidth = () => {
    return useAppSelector(selectChartWidth);
  };
  var useChartHeight = () => {
    return useAppSelector(selectChartHeight);
  };
  var manyComponentsThrowErrorsIfMarginIsUndefined = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  var useMargin = () => {
    var _useAppSelector3;
    return (_useAppSelector3 = useAppSelector((state) => state.layout.margin)) !== null && _useAppSelector3 !== void 0 ? _useAppSelector3 : manyComponentsThrowErrorsIfMarginIsUndefined;
  };
  var selectChartLayout = (state) => state.layout.layoutType;
  var useChartLayout = () => useAppSelector(selectChartLayout);
  var ReportChartSize = (props) => {
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(setChartSize(props));
    }, [dispatch, props]);
    return null;
  };
  var ReportChartMargin = (_ref2) => {
    var {
      margin
    } = _ref2;
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(setMargin(margin));
    }, [dispatch, margin]);
    return null;
  };
  var initialState$9 = {
    settings: {
      layout: "horizontal",
      align: "center",
      verticalAlign: "middle",
      itemSorter: "value"
    },
    size: {
      width: 0,
      height: 0
    },
    payload: []
  };
  var legendSlice = createSlice({
    name: "legend",
    initialState: initialState$9,
    reducers: {
      setLegendSize(state, action) {
        state.size.width = action.payload.width;
        state.size.height = action.payload.height;
      },
      setLegendSettings(state, action) {
        state.settings.align = action.payload.align;
        state.settings.layout = action.payload.layout;
        state.settings.verticalAlign = action.payload.verticalAlign;
        state.settings.itemSorter = action.payload.itemSorter;
      },
      addLegendPayload(state, action) {
        state.payload.push(castDraft(action.payload));
      },
      removeLegendPayload(state, action) {
        var index2 = current(state).payload.indexOf(castDraft(action.payload));
        if (index2 > -1) {
          state.payload.splice(index2, 1);
        }
      }
    }
  });
  var {
    setLegendSize,
    setLegendSettings,
    addLegendPayload,
    removeLegendPayload
  } = legendSlice.actions;
  var legendReducer = legendSlice.reducer;
  var _excluded$x = ["contextPayload"];
  function _extends$H() {
    return _extends$H = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$H.apply(null, arguments);
  }
  function ownKeys$S(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$S(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$S(Object(t), true).forEach(function(r3) {
        _defineProperty$W(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$S(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$W(e, r2, t) {
    return (r2 = _toPropertyKey$W(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$W(t) {
    var i = _toPrimitive$W(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$W(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _objectWithoutProperties$x(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$x(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$x(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function defaultUniqBy$1(entry) {
    return entry.value;
  }
  function LegendContent(props) {
    var {
      contextPayload
    } = props, otherProps = _objectWithoutProperties$x(props, _excluded$x);
    var finalPayload = getUniqPayload(contextPayload, props.payloadUniqBy, defaultUniqBy$1);
    var contentProps = _objectSpread$S(_objectSpread$S({}, otherProps), {}, {
      payload: finalPayload
    });
    if (/* @__PURE__ */ React__namespace.isValidElement(props.content)) {
      return /* @__PURE__ */ React__namespace.cloneElement(props.content, contentProps);
    }
    if (typeof props.content === "function") {
      return /* @__PURE__ */ React__namespace.createElement(props.content, contentProps);
    }
    return /* @__PURE__ */ React__namespace.createElement(DefaultLegendContent, contentProps);
  }
  function getDefaultPosition(style, props, margin, chartWidth, chartHeight, box) {
    var {
      layout,
      align,
      verticalAlign
    } = props;
    var hPos, vPos;
    if (!style || (style.left === void 0 || style.left === null) && (style.right === void 0 || style.right === null)) {
      if (align === "center" && layout === "vertical") {
        hPos = {
          left: ((chartWidth || 0) - box.width) / 2
        };
      } else {
        hPos = align === "right" ? {
          right: margin && margin.right || 0
        } : {
          left: margin && margin.left || 0
        };
      }
    }
    if (!style || (style.top === void 0 || style.top === null) && (style.bottom === void 0 || style.bottom === null)) {
      if (verticalAlign === "middle") {
        vPos = {
          top: ((chartHeight || 0) - box.height) / 2
        };
      } else {
        vPos = verticalAlign === "bottom" ? {
          bottom: margin && margin.bottom || 0
        } : {
          top: margin && margin.top || 0
        };
      }
    }
    return _objectSpread$S(_objectSpread$S({}, hPos), vPos);
  }
  function LegendSettingsDispatcher(props) {
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(setLegendSettings(props));
    }, [dispatch, props]);
    return null;
  }
  function LegendSizeDispatcher(props) {
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(setLegendSize(props));
      return () => {
        dispatch(setLegendSize({
          width: 0,
          height: 0
        }));
      };
    }, [dispatch, props]);
    return null;
  }
  function LegendWrapper(props) {
    var contextPayload = useLegendPayload();
    var legendPortalFromContext = useLegendPortal();
    var margin = useMargin();
    var {
      width: widthFromProps,
      height: heightFromProps,
      wrapperStyle,
      portal: portalFromProps
    } = props;
    var [lastBoundingBox, updateBoundingBox] = useElementOffset([contextPayload]);
    var chartWidth = useChartWidth();
    var chartHeight = useChartHeight();
    var maxWidth = chartWidth - (margin.left || 0) - (margin.right || 0);
    var widthOrHeight = Legend.getWidthOrHeight(props.layout, heightFromProps, widthFromProps, maxWidth);
    var outerStyle = portalFromProps ? wrapperStyle : _objectSpread$S(_objectSpread$S({
      position: "absolute",
      width: (widthOrHeight === null || widthOrHeight === void 0 ? void 0 : widthOrHeight.width) || widthFromProps || "auto",
      height: (widthOrHeight === null || widthOrHeight === void 0 ? void 0 : widthOrHeight.height) || heightFromProps || "auto"
    }, getDefaultPosition(wrapperStyle, props, margin, chartWidth, chartHeight, lastBoundingBox)), wrapperStyle);
    var legendPortal = portalFromProps !== null && portalFromProps !== void 0 ? portalFromProps : legendPortalFromContext;
    if (legendPortal == null) {
      return null;
    }
    var legendElement = /* @__PURE__ */ React__namespace.createElement("div", {
      className: "recharts-legend-wrapper",
      style: outerStyle,
      ref: updateBoundingBox
    }, /* @__PURE__ */ React__namespace.createElement(LegendSettingsDispatcher, {
      layout: props.layout,
      align: props.align,
      verticalAlign: props.verticalAlign,
      itemSorter: props.itemSorter
    }), /* @__PURE__ */ React__namespace.createElement(LegendSizeDispatcher, {
      width: lastBoundingBox.width,
      height: lastBoundingBox.height
    }), /* @__PURE__ */ React__namespace.createElement(LegendContent, _extends$H({}, props, widthOrHeight, {
      margin,
      chartWidth,
      chartHeight,
      contextPayload
    })));
    return /* @__PURE__ */ reactDom.createPortal(legendElement, legendPortal);
  }
  class Legend extends React.PureComponent {
    static getWidthOrHeight(layout, height, width, maxWidth) {
      if (layout === "vertical" && isNumber(height)) {
        return {
          height
        };
      }
      if (layout === "horizontal") {
        return {
          width: width || maxWidth
        };
      }
      return null;
    }
    render() {
      return /* @__PURE__ */ React__namespace.createElement(LegendWrapper, this.props);
    }
  }
  _defineProperty$W(Legend, "displayName", "Legend");
  _defineProperty$W(Legend, "defaultProps", {
    align: "center",
    iconSize: 14,
    itemSorter: "value",
    layout: "horizontal",
    verticalAlign: "bottom"
  });
  function _extends$G() {
    return _extends$G = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$G.apply(null, arguments);
  }
  function ownKeys$R(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$R(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$R(Object(t), true).forEach(function(r3) {
        _defineProperty$V(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$R(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$V(e, r2, t) {
    return (r2 = _toPropertyKey$V(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$V(t) {
    var i = _toPrimitive$V(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$V(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function defaultFormatter(value) {
    return Array.isArray(value) && isNumOrStr(value[0]) && isNumOrStr(value[1]) ? value.join(" ~ ") : value;
  }
  var DefaultTooltipContent = (props) => {
    var {
      separator = " : ",
      contentStyle = {},
      itemStyle = {},
      labelStyle = {},
      payload,
      formatter,
      itemSorter,
      wrapperClassName,
      labelClassName,
      label,
      labelFormatter,
      accessibilityLayer = false
    } = props;
    var renderContent2 = () => {
      if (payload && payload.length) {
        var listStyle = {
          padding: 0,
          margin: 0
        };
        var items = (itemSorter ? sortBy$2(payload, itemSorter) : payload).map((entry, i) => {
          if (entry.type === "none") {
            return null;
          }
          var finalFormatter = entry.formatter || formatter || defaultFormatter;
          var {
            value,
            name
          } = entry;
          var finalValue = value;
          var finalName = name;
          if (finalFormatter) {
            var formatted = finalFormatter(value, name, entry, i, payload);
            if (Array.isArray(formatted)) {
              [finalValue, finalName] = formatted;
            } else if (formatted != null) {
              finalValue = formatted;
            } else {
              return null;
            }
          }
          var finalItemStyle = _objectSpread$R({
            display: "block",
            paddingTop: 4,
            paddingBottom: 4,
            color: entry.color || "#000"
          }, itemStyle);
          return (
            // eslint-disable-next-line react/no-array-index-key
            /* @__PURE__ */ React__namespace.createElement("li", {
              className: "recharts-tooltip-item",
              key: "tooltip-item-".concat(i),
              style: finalItemStyle
            }, isNumOrStr(finalName) ? /* @__PURE__ */ React__namespace.createElement("span", {
              className: "recharts-tooltip-item-name"
            }, finalName) : null, isNumOrStr(finalName) ? /* @__PURE__ */ React__namespace.createElement("span", {
              className: "recharts-tooltip-item-separator"
            }, separator) : null, /* @__PURE__ */ React__namespace.createElement("span", {
              className: "recharts-tooltip-item-value"
            }, finalValue), /* @__PURE__ */ React__namespace.createElement("span", {
              className: "recharts-tooltip-item-unit"
            }, entry.unit || ""))
          );
        });
        return /* @__PURE__ */ React__namespace.createElement("ul", {
          className: "recharts-tooltip-item-list",
          style: listStyle
        }, items);
      }
      return null;
    };
    var finalStyle = _objectSpread$R({
      margin: 0,
      padding: 10,
      backgroundColor: "#fff",
      border: "1px solid #ccc",
      whiteSpace: "nowrap"
    }, contentStyle);
    var finalLabelStyle = _objectSpread$R({
      margin: 0
    }, labelStyle);
    var hasLabel = !isNullish(label);
    var finalLabel = hasLabel ? label : "";
    var wrapperCN = clsx("recharts-default-tooltip", wrapperClassName);
    var labelCN = clsx("recharts-tooltip-label", labelClassName);
    if (hasLabel && labelFormatter && payload !== void 0 && payload !== null) {
      finalLabel = labelFormatter(label, payload);
    }
    var accessibilityAttributes = accessibilityLayer ? {
      role: "status",
      "aria-live": "assertive"
    } : {};
    return /* @__PURE__ */ React__namespace.createElement("div", _extends$G({
      className: wrapperCN,
      style: finalStyle
    }, accessibilityAttributes), /* @__PURE__ */ React__namespace.createElement("p", {
      className: labelCN,
      style: finalLabelStyle
    }, /* @__PURE__ */ React__namespace.isValidElement(finalLabel) ? finalLabel : "".concat(finalLabel)), renderContent2());
  };
  var CSS_CLASS_PREFIX = "recharts-tooltip-wrapper";
  var TOOLTIP_HIDDEN = {
    visibility: "hidden"
  };
  function getTooltipCSSClassName(_ref2) {
    var {
      coordinate,
      translateX,
      translateY
    } = _ref2;
    return clsx(CSS_CLASS_PREFIX, {
      ["".concat(CSS_CLASS_PREFIX, "-right")]: isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX >= coordinate.x,
      ["".concat(CSS_CLASS_PREFIX, "-left")]: isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX < coordinate.x,
      ["".concat(CSS_CLASS_PREFIX, "-bottom")]: isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY >= coordinate.y,
      ["".concat(CSS_CLASS_PREFIX, "-top")]: isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY < coordinate.y
    });
  }
  function getTooltipTranslateXY(_ref2) {
    var {
      allowEscapeViewBox,
      coordinate,
      key,
      offsetTopLeft,
      position: position2,
      reverseDirection,
      tooltipDimension,
      viewBox,
      viewBoxDimension
    } = _ref2;
    if (position2 && isNumber(position2[key])) {
      return position2[key];
    }
    var negative = coordinate[key] - tooltipDimension - (offsetTopLeft > 0 ? offsetTopLeft : 0);
    var positive = coordinate[key] + offsetTopLeft;
    if (allowEscapeViewBox[key]) {
      return reverseDirection[key] ? negative : positive;
    }
    var viewBoxKey = viewBox[key];
    if (viewBoxKey == null) {
      return 0;
    }
    if (reverseDirection[key]) {
      var _tooltipBoundary = negative;
      var _viewBoxBoundary = viewBoxKey;
      if (_tooltipBoundary < _viewBoxBoundary) {
        return Math.max(positive, viewBoxKey);
      }
      return Math.max(negative, viewBoxKey);
    }
    if (viewBoxDimension == null) {
      return 0;
    }
    var tooltipBoundary = positive + tooltipDimension;
    var viewBoxBoundary = viewBoxKey + viewBoxDimension;
    if (tooltipBoundary > viewBoxBoundary) {
      return Math.max(negative, viewBoxKey);
    }
    return Math.max(positive, viewBoxKey);
  }
  function getTransformStyle(_ref3) {
    var {
      translateX,
      translateY,
      useTranslate3d
    } = _ref3;
    return {
      transform: useTranslate3d ? "translate3d(".concat(translateX, "px, ").concat(translateY, "px, 0)") : "translate(".concat(translateX, "px, ").concat(translateY, "px)")
    };
  }
  function getTooltipTranslate(_ref4) {
    var {
      allowEscapeViewBox,
      coordinate,
      offsetTopLeft,
      position: position2,
      reverseDirection,
      tooltipBox,
      useTranslate3d,
      viewBox
    } = _ref4;
    var cssProperties, translateX, translateY;
    if (tooltipBox.height > 0 && tooltipBox.width > 0 && coordinate) {
      translateX = getTooltipTranslateXY({
        allowEscapeViewBox,
        coordinate,
        key: "x",
        offsetTopLeft,
        position: position2,
        reverseDirection,
        tooltipDimension: tooltipBox.width,
        viewBox,
        viewBoxDimension: viewBox.width
      });
      translateY = getTooltipTranslateXY({
        allowEscapeViewBox,
        coordinate,
        key: "y",
        offsetTopLeft,
        position: position2,
        reverseDirection,
        tooltipDimension: tooltipBox.height,
        viewBox,
        viewBoxDimension: viewBox.height
      });
      cssProperties = getTransformStyle({
        translateX,
        translateY,
        useTranslate3d
      });
    } else {
      cssProperties = TOOLTIP_HIDDEN;
    }
    return {
      cssProperties,
      cssClasses: getTooltipCSSClassName({
        translateX,
        translateY,
        coordinate
      })
    };
  }
  function ownKeys$Q(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$Q(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$Q(Object(t), true).forEach(function(r3) {
        _defineProperty$U(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$Q(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$U(e, r2, t) {
    return (r2 = _toPropertyKey$U(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$U(t) {
    var i = _toPrimitive$U(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$U(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  class TooltipBoundingBox extends React.PureComponent {
    constructor() {
      super(...arguments);
      _defineProperty$U(this, "state", {
        dismissed: false,
        dismissedAtCoordinate: {
          x: 0,
          y: 0
        }
      });
      _defineProperty$U(this, "handleKeyDown", (event) => {
        if (event.key === "Escape") {
          var _this$props$coordinat, _this$props$coordinat2, _this$props$coordinat3, _this$props$coordinat4;
          this.setState({
            dismissed: true,
            dismissedAtCoordinate: {
              x: (_this$props$coordinat = (_this$props$coordinat2 = this.props.coordinate) === null || _this$props$coordinat2 === void 0 ? void 0 : _this$props$coordinat2.x) !== null && _this$props$coordinat !== void 0 ? _this$props$coordinat : 0,
              y: (_this$props$coordinat3 = (_this$props$coordinat4 = this.props.coordinate) === null || _this$props$coordinat4 === void 0 ? void 0 : _this$props$coordinat4.y) !== null && _this$props$coordinat3 !== void 0 ? _this$props$coordinat3 : 0
            }
          });
        }
      });
    }
    componentDidMount() {
      document.addEventListener("keydown", this.handleKeyDown);
    }
    componentWillUnmount() {
      document.removeEventListener("keydown", this.handleKeyDown);
    }
    componentDidUpdate() {
      var _this$props$coordinat5, _this$props$coordinat6;
      if (!this.state.dismissed) {
        return;
      }
      if (((_this$props$coordinat5 = this.props.coordinate) === null || _this$props$coordinat5 === void 0 ? void 0 : _this$props$coordinat5.x) !== this.state.dismissedAtCoordinate.x || ((_this$props$coordinat6 = this.props.coordinate) === null || _this$props$coordinat6 === void 0 ? void 0 : _this$props$coordinat6.y) !== this.state.dismissedAtCoordinate.y) {
        this.state.dismissed = false;
      }
    }
    render() {
      var {
        active,
        allowEscapeViewBox,
        animationDuration,
        animationEasing,
        children,
        coordinate,
        hasPayload,
        isAnimationActive,
        offset,
        position: position2,
        reverseDirection,
        useTranslate3d,
        viewBox,
        wrapperStyle,
        lastBoundingBox,
        innerRef,
        hasPortalFromProps
      } = this.props;
      var {
        cssClasses,
        cssProperties
      } = getTooltipTranslate({
        allowEscapeViewBox,
        coordinate,
        offsetTopLeft: offset,
        position: position2,
        reverseDirection,
        tooltipBox: {
          height: lastBoundingBox.height,
          width: lastBoundingBox.width
        },
        useTranslate3d,
        viewBox
      });
      var positionStyles = hasPortalFromProps ? {} : _objectSpread$Q(_objectSpread$Q({
        transition: isAnimationActive && active ? "transform ".concat(animationDuration, "ms ").concat(animationEasing) : void 0
      }, cssProperties), {}, {
        pointerEvents: "none",
        visibility: !this.state.dismissed && active && hasPayload ? "visible" : "hidden",
        position: "absolute",
        top: 0,
        left: 0
      });
      var outerStyle = _objectSpread$Q(_objectSpread$Q({}, positionStyles), {}, {
        visibility: !this.state.dismissed && active && hasPayload ? "visible" : "hidden"
      }, wrapperStyle);
      return (
        // This element allow listening to the `Escape` key. See https://github.com/recharts/recharts/pull/2925
        /* @__PURE__ */ React__namespace.createElement("div", {
          // @ts-expect-error typescript library does not recognize xmlns attribute, but it's required for an HTML chunk inside SVG.
          xmlns: "http://www.w3.org/1999/xhtml",
          tabIndex: -1,
          className: cssClasses,
          style: outerStyle,
          ref: innerRef
        }, children)
      );
    }
  }
  var parseIsSsrByDefault = () => !(typeof window !== "undefined" && window.document && Boolean(window.document.createElement) && window.setTimeout);
  var Global = {
    isSsr: parseIsSsrByDefault()
  };
  var useAccessibilityLayer = () => useAppSelector((state) => state.rootProps.accessibilityLayer);
  function isWellBehavedNumber(n) {
    return Number.isFinite(n);
  }
  function isPositiveNumber(n) {
    return typeof n === "number" && n > 0 && Number.isFinite(n);
  }
  function _extends$F() {
    return _extends$F = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$F.apply(null, arguments);
  }
  function ownKeys$P(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$P(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$P(Object(t), true).forEach(function(r3) {
        _defineProperty$T(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$P(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$T(e, r2, t) {
    return (r2 = _toPropertyKey$T(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$T(t) {
    var i = _toPrimitive$T(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$T(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var CURVE_FACTORIES = {
    curveBasisClosed,
    curveBasisOpen,
    curveBasis,
    curveBumpX: bumpX,
    curveBumpY: bumpY,
    curveLinearClosed,
    curveLinear,
    curveMonotoneX: monotoneX,
    curveMonotoneY: monotoneY,
    curveNatural,
    curveStep,
    curveStepAfter: stepAfter,
    curveStepBefore: stepBefore
  };
  var defined = (p) => isWellBehavedNumber(p.x) && isWellBehavedNumber(p.y);
  var getX = (p) => p.x;
  var getY = (p) => p.y;
  var getCurveFactory = (type, layout) => {
    if (typeof type === "function") {
      return type;
    }
    var name = "curve".concat(upperFirst$1(type));
    if ((name === "curveMonotone" || name === "curveBump") && layout) {
      return CURVE_FACTORIES["".concat(name).concat(layout === "vertical" ? "Y" : "X")];
    }
    return CURVE_FACTORIES[name] || curveLinear;
  };
  var getPath$1 = (_ref2) => {
    var {
      type = "linear",
      points = [],
      baseLine,
      layout,
      connectNulls = false
    } = _ref2;
    var curveFactory = getCurveFactory(type, layout);
    var formatPoints = connectNulls ? points.filter(defined) : points;
    var lineFunction;
    if (Array.isArray(baseLine)) {
      var formatBaseLine = connectNulls ? baseLine.filter((base) => defined(base)) : baseLine;
      var areaPoints = formatPoints.map((entry, index2) => _objectSpread$P(_objectSpread$P({}, entry), {}, {
        base: formatBaseLine[index2]
      }));
      if (layout === "vertical") {
        lineFunction = shapeArea().y(getY).x1(getX).x0((d) => d.base.x);
      } else {
        lineFunction = shapeArea().x(getX).y1(getY).y0((d) => d.base.y);
      }
      lineFunction.defined(defined).curve(curveFactory);
      return lineFunction(areaPoints);
    }
    if (layout === "vertical" && isNumber(baseLine)) {
      lineFunction = shapeArea().y(getY).x1(getX).x0(baseLine);
    } else if (isNumber(baseLine)) {
      lineFunction = shapeArea().x(getX).y1(getY).y0(baseLine);
    } else {
      lineFunction = shapeLine().x(getX).y(getY);
    }
    lineFunction.defined(defined).curve(curveFactory);
    return lineFunction(formatPoints);
  };
  var Curve = (props) => {
    var {
      className,
      points,
      path: path2,
      pathRef
    } = props;
    if ((!points || !points.length) && !path2) {
      return null;
    }
    var realPath = points && points.length ? getPath$1(props) : path2;
    return /* @__PURE__ */ React__namespace.createElement("path", _extends$F({}, svgPropertiesNoEvents(props), adaptEventHandlers(props), {
      className: clsx("recharts-curve", className),
      d: realPath === null ? void 0 : realPath,
      ref: pathRef
    }));
  };
  var _excluded$w = ["x", "y", "top", "left", "width", "height", "className"];
  function _extends$E() {
    return _extends$E = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$E.apply(null, arguments);
  }
  function ownKeys$O(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$O(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$O(Object(t), true).forEach(function(r3) {
        _defineProperty$S(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$O(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$S(e, r2, t) {
    return (r2 = _toPropertyKey$S(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$S(t) {
    var i = _toPrimitive$S(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$S(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _objectWithoutProperties$w(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$w(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$w(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var getPath = (x2, y2, width, height, top, left) => {
    return "M".concat(x2, ",").concat(top, "v").concat(height, "M").concat(left, ",").concat(y2, "h").concat(width);
  };
  var Cross = (_ref2) => {
    var {
      x: x2 = 0,
      y: y2 = 0,
      top = 0,
      left = 0,
      width = 0,
      height = 0,
      className
    } = _ref2, rest2 = _objectWithoutProperties$w(_ref2, _excluded$w);
    var props = _objectSpread$O({
      x: x2,
      y: y2,
      top,
      left,
      width,
      height
    }, rest2);
    if (!isNumber(x2) || !isNumber(y2) || !isNumber(width) || !isNumber(height) || !isNumber(top) || !isNumber(left)) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement("path", _extends$E({}, filterProps(props, true), {
      className: clsx("recharts-cross", className),
      d: getPath(x2, y2, width, height, top, left)
    }));
  };
  function getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize) {
    var halfSize = tooltipAxisBandSize / 2;
    return {
      stroke: "none",
      fill: "#ccc",
      x: layout === "horizontal" ? activeCoordinate.x - halfSize : offset.left + 0.5,
      y: layout === "horizontal" ? offset.top + 0.5 : activeCoordinate.y - halfSize,
      width: layout === "horizontal" ? tooltipAxisBandSize : offset.width - 1,
      height: layout === "horizontal" ? offset.height - 1 : tooltipAxisBandSize
    };
  }
  function ownKeys$N(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$N(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$N(Object(t), true).forEach(function(r3) {
        _defineProperty$R(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$N(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$R(e, r2, t) {
    return (r2 = _toPropertyKey$R(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$R(t) {
    var i = _toPrimitive$R(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$R(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function resolveDefaultProps(realProps, defaultProps2) {
    var resolvedProps = _objectSpread$N({}, realProps);
    var dp = defaultProps2;
    var keys = Object.keys(defaultProps2);
    var withDefaults = keys.reduce((acc, key) => {
      if (acc[key] === void 0 && dp[key] !== void 0) {
        acc[key] = dp[key];
      }
      return acc;
    }, resolvedProps);
    return withDefaults;
  }
  var isEqual$4 = {};
  var isEqualWith$2 = {};
  var isPlainObject$8 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function isPlainObject2(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      const proto2 = Object.getPrototypeOf(value);
      const hasObjectPrototype = proto2 === null || proto2 === Object.prototype || Object.getPrototypeOf(proto2) === null;
      if (!hasObjectPrototype) {
        return false;
      }
      return Object.prototype.toString.call(value) === "[object Object]";
    }
    exports3.isPlainObject = isPlainObject2;
  })(isPlainObject$8);
  const isPlainObject$7 = /* @__PURE__ */ getDefaultExportFromCjs(isPlainObject$8);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const isPlainObject2 = isPlainObject$8;
    const getSymbols2 = getSymbols$2;
    const getTag2 = getTag$2;
    const tags2 = tags$1;
    const eq2 = eq$2;
    function isEqualWith2(a2, b, areValuesEqual) {
      return isEqualWithImpl2(a2, b, void 0, void 0, void 0, void 0, areValuesEqual);
    }
    function isEqualWithImpl2(a2, b, property2, aParent, bParent, stack, areValuesEqual) {
      const result = areValuesEqual(a2, b, property2, aParent, bParent, stack);
      if (result !== void 0) {
        return result;
      }
      if (typeof a2 === typeof b) {
        switch (typeof a2) {
          case "bigint":
          case "string":
          case "boolean":
          case "symbol":
          case "undefined": {
            return a2 === b;
          }
          case "number": {
            return a2 === b || Object.is(a2, b);
          }
          case "function": {
            return a2 === b;
          }
          case "object": {
            return areObjectsEqual2(a2, b, stack, areValuesEqual);
          }
        }
      }
      return areObjectsEqual2(a2, b, stack, areValuesEqual);
    }
    function areObjectsEqual2(a2, b, stack, areValuesEqual) {
      if (Object.is(a2, b)) {
        return true;
      }
      let aTag = getTag2.getTag(a2);
      let bTag = getTag2.getTag(b);
      if (aTag === tags2.argumentsTag) {
        aTag = tags2.objectTag;
      }
      if (bTag === tags2.argumentsTag) {
        bTag = tags2.objectTag;
      }
      if (aTag !== bTag) {
        return false;
      }
      switch (aTag) {
        case tags2.stringTag:
          return a2.toString() === b.toString();
        case tags2.numberTag: {
          const x2 = a2.valueOf();
          const y2 = b.valueOf();
          return eq2.eq(x2, y2);
        }
        case tags2.booleanTag:
        case tags2.dateTag:
        case tags2.symbolTag:
          return Object.is(a2.valueOf(), b.valueOf());
        case tags2.regexpTag: {
          return a2.source === b.source && a2.flags === b.flags;
        }
        case tags2.functionTag: {
          return a2 === b;
        }
      }
      stack = stack ?? /* @__PURE__ */ new Map();
      const aStack = stack.get(a2);
      const bStack = stack.get(b);
      if (aStack != null && bStack != null) {
        return aStack === b;
      }
      stack.set(a2, b);
      stack.set(b, a2);
      try {
        switch (aTag) {
          case tags2.mapTag: {
            if (a2.size !== b.size) {
              return false;
            }
            for (const [key, value] of a2.entries()) {
              if (!b.has(key) || !isEqualWithImpl2(value, b.get(key), key, a2, b, stack, areValuesEqual)) {
                return false;
              }
            }
            return true;
          }
          case tags2.setTag: {
            if (a2.size !== b.size) {
              return false;
            }
            const aValues = Array.from(a2.values());
            const bValues = Array.from(b.values());
            for (let i = 0; i < aValues.length; i++) {
              const aValue = aValues[i];
              const index2 = bValues.findIndex((bValue) => {
                return isEqualWithImpl2(aValue, bValue, void 0, a2, b, stack, areValuesEqual);
              });
              if (index2 === -1) {
                return false;
              }
              bValues.splice(index2, 1);
            }
            return true;
          }
          case tags2.arrayTag:
          case tags2.uint8ArrayTag:
          case tags2.uint8ClampedArrayTag:
          case tags2.uint16ArrayTag:
          case tags2.uint32ArrayTag:
          case tags2.bigUint64ArrayTag:
          case tags2.int8ArrayTag:
          case tags2.int16ArrayTag:
          case tags2.int32ArrayTag:
          case tags2.bigInt64ArrayTag:
          case tags2.float32ArrayTag:
          case tags2.float64ArrayTag: {
            if (typeof Buffer !== "undefined" && Buffer.isBuffer(a2) !== Buffer.isBuffer(b)) {
              return false;
            }
            if (a2.length !== b.length) {
              return false;
            }
            for (let i = 0; i < a2.length; i++) {
              if (!isEqualWithImpl2(a2[i], b[i], i, a2, b, stack, areValuesEqual)) {
                return false;
              }
            }
            return true;
          }
          case tags2.arrayBufferTag: {
            if (a2.byteLength !== b.byteLength) {
              return false;
            }
            return areObjectsEqual2(new Uint8Array(a2), new Uint8Array(b), stack, areValuesEqual);
          }
          case tags2.dataViewTag: {
            if (a2.byteLength !== b.byteLength || a2.byteOffset !== b.byteOffset) {
              return false;
            }
            return areObjectsEqual2(new Uint8Array(a2), new Uint8Array(b), stack, areValuesEqual);
          }
          case tags2.errorTag: {
            return a2.name === b.name && a2.message === b.message;
          }
          case tags2.objectTag: {
            const areEqualInstances = areObjectsEqual2(a2.constructor, b.constructor, stack, areValuesEqual) || isPlainObject2.isPlainObject(a2) && isPlainObject2.isPlainObject(b);
            if (!areEqualInstances) {
              return false;
            }
            const aKeys = [...Object.keys(a2), ...getSymbols2.getSymbols(a2)];
            const bKeys = [...Object.keys(b), ...getSymbols2.getSymbols(b)];
            if (aKeys.length !== bKeys.length) {
              return false;
            }
            for (let i = 0; i < aKeys.length; i++) {
              const propKey = aKeys[i];
              const aProp = a2[propKey];
              if (!Object.hasOwn(b, propKey)) {
                return false;
              }
              const bProp = b[propKey];
              if (!isEqualWithImpl2(aProp, bProp, propKey, a2, b, stack, areValuesEqual)) {
                return false;
              }
            }
            return true;
          }
          default: {
            return false;
          }
        }
      } finally {
        stack.delete(a2);
        stack.delete(b);
      }
    }
    exports3.isEqualWith = isEqualWith2;
  })(isEqualWith$2);
  const isEqualWith$1 = /* @__PURE__ */ getDefaultExportFromCjs(isEqualWith$2);
  var noop$5 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function noop3() {
    }
    exports3.noop = noop3;
  })(noop$5);
  const noop$4 = /* @__PURE__ */ getDefaultExportFromCjs(noop$5);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const isEqualWith2 = isEqualWith$2;
    const noop3 = noop$5;
    function isEqual2(a2, b) {
      return isEqualWith2.isEqualWith(a2, b, noop3.noop);
    }
    exports3.isEqual = isEqual2;
  })(isEqual$4);
  const isEqual$3 = /* @__PURE__ */ getDefaultExportFromCjs(isEqual$4);
  var isEqual$1 = isEqual$4.isEqual;
  const isEqual$2 = /* @__PURE__ */ getDefaultExportFromCjs(isEqual$1);
  var ACCURACY = 1e-4;
  var cubicBezierFactor = (c1, c2) => [0, 3 * c1, 3 * c2 - 6 * c1, 3 * c1 - 3 * c2 + 1];
  var evaluatePolynomial = (params, t) => params.map((param, i) => param * t ** i).reduce((pre, curr) => pre + curr);
  var cubicBezier = (c1, c2) => (t) => {
    var params = cubicBezierFactor(c1, c2);
    return evaluatePolynomial(params, t);
  };
  var derivativeCubicBezier = (c1, c2) => (t) => {
    var params = cubicBezierFactor(c1, c2);
    var newParams = [...params.map((param, i) => param * i).slice(1), 0];
    return evaluatePolynomial(newParams, t);
  };
  var configBezier = function configBezier2() {
    var x1, x2, y1, y2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1) {
      switch (args[0]) {
        case "linear":
          [x1, y1, x2, y2] = [0, 0, 1, 1];
          break;
        case "ease":
          [x1, y1, x2, y2] = [0.25, 0.1, 0.25, 1];
          break;
        case "ease-in":
          [x1, y1, x2, y2] = [0.42, 0, 1, 1];
          break;
        case "ease-out":
          [x1, y1, x2, y2] = [0.42, 0, 0.58, 1];
          break;
        case "ease-in-out":
          [x1, y1, x2, y2] = [0, 0, 0.58, 1];
          break;
        default: {
          var easing = args[0].split("(");
          if (easing[0] === "cubic-bezier" && easing[1].split(")")[0].split(",").length === 4) {
            [x1, y1, x2, y2] = easing[1].split(")")[0].split(",").map((x3) => parseFloat(x3));
          }
        }
      }
    } else if (args.length === 4) {
      [x1, y1, x2, y2] = args;
    }
    var curveX = cubicBezier(x1, x2);
    var curveY = cubicBezier(y1, y2);
    var derCurveX = derivativeCubicBezier(x1, x2);
    var rangeValue = (value) => {
      if (value > 1) {
        return 1;
      }
      if (value < 0) {
        return 0;
      }
      return value;
    };
    var bezier = (_t) => {
      var t = _t > 1 ? 1 : _t;
      var x3 = t;
      for (var i = 0; i < 8; ++i) {
        var evalT = curveX(x3) - t;
        var derVal = derCurveX(x3);
        if (Math.abs(evalT - t) < ACCURACY || derVal < ACCURACY) {
          return curveY(x3);
        }
        x3 = rangeValue(x3 - evalT / derVal);
      }
      return curveY(x3);
    };
    bezier.isStepper = false;
    return bezier;
  };
  var configSpring = function configSpring2() {
    var config2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var {
      stiff = 100,
      damping = 8,
      dt = 17
    } = config2;
    var stepper = (currX, destX, currV) => {
      var FSpring = -(currX - destX) * stiff;
      var FDamping = currV * damping;
      var newV = currV + (FSpring - FDamping) * dt / 1e3;
      var newX = currV * dt / 1e3 + currX;
      if (Math.abs(newX - destX) < ACCURACY && Math.abs(newV) < ACCURACY) {
        return [destX, 0];
      }
      return [newX, newV];
    };
    stepper.isStepper = true;
    stepper.dt = dt;
    return stepper;
  };
  var configEasing = (easing) => {
    if (typeof easing === "string") {
      switch (easing) {
        case "ease":
        case "ease-in-out":
        case "ease-out":
        case "ease-in":
        case "linear":
          return configBezier(easing);
        case "spring":
          return configSpring();
        default:
          if (easing.split("(")[0] === "cubic-bezier") {
            return configBezier(easing);
          }
      }
    }
    if (typeof easing === "function") {
      return easing;
    }
    return null;
  };
  function ownKeys$M(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$M(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$M(Object(t), true).forEach(function(r3) {
        _defineProperty$Q(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$M(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$Q(e, r2, t) {
    return (r2 = _toPropertyKey$Q(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$Q(t) {
    var i = _toPrimitive$Q(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$Q(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var getDashCase = (name) => name.replace(/([A-Z])/g, (v) => "-".concat(v.toLowerCase()));
  var getTransitionVal = (props, duration, easing) => props.map((prop) => "".concat(getDashCase(prop), " ").concat(duration, "ms ").concat(easing)).join(",");
  var getIntersectionKeys = (preObj, nextObj) => [Object.keys(preObj), Object.keys(nextObj)].reduce((a2, b) => a2.filter((c2) => b.includes(c2)));
  var mapObject = (fn, obj) => Object.keys(obj).reduce((res, key) => _objectSpread$M(_objectSpread$M({}, res), {}, {
    [key]: fn(key, obj[key])
  }), {});
  function ownKeys$L(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$L(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$L(Object(t), true).forEach(function(r3) {
        _defineProperty$P(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$L(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$P(e, r2, t) {
    return (r2 = _toPropertyKey$P(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$P(t) {
    var i = _toPrimitive$P(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$P(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var alpha = (begin, end, k2) => begin + (end - begin) * k2;
  var needContinue = (_ref2) => {
    var {
      from: from2,
      to: to2
    } = _ref2;
    return from2 !== to2;
  };
  var calStepperVals = (easing, preVals, steps) => {
    var nextStepVals = mapObject((key, val) => {
      if (needContinue(val)) {
        var [newX, newV] = easing(val.from, val.to, val.velocity);
        return _objectSpread$L(_objectSpread$L({}, val), {}, {
          from: newX,
          velocity: newV
        });
      }
      return val;
    }, preVals);
    if (steps < 1) {
      return mapObject((key, val) => {
        if (needContinue(val)) {
          return _objectSpread$L(_objectSpread$L({}, val), {}, {
            velocity: alpha(val.velocity, nextStepVals[key].velocity, steps),
            from: alpha(val.from, nextStepVals[key].from, steps)
          });
        }
        return val;
      }, preVals);
    }
    return calStepperVals(easing, nextStepVals, steps - 1);
  };
  function createStepperUpdate(from2, to2, easing, interKeys, render, timeoutController) {
    var preTime;
    var stepperStyle = interKeys.reduce((res, key) => _objectSpread$L(_objectSpread$L({}, res), {}, {
      [key]: {
        from: from2[key],
        velocity: 0,
        to: to2[key]
      }
    }), {});
    var getCurrStyle = () => mapObject((key, val) => val.from, stepperStyle);
    var shouldStopAnimation = () => !Object.values(stepperStyle).filter(needContinue).length;
    var stopAnimation = null;
    var stepperUpdate = (now2) => {
      if (!preTime) {
        preTime = now2;
      }
      var deltaTime = now2 - preTime;
      var steps = deltaTime / easing.dt;
      stepperStyle = calStepperVals(easing, stepperStyle, steps);
      render(_objectSpread$L(_objectSpread$L(_objectSpread$L({}, from2), to2), getCurrStyle()));
      preTime = now2;
      if (!shouldStopAnimation()) {
        stopAnimation = timeoutController.setTimeout(stepperUpdate);
      }
    };
    return () => {
      stopAnimation = timeoutController.setTimeout(stepperUpdate);
      return () => {
        stopAnimation();
      };
    };
  }
  function createTimingUpdate(from2, to2, easing, duration, interKeys, render, timeoutController) {
    var stopAnimation = null;
    var timingStyle = interKeys.reduce((res, key) => _objectSpread$L(_objectSpread$L({}, res), {}, {
      [key]: [from2[key], to2[key]]
    }), {});
    var beginTime;
    var timingUpdate = (now2) => {
      if (!beginTime) {
        beginTime = now2;
      }
      var t = (now2 - beginTime) / duration;
      var currStyle = mapObject((key, val) => alpha(...val, easing(t)), timingStyle);
      render(_objectSpread$L(_objectSpread$L(_objectSpread$L({}, from2), to2), currStyle));
      if (t < 1) {
        stopAnimation = timeoutController.setTimeout(timingUpdate);
      } else {
        var finalStyle = mapObject((key, val) => alpha(...val, easing(1)), timingStyle);
        render(_objectSpread$L(_objectSpread$L(_objectSpread$L({}, from2), to2), finalStyle));
      }
    };
    return () => {
      stopAnimation = timeoutController.setTimeout(timingUpdate);
      return () => {
        stopAnimation();
      };
    };
  }
  const configUpdate = (from2, to2, easing, duration, render, timeoutController) => {
    var interKeys = getIntersectionKeys(from2, to2);
    return easing.isStepper === true ? createStepperUpdate(from2, to2, easing, interKeys, render, timeoutController) : createTimingUpdate(from2, to2, easing, duration, interKeys, render, timeoutController);
  };
  function createAnimateManager(timeoutController) {
    var currStyle;
    var handleChange = () => null;
    var shouldStop = false;
    var cancelTimeout = null;
    var setStyle = (_style) => {
      if (shouldStop) {
        return;
      }
      if (Array.isArray(_style)) {
        if (!_style.length) {
          return;
        }
        var styles = _style;
        var [curr, ...restStyles] = styles;
        if (typeof curr === "number") {
          cancelTimeout = timeoutController.setTimeout(setStyle.bind(null, restStyles), curr);
          return;
        }
        setStyle(curr);
        cancelTimeout = timeoutController.setTimeout(setStyle.bind(null, restStyles));
        return;
      }
      if (typeof _style === "string") {
        currStyle = _style;
        handleChange(currStyle);
      }
      if (typeof _style === "object") {
        currStyle = _style;
        handleChange(currStyle);
      }
      if (typeof _style === "function") {
        _style();
      }
    };
    return {
      stop: () => {
        shouldStop = true;
      },
      start: (style) => {
        shouldStop = false;
        if (cancelTimeout) {
          cancelTimeout();
          cancelTimeout = null;
        }
        setStyle(style);
      },
      subscribe: (_handleChange) => {
        handleChange = _handleChange;
        return () => {
          handleChange = () => null;
        };
      },
      getTimeoutController: () => timeoutController
    };
  }
  class RequestAnimationFrameTimeoutController {
    setTimeout(callback) {
      var delay2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var startTime = performance.now();
      var requestId = null;
      var executeCallback = (now2) => {
        if (now2 - startTime >= delay2) {
          callback(now2);
        } else if (typeof requestAnimationFrame === "function") {
          requestId = requestAnimationFrame(executeCallback);
        }
      };
      requestId = requestAnimationFrame(executeCallback);
      return () => {
        cancelAnimationFrame(requestId);
      };
    }
  }
  function createDefaultAnimationManager() {
    return createAnimateManager(new RequestAnimationFrameTimeoutController());
  }
  var AnimationManagerContext = /* @__PURE__ */ React.createContext(createDefaultAnimationManager);
  function useAnimationManager(animationId, animationManagerFromProps) {
    var contextAnimationManager = React.useContext(AnimationManagerContext);
    return React.useMemo(() => animationManagerFromProps !== null && animationManagerFromProps !== void 0 ? animationManagerFromProps : contextAnimationManager(animationId), [animationId, animationManagerFromProps, contextAnimationManager]);
  }
  var _excluded$v = ["children", "begin", "duration", "attributeName", "easing", "isActive", "from", "to", "canBegin", "onAnimationEnd", "shouldReAnimate", "onAnimationReStart", "animationManager"];
  function _extends$D() {
    return _extends$D = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$D.apply(null, arguments);
  }
  function _objectWithoutProperties$v(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$v(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$v(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function ownKeys$K(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$K(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$K(Object(t), true).forEach(function(r3) {
        _defineProperty$O(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$K(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$O(e, r2, t) {
    return (r2 = _toPropertyKey$O(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$O(t) {
    var i = _toPrimitive$O(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$O(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  class AnimateImpl extends React.PureComponent {
    constructor(props, context) {
      super(props, context);
      _defineProperty$O(this, "mounted", false);
      _defineProperty$O(this, "manager", void 0);
      _defineProperty$O(this, "stopJSAnimation", null);
      _defineProperty$O(this, "unSubscribe", null);
      var {
        isActive,
        attributeName,
        from: from2,
        to: to2,
        children,
        duration,
        animationManager
      } = this.props;
      this.manager = animationManager;
      this.handleStyleChange = this.handleStyleChange.bind(this);
      this.changeStyle = this.changeStyle.bind(this);
      if (!isActive || duration <= 0) {
        this.state = {
          style: {}
        };
        if (typeof children === "function") {
          this.state = {
            style: to2
          };
        }
        return;
      }
      if (from2) {
        if (typeof children === "function") {
          this.state = {
            style: from2
          };
          return;
        }
        this.state = {
          style: attributeName ? {
            [attributeName]: from2
          } : from2
        };
      } else {
        this.state = {
          style: {}
        };
      }
    }
    componentDidMount() {
      var {
        isActive,
        canBegin
      } = this.props;
      this.mounted = true;
      if (!isActive || !canBegin) {
        return;
      }
      this.runAnimation(this.props);
    }
    componentDidUpdate(prevProps) {
      var {
        isActive,
        canBegin,
        attributeName,
        shouldReAnimate,
        to: to2,
        from: currentFrom
      } = this.props;
      var {
        style
      } = this.state;
      if (!canBegin) {
        return;
      }
      if (!isActive) {
        var newState = {
          style: attributeName ? {
            [attributeName]: to2
          } : to2
        };
        if (this.state && style) {
          if (attributeName && style[attributeName] !== to2 || !attributeName && style !== to2) {
            this.setState(newState);
          }
        }
        return;
      }
      if (isEqual$2(prevProps.to, to2) && prevProps.canBegin && prevProps.isActive) {
        return;
      }
      var isTriggered = !prevProps.canBegin || !prevProps.isActive;
      this.manager.stop();
      if (this.stopJSAnimation) {
        this.stopJSAnimation();
      }
      var from2 = isTriggered || shouldReAnimate ? currentFrom : prevProps.to;
      if (this.state && style) {
        var _newState = {
          style: attributeName ? {
            [attributeName]: from2
          } : from2
        };
        if (attributeName && style[attributeName] !== from2 || !attributeName && style !== from2) {
          this.setState(_newState);
        }
      }
      this.runAnimation(_objectSpread$K(_objectSpread$K({}, this.props), {}, {
        from: from2,
        begin: 0
      }));
    }
    componentWillUnmount() {
      this.mounted = false;
      var {
        onAnimationEnd
      } = this.props;
      if (this.unSubscribe) {
        this.unSubscribe();
      }
      this.manager.stop();
      if (this.stopJSAnimation) {
        this.stopJSAnimation();
      }
      if (onAnimationEnd) {
        onAnimationEnd();
      }
    }
    handleStyleChange(style) {
      this.changeStyle(style);
    }
    changeStyle(style) {
      if (this.mounted) {
        this.setState({
          style
        });
      }
    }
    runJSAnimation(props) {
      var {
        from: from2,
        to: to2,
        duration,
        easing,
        begin,
        onAnimationEnd,
        onAnimationStart
      } = props;
      var startAnimation = configUpdate(from2, to2, configEasing(easing), duration, this.changeStyle, this.manager.getTimeoutController());
      var finalStartAnimation = () => {
        this.stopJSAnimation = startAnimation();
      };
      this.manager.start([onAnimationStart, begin, finalStartAnimation, duration, onAnimationEnd]);
    }
    runAnimation(props) {
      var {
        begin,
        duration,
        attributeName,
        to: propsTo,
        easing,
        onAnimationStart,
        onAnimationEnd,
        children
      } = props;
      this.unSubscribe = this.manager.subscribe(this.handleStyleChange);
      if (typeof easing === "function" || typeof children === "function" || easing === "spring") {
        this.runJSAnimation(props);
        return;
      }
      var to2 = attributeName ? {
        [attributeName]: propsTo
      } : propsTo;
      var transition = getTransitionVal(Object.keys(to2), duration, easing);
      this.manager.start([onAnimationStart, begin, _objectSpread$K(_objectSpread$K({}, to2), {}, {
        transition
      }), duration, onAnimationEnd]);
    }
    render() {
      var _this$props = this.props, {
        children,
        begin,
        duration,
        attributeName,
        easing,
        isActive,
        from: from2,
        to: to2,
        canBegin,
        onAnimationEnd,
        shouldReAnimate,
        onAnimationReStart,
        animationManager
      } = _this$props, others = _objectWithoutProperties$v(_this$props, _excluded$v);
      var count2 = React.Children.count(children);
      var stateStyle = this.state.style;
      if (typeof children === "function") {
        return children(stateStyle);
      }
      if (!isActive || count2 === 0 || duration <= 0) {
        return children;
      }
      var cloneContainer = (container) => {
        var {
          style = {},
          className
        } = container.props;
        var res = /* @__PURE__ */ React.cloneElement(container, _objectSpread$K(_objectSpread$K({}, others), {}, {
          style: _objectSpread$K(_objectSpread$K({}, style), stateStyle),
          className
        }));
        return res;
      };
      if (count2 === 1) {
        return cloneContainer(React.Children.only(children));
      }
      return /* @__PURE__ */ React__namespace.createElement("div", null, React.Children.map(children, (child) => cloneContainer(child)));
    }
  }
  _defineProperty$O(AnimateImpl, "displayName", "Animate");
  _defineProperty$O(AnimateImpl, "defaultProps", {
    begin: 0,
    duration: 1e3,
    attributeName: "",
    easing: "ease",
    isActive: true,
    canBegin: true,
    onAnimationEnd: () => {
    },
    onAnimationStart: () => {
    }
  });
  function Animate(props) {
    var _props$attributeName;
    var animationManager = useAnimationManager((_props$attributeName = props.attributeName) !== null && _props$attributeName !== void 0 ? _props$attributeName : Object.keys(props.to).join(","), props.animationManager);
    return /* @__PURE__ */ React__namespace.createElement(AnimateImpl, _extends$D({}, props, {
      animationManager
    }));
  }
  function _extends$C() {
    return _extends$C = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$C.apply(null, arguments);
  }
  var getRectanglePath = (x2, y2, width, height, radius) => {
    var maxRadius = Math.min(Math.abs(width) / 2, Math.abs(height) / 2);
    var ySign = height >= 0 ? 1 : -1;
    var xSign = width >= 0 ? 1 : -1;
    var clockWise = height >= 0 && width >= 0 || height < 0 && width < 0 ? 1 : 0;
    var path2;
    if (maxRadius > 0 && radius instanceof Array) {
      var newRadius = [0, 0, 0, 0];
      for (var i = 0, len = 4; i < len; i++) {
        newRadius[i] = radius[i] > maxRadius ? maxRadius : radius[i];
      }
      path2 = "M".concat(x2, ",").concat(y2 + ySign * newRadius[0]);
      if (newRadius[0] > 0) {
        path2 += "A ".concat(newRadius[0], ",").concat(newRadius[0], ",0,0,").concat(clockWise, ",").concat(x2 + xSign * newRadius[0], ",").concat(y2);
      }
      path2 += "L ".concat(x2 + width - xSign * newRadius[1], ",").concat(y2);
      if (newRadius[1] > 0) {
        path2 += "A ".concat(newRadius[1], ",").concat(newRadius[1], ",0,0,").concat(clockWise, ",\n        ").concat(x2 + width, ",").concat(y2 + ySign * newRadius[1]);
      }
      path2 += "L ".concat(x2 + width, ",").concat(y2 + height - ySign * newRadius[2]);
      if (newRadius[2] > 0) {
        path2 += "A ".concat(newRadius[2], ",").concat(newRadius[2], ",0,0,").concat(clockWise, ",\n        ").concat(x2 + width - xSign * newRadius[2], ",").concat(y2 + height);
      }
      path2 += "L ".concat(x2 + xSign * newRadius[3], ",").concat(y2 + height);
      if (newRadius[3] > 0) {
        path2 += "A ".concat(newRadius[3], ",").concat(newRadius[3], ",0,0,").concat(clockWise, ",\n        ").concat(x2, ",").concat(y2 + height - ySign * newRadius[3]);
      }
      path2 += "Z";
    } else if (maxRadius > 0 && radius === +radius && radius > 0) {
      var _newRadius = Math.min(maxRadius, radius);
      path2 = "M ".concat(x2, ",").concat(y2 + ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + xSign * _newRadius, ",").concat(y2, "\n            L ").concat(x2 + width - xSign * _newRadius, ",").concat(y2, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + width, ",").concat(y2 + ySign * _newRadius, "\n            L ").concat(x2 + width, ",").concat(y2 + height - ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + width - xSign * _newRadius, ",").concat(y2 + height, "\n            L ").concat(x2 + xSign * _newRadius, ",").concat(y2 + height, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2, ",").concat(y2 + height - ySign * _newRadius, " Z");
    } else {
      path2 = "M ".concat(x2, ",").concat(y2, " h ").concat(width, " v ").concat(height, " h ").concat(-width, " Z");
    }
    return path2;
  };
  var defaultProps$9 = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    // The radius of border
    // The radius of four corners when radius is a number
    // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array
    radius: 0,
    isAnimationActive: false,
    isUpdateAnimationActive: false,
    animationBegin: 0,
    animationDuration: 1500,
    animationEasing: "ease"
  };
  var Rectangle = (rectangleProps) => {
    var props = resolveDefaultProps(rectangleProps, defaultProps$9);
    var pathRef = React.useRef(null);
    var [totalLength, setTotalLength] = React.useState(-1);
    React.useEffect(() => {
      if (pathRef.current && pathRef.current.getTotalLength) {
        try {
          var pathTotalLength = pathRef.current.getTotalLength();
          if (pathTotalLength) {
            setTotalLength(pathTotalLength);
          }
        } catch (_unused) {
        }
      }
    }, []);
    var {
      x: x2,
      y: y2,
      width,
      height,
      radius,
      className
    } = props;
    var {
      animationEasing,
      animationDuration,
      animationBegin,
      isAnimationActive,
      isUpdateAnimationActive
    } = props;
    if (x2 !== +x2 || y2 !== +y2 || width !== +width || height !== +height || width === 0 || height === 0) {
      return null;
    }
    var layerClass = clsx("recharts-rectangle", className);
    if (!isUpdateAnimationActive) {
      return /* @__PURE__ */ React__namespace.createElement("path", _extends$C({}, filterProps(props, true), {
        className: layerClass,
        d: getRectanglePath(x2, y2, width, height, radius)
      }));
    }
    return /* @__PURE__ */ React__namespace.createElement(Animate, {
      canBegin: totalLength > 0,
      from: {
        width,
        height,
        x: x2,
        y: y2
      },
      to: {
        width,
        height,
        x: x2,
        y: y2
      },
      duration: animationDuration,
      animationEasing,
      isActive: isUpdateAnimationActive
    }, (_ref2) => {
      var {
        width: currWidth,
        height: currHeight,
        x: currX,
        y: currY
      } = _ref2;
      return /* @__PURE__ */ React__namespace.createElement(Animate, {
        canBegin: totalLength > 0,
        from: "0px ".concat(totalLength === -1 ? 1 : totalLength, "px"),
        to: "".concat(totalLength, "px 0px"),
        attributeName: "strokeDasharray",
        begin: animationBegin,
        duration: animationDuration,
        isActive: isAnimationActive,
        easing: animationEasing
      }, /* @__PURE__ */ React__namespace.createElement("path", _extends$C({}, filterProps(props, true), {
        className: layerClass,
        d: getRectanglePath(currX, currY, currWidth, currHeight, radius),
        ref: pathRef
      })));
    });
  };
  function getRadialCursorPoints(activeCoordinate) {
    var {
      cx,
      cy,
      radius,
      startAngle,
      endAngle
    } = activeCoordinate;
    var startPoint = polarToCartesian(cx, cy, radius, startAngle);
    var endPoint = polarToCartesian(cx, cy, radius, endAngle);
    return {
      points: [startPoint, endPoint],
      cx,
      cy,
      radius,
      startAngle,
      endAngle
    };
  }
  function _extends$B() {
    return _extends$B = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$B.apply(null, arguments);
  }
  var getDeltaAngle$1 = (startAngle, endAngle) => {
    var sign2 = mathSign(endAngle - startAngle);
    var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 359.999);
    return sign2 * deltaAngle;
  };
  var getTangentCircle = (_ref2) => {
    var {
      cx,
      cy,
      radius,
      angle,
      sign: sign2,
      isExternal,
      cornerRadius,
      cornerIsExternal
    } = _ref2;
    var centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;
    var theta = Math.asin(cornerRadius / centerRadius) / RADIAN$1;
    var centerAngle = cornerIsExternal ? angle : angle + sign2 * theta;
    var center = polarToCartesian(cx, cy, centerRadius, centerAngle);
    var circleTangency = polarToCartesian(cx, cy, radius, centerAngle);
    var lineTangencyAngle = cornerIsExternal ? angle - sign2 * theta : angle;
    var lineTangency = polarToCartesian(cx, cy, centerRadius * Math.cos(theta * RADIAN$1), lineTangencyAngle);
    return {
      center,
      circleTangency,
      lineTangency,
      theta
    };
  };
  var getSectorPath = (_ref2) => {
    var {
      cx,
      cy,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    } = _ref2;
    var angle = getDeltaAngle$1(startAngle, endAngle);
    var tempEndAngle = startAngle + angle;
    var outerStartPoint = polarToCartesian(cx, cy, outerRadius, startAngle);
    var outerEndPoint = polarToCartesian(cx, cy, outerRadius, tempEndAngle);
    var path2 = "M ".concat(outerStartPoint.x, ",").concat(outerStartPoint.y, "\n    A ").concat(outerRadius, ",").concat(outerRadius, ",0,\n    ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle > tempEndAngle), ",\n    ").concat(outerEndPoint.x, ",").concat(outerEndPoint.y, "\n  ");
    if (innerRadius > 0) {
      var innerStartPoint = polarToCartesian(cx, cy, innerRadius, startAngle);
      var innerEndPoint = polarToCartesian(cx, cy, innerRadius, tempEndAngle);
      path2 += "L ".concat(innerEndPoint.x, ",").concat(innerEndPoint.y, "\n            A ").concat(innerRadius, ",").concat(innerRadius, ",0,\n            ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle <= tempEndAngle), ",\n            ").concat(innerStartPoint.x, ",").concat(innerStartPoint.y, " Z");
    } else {
      path2 += "L ".concat(cx, ",").concat(cy, " Z");
    }
    return path2;
  };
  var getSectorWithCorner = (_ref3) => {
    var {
      cx,
      cy,
      innerRadius,
      outerRadius,
      cornerRadius,
      forceCornerRadius,
      cornerIsExternal,
      startAngle,
      endAngle
    } = _ref3;
    var sign2 = mathSign(endAngle - startAngle);
    var {
      circleTangency: soct,
      lineTangency: solt,
      theta: sot
    } = getTangentCircle({
      cx,
      cy,
      radius: outerRadius,
      angle: startAngle,
      sign: sign2,
      cornerRadius,
      cornerIsExternal
    });
    var {
      circleTangency: eoct,
      lineTangency: eolt,
      theta: eot
    } = getTangentCircle({
      cx,
      cy,
      radius: outerRadius,
      angle: endAngle,
      sign: -sign2,
      cornerRadius,
      cornerIsExternal
    });
    var outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;
    if (outerArcAngle < 0) {
      if (forceCornerRadius) {
        return "M ".concat(solt.x, ",").concat(solt.y, "\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(cornerRadius * 2, ",0\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(-cornerRadius * 2, ",0\n      ");
      }
      return getSectorPath({
        cx,
        cy,
        innerRadius,
        outerRadius,
        startAngle,
        endAngle
      });
    }
    var path2 = "M ".concat(solt.x, ",").concat(solt.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(soct.x, ",").concat(soct.y, "\n    A").concat(outerRadius, ",").concat(outerRadius, ",0,").concat(+(outerArcAngle > 180), ",").concat(+(sign2 < 0), ",").concat(eoct.x, ",").concat(eoct.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(eolt.x, ",").concat(eolt.y, "\n  ");
    if (innerRadius > 0) {
      var {
        circleTangency: sict,
        lineTangency: silt,
        theta: sit
      } = getTangentCircle({
        cx,
        cy,
        radius: innerRadius,
        angle: startAngle,
        sign: sign2,
        isExternal: true,
        cornerRadius,
        cornerIsExternal
      });
      var {
        circleTangency: eict,
        lineTangency: eilt,
        theta: eit
      } = getTangentCircle({
        cx,
        cy,
        radius: innerRadius,
        angle: endAngle,
        sign: -sign2,
        isExternal: true,
        cornerRadius,
        cornerIsExternal
      });
      var innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;
      if (innerArcAngle < 0 && cornerRadius === 0) {
        return "".concat(path2, "L").concat(cx, ",").concat(cy, "Z");
      }
      path2 += "L".concat(eilt.x, ",").concat(eilt.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(eict.x, ",").concat(eict.y, "\n      A").concat(innerRadius, ",").concat(innerRadius, ",0,").concat(+(innerArcAngle > 180), ",").concat(+(sign2 > 0), ",").concat(sict.x, ",").concat(sict.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(silt.x, ",").concat(silt.y, "Z");
    } else {
      path2 += "L".concat(cx, ",").concat(cy, "Z");
    }
    return path2;
  };
  var defaultProps$8 = {
    cx: 0,
    cy: 0,
    innerRadius: 0,
    outerRadius: 0,
    startAngle: 0,
    endAngle: 0,
    cornerRadius: 0,
    forceCornerRadius: false,
    cornerIsExternal: false
  };
  var Sector = (sectorProps) => {
    var props = resolveDefaultProps(sectorProps, defaultProps$8);
    var {
      cx,
      cy,
      innerRadius,
      outerRadius,
      cornerRadius,
      forceCornerRadius,
      cornerIsExternal,
      startAngle,
      endAngle,
      className
    } = props;
    if (outerRadius < innerRadius || startAngle === endAngle) {
      return null;
    }
    var layerClass = clsx("recharts-sector", className);
    var deltaRadius = outerRadius - innerRadius;
    var cr = getPercentValue(cornerRadius, deltaRadius, 0, true);
    var path2;
    if (cr > 0 && Math.abs(startAngle - endAngle) < 360) {
      path2 = getSectorWithCorner({
        cx,
        cy,
        innerRadius,
        outerRadius,
        cornerRadius: Math.min(cr, deltaRadius / 2),
        forceCornerRadius,
        cornerIsExternal,
        startAngle,
        endAngle
      });
    } else {
      path2 = getSectorPath({
        cx,
        cy,
        innerRadius,
        outerRadius,
        startAngle,
        endAngle
      });
    }
    return /* @__PURE__ */ React__namespace.createElement("path", _extends$B({}, filterProps(props, true), {
      className: layerClass,
      d: path2
    }));
  };
  function getCursorPoints(layout, activeCoordinate, offset) {
    var x1, y1, x2, y2;
    if (layout === "horizontal") {
      x1 = activeCoordinate.x;
      x2 = x1;
      y1 = offset.top;
      y2 = offset.top + offset.height;
    } else if (layout === "vertical") {
      y1 = activeCoordinate.y;
      y2 = y1;
      x1 = offset.left;
      x2 = offset.left + offset.width;
    } else if (activeCoordinate.cx != null && activeCoordinate.cy != null) {
      if (layout === "centric") {
        var {
          cx,
          cy,
          innerRadius,
          outerRadius,
          angle
        } = activeCoordinate;
        var innerPoint = polarToCartesian(cx, cy, innerRadius, angle);
        var outerPoint = polarToCartesian(cx, cy, outerRadius, angle);
        x1 = innerPoint.x;
        y1 = innerPoint.y;
        x2 = outerPoint.x;
        y2 = outerPoint.y;
      } else {
        return getRadialCursorPoints(activeCoordinate);
      }
    }
    return [{
      x: x1,
      y: y1
    }, {
      x: x2,
      y: y2
    }];
  }
  var range$6 = {};
  var toFinite$2 = {};
  var toNumber$2 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const isSymbol2 = isSymbol$3;
    function toNumber2(value) {
      if (isSymbol2.isSymbol(value)) {
        return NaN;
      }
      return Number(value);
    }
    exports3.toNumber = toNumber2;
  })(toNumber$2);
  const toNumber$1 = /* @__PURE__ */ getDefaultExportFromCjs(toNumber$2);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const toNumber2 = toNumber$2;
    function toFinite2(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber2.toNumber(value);
      if (value === Infinity || value === -Infinity) {
        const sign2 = value < 0 ? -1 : 1;
        return sign2 * Number.MAX_VALUE;
      }
      return value === value ? value : 0;
    }
    exports3.toFinite = toFinite2;
  })(toFinite$2);
  const toFinite$1 = /* @__PURE__ */ getDefaultExportFromCjs(toFinite$2);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const isIterateeCall2 = isIterateeCall$1;
    const toFinite2 = toFinite$2;
    function range2(start, end, step) {
      if (step && typeof step !== "number" && isIterateeCall2.isIterateeCall(start, end, step)) {
        end = step = void 0;
      }
      start = toFinite2.toFinite(start);
      if (end === void 0) {
        end = start;
        start = 0;
      } else {
        end = toFinite2.toFinite(end);
      }
      step = step === void 0 ? start < end ? 1 : -1 : toFinite2.toFinite(step);
      const length2 = Math.max(Math.ceil((end - start) / (step || 1)), 0);
      const result = new Array(length2);
      for (let index2 = 0; index2 < length2; index2++) {
        result[index2] = start;
        start += step;
      }
      return result;
    }
    exports3.range = range2;
  })(range$6);
  const range$5 = /* @__PURE__ */ getDefaultExportFromCjs(range$6);
  var range$3 = range$6.range;
  const range$4 = /* @__PURE__ */ getDefaultExportFromCjs(range$3);
  function ascending(a2, b) {
    return a2 == null || b == null ? NaN : a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
  }
  function descending(a2, b) {
    return a2 == null || b == null ? NaN : b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
  }
  function bisector(f) {
    let compare1, compare2, delta;
    if (f.length !== 2) {
      compare1 = ascending;
      compare2 = (d, x2) => ascending(f(d), x2);
      delta = (d, x2) => f(d) - x2;
    } else {
      compare1 = f === ascending || f === descending ? f : zero$1;
      compare2 = f;
      delta = f;
    }
    function left(a2, x2, lo = 0, hi = a2.length) {
      if (lo < hi) {
        if (compare1(x2, x2) !== 0) return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a2[mid], x2) < 0) lo = mid + 1;
          else hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function right(a2, x2, lo = 0, hi = a2.length) {
      if (lo < hi) {
        if (compare1(x2, x2) !== 0) return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a2[mid], x2) <= 0) lo = mid + 1;
          else hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function center(a2, x2, lo = 0, hi = a2.length) {
      const i = left(a2, x2, lo, hi - 1);
      return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
    }
    return { left, center, right };
  }
  function zero$1() {
    return 0;
  }
  function number$2(x2) {
    return x2 === null ? NaN : +x2;
  }
  function* numbers(values, valueof) {
    if (valueof === void 0) {
      for (let value of values) {
        if (value != null && (value = +value) >= value) {
          yield value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (value = +value) >= value) {
          yield value;
        }
      }
    }
  }
  const ascendingBisect = bisector(ascending);
  const bisectRight = ascendingBisect.right;
  const bisectLeft = ascendingBisect.left;
  const bisectCenter = bisector(number$2).center;
  function blur(values, r2) {
    if (!((r2 = +r2) >= 0)) throw new RangeError("invalid r");
    let length2 = values.length;
    if (!((length2 = Math.floor(length2)) >= 0)) throw new RangeError("invalid length");
    if (!length2 || !r2) return values;
    const blur3 = blurf(r2);
    const temp = values.slice();
    blur3(values, temp, 0, length2, 1);
    blur3(temp, values, 0, length2, 1);
    blur3(values, temp, 0, length2, 1);
    return values;
  }
  const blur2 = Blur2(blurf);
  const blurImage = Blur2(blurfImage);
  function Blur2(blur3) {
    return function(data, rx, ry = rx) {
      if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
      if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
      let { data: values, width, height } = data;
      if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
      if (!((height = Math.floor(height !== void 0 ? height : values.length / width)) >= 0)) throw new RangeError("invalid height");
      if (!width || !height || !rx && !ry) return data;
      const blurx = rx && blur3(rx);
      const blury = ry && blur3(ry);
      const temp = values.slice();
      if (blurx && blury) {
        blurh(blurx, temp, values, width, height);
        blurh(blurx, values, temp, width, height);
        blurh(blurx, temp, values, width, height);
        blurv(blury, values, temp, width, height);
        blurv(blury, temp, values, width, height);
        blurv(blury, values, temp, width, height);
      } else if (blurx) {
        blurh(blurx, values, temp, width, height);
        blurh(blurx, temp, values, width, height);
        blurh(blurx, values, temp, width, height);
      } else if (blury) {
        blurv(blury, values, temp, width, height);
        blurv(blury, temp, values, width, height);
        blurv(blury, values, temp, width, height);
      }
      return data;
    };
  }
  function blurh(blur3, T, S, w, h) {
    for (let y2 = 0, n = w * h; y2 < n; ) {
      blur3(T, S, y2, y2 += w, 1);
    }
  }
  function blurv(blur3, T, S, w, h) {
    for (let x2 = 0, n = w * h; x2 < w; ++x2) {
      blur3(T, S, x2, x2 + n, w);
    }
  }
  function blurfImage(radius) {
    const blur3 = blurf(radius);
    return (T, S, start, stop, step) => {
      start <<= 2, stop <<= 2, step <<= 2;
      blur3(T, S, start + 0, stop + 0, step);
      blur3(T, S, start + 1, stop + 1, step);
      blur3(T, S, start + 2, stop + 2, step);
      blur3(T, S, start + 3, stop + 3, step);
    };
  }
  function blurf(radius) {
    const radius0 = Math.floor(radius);
    if (radius0 === radius) return bluri(radius);
    const t = radius - radius0;
    const w = 2 * radius + 1;
    return (T, S, start, stop, step) => {
      if (!((stop -= step) >= start)) return;
      let sum2 = radius0 * S[start];
      const s0 = step * radius0;
      const s1 = s0 + step;
      for (let i = start, j = start + s0; i < j; i += step) {
        sum2 += S[Math.min(stop, i)];
      }
      for (let i = start, j = stop; i <= j; i += step) {
        sum2 += S[Math.min(stop, i + s0)];
        T[i] = (sum2 + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;
        sum2 -= S[Math.max(start, i - s0)];
      }
    };
  }
  function bluri(radius) {
    const w = 2 * radius + 1;
    return (T, S, start, stop, step) => {
      if (!((stop -= step) >= start)) return;
      let sum2 = radius * S[start];
      const s2 = step * radius;
      for (let i = start, j = start + s2; i < j; i += step) {
        sum2 += S[Math.min(stop, i)];
      }
      for (let i = start, j = stop; i <= j; i += step) {
        sum2 += S[Math.min(stop, i + s2)];
        T[i] = sum2 / w;
        sum2 -= S[Math.max(start, i - s2)];
      }
    };
  }
  function count(values, valueof) {
    let count2 = 0;
    if (valueof === void 0) {
      for (let value of values) {
        if (value != null && (value = +value) >= value) {
          ++count2;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (value = +value) >= value) {
          ++count2;
        }
      }
    }
    return count2;
  }
  function length$1(array2) {
    return array2.length | 0;
  }
  function empty(length2) {
    return !(length2 > 0);
  }
  function arrayify(values) {
    return typeof values !== "object" || "length" in values ? values : Array.from(values);
  }
  function reducer(reduce2) {
    return (values) => reduce2(...values);
  }
  function cross(...values) {
    const reduce2 = typeof values[values.length - 1] === "function" && reducer(values.pop());
    values = values.map(arrayify);
    const lengths = values.map(length$1);
    const j = values.length - 1;
    const index2 = new Array(j + 1).fill(0);
    const product = [];
    if (j < 0 || lengths.some(empty)) return product;
    while (true) {
      product.push(index2.map((j2, i2) => values[i2][j2]));
      let i = j;
      while (++index2[i] === lengths[i]) {
        if (i === 0) return reduce2 ? product.map(reduce2) : product;
        index2[i--] = 0;
      }
    }
  }
  function cumsum(values, valueof) {
    var sum2 = 0, index2 = 0;
    return Float64Array.from(values, valueof === void 0 ? (v) => sum2 += +v || 0 : (v) => sum2 += +valueof(v, index2++, values) || 0);
  }
  function variance(values, valueof) {
    let count2 = 0;
    let delta;
    let mean2 = 0;
    let sum2 = 0;
    if (valueof === void 0) {
      for (let value of values) {
        if (value != null && (value = +value) >= value) {
          delta = value - mean2;
          mean2 += delta / ++count2;
          sum2 += delta * (value - mean2);
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (value = +value) >= value) {
          delta = value - mean2;
          mean2 += delta / ++count2;
          sum2 += delta * (value - mean2);
        }
      }
    }
    if (count2 > 1) return sum2 / (count2 - 1);
  }
  function deviation(values, valueof) {
    const v = variance(values, valueof);
    return v ? Math.sqrt(v) : v;
  }
  function extent(values, valueof) {
    let min2;
    let max2;
    if (valueof === void 0) {
      for (const value of values) {
        if (value != null) {
          if (min2 === void 0) {
            if (value >= value) min2 = max2 = value;
          } else {
            if (min2 > value) min2 = value;
            if (max2 < value) max2 = value;
          }
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null) {
          if (min2 === void 0) {
            if (value >= value) min2 = max2 = value;
          } else {
            if (min2 > value) min2 = value;
            if (max2 < value) max2 = value;
          }
        }
      }
    }
    return [min2, max2];
  }
  class Adder {
    constructor() {
      this._partials = new Float64Array(32);
      this._n = 0;
    }
    add(x2) {
      const p = this._partials;
      let i = 0;
      for (let j = 0; j < this._n && j < 32; j++) {
        const y2 = p[j], hi = x2 + y2, lo = Math.abs(x2) < Math.abs(y2) ? x2 - (hi - y2) : y2 - (hi - x2);
        if (lo) p[i++] = lo;
        x2 = hi;
      }
      p[i] = x2;
      this._n = i + 1;
      return this;
    }
    valueOf() {
      const p = this._partials;
      let n = this._n, x2, y2, lo, hi = 0;
      if (n > 0) {
        hi = p[--n];
        while (n > 0) {
          x2 = hi;
          y2 = p[--n];
          hi = x2 + y2;
          lo = y2 - (hi - x2);
          if (lo) break;
        }
        if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
          y2 = lo * 2;
          x2 = hi + y2;
          if (y2 == x2 - hi) hi = x2;
        }
      }
      return hi;
    }
  }
  function fsum(values, valueof) {
    const adder = new Adder();
    if (valueof === void 0) {
      for (let value of values) {
        if (value = +value) {
          adder.add(value);
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if (value = +valueof(value, ++index2, values)) {
          adder.add(value);
        }
      }
    }
    return +adder;
  }
  function fcumsum(values, valueof) {
    const adder = new Adder();
    let index2 = -1;
    return Float64Array.from(
      values,
      valueof === void 0 ? (v) => adder.add(+v || 0) : (v) => adder.add(+valueof(v, ++index2, values) || 0)
    );
  }
  class InternMap extends Map {
    constructor(entries, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
    }
    get(key) {
      return super.get(intern_get(this, key));
    }
    has(key) {
      return super.has(intern_get(this, key));
    }
    set(key, value) {
      return super.set(intern_set(this, key), value);
    }
    delete(key) {
      return super.delete(intern_delete(this, key));
    }
  }
  class InternSet extends Set {
    constructor(values, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (values != null) for (const value of values) this.add(value);
    }
    has(value) {
      return super.has(intern_get(this, value));
    }
    add(value) {
      return super.add(intern_set(this, value));
    }
    delete(value) {
      return super.delete(intern_delete(this, value));
    }
  }
  function intern_get({ _intern, _key }, value) {
    const key = _key(value);
    return _intern.has(key) ? _intern.get(key) : value;
  }
  function intern_set({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) return _intern.get(key);
    _intern.set(key, value);
    return value;
  }
  function intern_delete({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) {
      value = _intern.get(key);
      _intern.delete(key);
    }
    return value;
  }
  function keyof(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }
  function identity$6(x2) {
    return x2;
  }
  function group(values, ...keys) {
    return nest(values, identity$6, identity$6, keys);
  }
  function groups(values, ...keys) {
    return nest(values, Array.from, identity$6, keys);
  }
  function flatten$2(groups2, keys) {
    for (let i = 1, n = keys.length; i < n; ++i) {
      groups2 = groups2.flatMap((g) => g.pop().map(([key, value]) => [...g, key, value]));
    }
    return groups2;
  }
  function flatGroup(values, ...keys) {
    return flatten$2(groups(values, ...keys), keys);
  }
  function flatRollup(values, reduce2, ...keys) {
    return flatten$2(rollups(values, reduce2, ...keys), keys);
  }
  function rollup(values, reduce2, ...keys) {
    return nest(values, identity$6, reduce2, keys);
  }
  function rollups(values, reduce2, ...keys) {
    return nest(values, Array.from, reduce2, keys);
  }
  function index(values, ...keys) {
    return nest(values, identity$6, unique, keys);
  }
  function indexes(values, ...keys) {
    return nest(values, Array.from, unique, keys);
  }
  function unique(values) {
    if (values.length !== 1) throw new Error("duplicate key");
    return values[0];
  }
  function nest(values, map2, reduce2, keys) {
    return function regroup(values2, i) {
      if (i >= keys.length) return reduce2(values2);
      const groups2 = new InternMap();
      const keyof2 = keys[i++];
      let index2 = -1;
      for (const value of values2) {
        const key = keyof2(value, ++index2, values2);
        const group2 = groups2.get(key);
        if (group2) group2.push(value);
        else groups2.set(key, [value]);
      }
      for (const [key, values3] of groups2) {
        groups2.set(key, regroup(values3, i));
      }
      return map2(groups2);
    }(values, 0);
  }
  function permute(source, keys) {
    return Array.from(keys, (key) => source[key]);
  }
  function sort(values, ...F) {
    if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    values = Array.from(values);
    let [f] = F;
    if (f && f.length !== 2 || F.length > 1) {
      const index2 = Uint32Array.from(values, (d, i) => i);
      if (F.length > 1) {
        F = F.map((f2) => values.map(f2));
        index2.sort((i, j) => {
          for (const f2 of F) {
            const c2 = ascendingDefined(f2[i], f2[j]);
            if (c2) return c2;
          }
        });
      } else {
        f = values.map(f);
        index2.sort((i, j) => ascendingDefined(f[i], f[j]));
      }
      return permute(values, index2);
    }
    return values.sort(compareDefined(f));
  }
  function compareDefined(compare = ascending) {
    if (compare === ascending) return ascendingDefined;
    if (typeof compare !== "function") throw new TypeError("compare is not a function");
    return (a2, b) => {
      const x2 = compare(a2, b);
      if (x2 || x2 === 0) return x2;
      return (compare(b, b) === 0) - (compare(a2, a2) === 0);
    };
  }
  function ascendingDefined(a2, b) {
    return (a2 == null || !(a2 >= a2)) - (b == null || !(b >= b)) || (a2 < b ? -1 : a2 > b ? 1 : 0);
  }
  function groupSort(values, reduce2, key) {
    return (reduce2.length !== 2 ? sort(rollup(values, reduce2, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values, key), ([ak, av], [bk, bv]) => reduce2(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
  }
  var array$1 = Array.prototype;
  var slice = array$1.slice;
  var map$3 = array$1.map;
  function constant$1(x2) {
    return () => x2;
  }
  const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
  function tickSpec(start, stop, count2) {
    const step = (stop - start) / Math.max(0, count2), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
    let i1, i2, inc;
    if (power < 0) {
      inc = Math.pow(10, -power) / factor;
      i1 = Math.round(start * inc);
      i2 = Math.round(stop * inc);
      if (i1 / inc < start) ++i1;
      if (i2 / inc > stop) --i2;
      inc = -inc;
    } else {
      inc = Math.pow(10, power) * factor;
      i1 = Math.round(start / inc);
      i2 = Math.round(stop / inc);
      if (i1 * inc < start) ++i1;
      if (i2 * inc > stop) --i2;
    }
    if (i2 < i1 && 0.5 <= count2 && count2 < 2) return tickSpec(start, stop, count2 * 2);
    return [i1, i2, inc];
  }
  function ticks(start, stop, count2) {
    stop = +stop, start = +start, count2 = +count2;
    if (!(count2 > 0)) return [];
    if (start === stop) return [start];
    const reverse2 = stop < start, [i1, i2, inc] = reverse2 ? tickSpec(stop, start, count2) : tickSpec(start, stop, count2);
    if (!(i2 >= i1)) return [];
    const n = i2 - i1 + 1, ticks2 = new Array(n);
    if (reverse2) {
      if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) / -inc;
      else for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) * inc;
    } else {
      if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) / -inc;
      else for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) * inc;
    }
    return ticks2;
  }
  function tickIncrement(start, stop, count2) {
    stop = +stop, start = +start, count2 = +count2;
    return tickSpec(start, stop, count2)[2];
  }
  function tickStep(start, stop, count2) {
    stop = +stop, start = +start, count2 = +count2;
    const reverse2 = stop < start, inc = reverse2 ? tickIncrement(stop, start, count2) : tickIncrement(start, stop, count2);
    return (reverse2 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
  }
  function nice$1(start, stop, count2) {
    let prestep;
    while (true) {
      const step = tickIncrement(start, stop, count2);
      if (step === prestep || step === 0 || !isFinite(step)) {
        return [start, stop];
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      }
      prestep = step;
    }
  }
  function thresholdSturges(values) {
    return Math.max(1, Math.ceil(Math.log(count(values)) / Math.LN2) + 1);
  }
  function bin() {
    var value = identity$6, domain = extent, threshold2 = thresholdSturges;
    function histogram(data) {
      if (!Array.isArray(data)) data = Array.from(data);
      var i, n = data.length, x2, step, values = new Array(n);
      for (i = 0; i < n; ++i) {
        values[i] = value(data[i], i, data);
      }
      var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold2(values, x0, x1);
      if (!Array.isArray(tz)) {
        const max2 = x1, tn = +tz;
        if (domain === extent) [x0, x1] = nice$1(x0, x1, tn);
        tz = ticks(x0, x1, tn);
        if (tz[0] <= x0) step = tickIncrement(x0, x1, tn);
        if (tz[tz.length - 1] >= x1) {
          if (max2 >= x1 && domain === extent) {
            const step2 = tickIncrement(x0, x1, tn);
            if (isFinite(step2)) {
              if (step2 > 0) {
                x1 = (Math.floor(x1 / step2) + 1) * step2;
              } else if (step2 < 0) {
                x1 = (Math.ceil(x1 * -step2) + 1) / -step2;
              }
            }
          } else {
            tz.pop();
          }
        }
      }
      var m = tz.length, a2 = 0, b = m;
      while (tz[a2] <= x0) ++a2;
      while (tz[b - 1] > x1) --b;
      if (a2 || b < m) tz = tz.slice(a2, b), m = b - a2;
      var bins = new Array(m + 1), bin2;
      for (i = 0; i <= m; ++i) {
        bin2 = bins[i] = [];
        bin2.x0 = i > 0 ? tz[i - 1] : x0;
        bin2.x1 = i < m ? tz[i] : x1;
      }
      if (isFinite(step)) {
        if (step > 0) {
          for (i = 0; i < n; ++i) {
            if ((x2 = values[i]) != null && x0 <= x2 && x2 <= x1) {
              bins[Math.min(m, Math.floor((x2 - x0) / step))].push(data[i]);
            }
          }
        } else if (step < 0) {
          for (i = 0; i < n; ++i) {
            if ((x2 = values[i]) != null && x0 <= x2 && x2 <= x1) {
              const j = Math.floor((x0 - x2) * step);
              bins[Math.min(m, j + (tz[j] <= x2))].push(data[i]);
            }
          }
        }
      } else {
        for (i = 0; i < n; ++i) {
          if ((x2 = values[i]) != null && x0 <= x2 && x2 <= x1) {
            bins[bisectRight(tz, x2, 0, m)].push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(_), histogram) : value;
    };
    histogram.domain = function(_) {
      return arguments.length ? (domain = typeof _ === "function" ? _ : constant$1([_[0], _[1]]), histogram) : domain;
    };
    histogram.thresholds = function(_) {
      return arguments.length ? (threshold2 = typeof _ === "function" ? _ : constant$1(Array.isArray(_) ? slice.call(_) : _), histogram) : threshold2;
    };
    return histogram;
  }
  function max(values, valueof) {
    let max2;
    if (valueof === void 0) {
      for (const value of values) {
        if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
          max2 = value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (max2 < value || max2 === void 0 && value >= value)) {
          max2 = value;
        }
      }
    }
    return max2;
  }
  function maxIndex(values, valueof) {
    let max2;
    let maxIndex2 = -1;
    let index2 = -1;
    if (valueof === void 0) {
      for (const value of values) {
        ++index2;
        if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
          max2 = value, maxIndex2 = index2;
        }
      }
    } else {
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (max2 < value || max2 === void 0 && value >= value)) {
          max2 = value, maxIndex2 = index2;
        }
      }
    }
    return maxIndex2;
  }
  function min(values, valueof) {
    let min2;
    if (valueof === void 0) {
      for (const value of values) {
        if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
          min2 = value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (min2 > value || min2 === void 0 && value >= value)) {
          min2 = value;
        }
      }
    }
    return min2;
  }
  function minIndex(values, valueof) {
    let min2;
    let minIndex2 = -1;
    let index2 = -1;
    if (valueof === void 0) {
      for (const value of values) {
        ++index2;
        if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
          min2 = value, minIndex2 = index2;
        }
      }
    } else {
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (min2 > value || min2 === void 0 && value >= value)) {
          min2 = value, minIndex2 = index2;
        }
      }
    }
    return minIndex2;
  }
  function quickselect(array2, k2, left = 0, right = Infinity, compare) {
    k2 = Math.floor(k2);
    left = Math.floor(Math.max(0, left));
    right = Math.floor(Math.min(array2.length - 1, right));
    if (!(left <= k2 && k2 <= right)) return array2;
    compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
    while (right > left) {
      if (right - left > 600) {
        const n = right - left + 1;
        const m = k2 - left + 1;
        const z = Math.log(n);
        const s2 = 0.5 * Math.exp(2 * z / 3);
        const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m - n / 2 < 0 ? -1 : 1);
        const newLeft = Math.max(left, Math.floor(k2 - m * s2 / n + sd));
        const newRight = Math.min(right, Math.floor(k2 + (n - m) * s2 / n + sd));
        quickselect(array2, k2, newLeft, newRight, compare);
      }
      const t = array2[k2];
      let i = left;
      let j = right;
      swap(array2, left, k2);
      if (compare(array2[right], t) > 0) swap(array2, left, right);
      while (i < j) {
        swap(array2, i, j), ++i, --j;
        while (compare(array2[i], t) < 0) ++i;
        while (compare(array2[j], t) > 0) --j;
      }
      if (compare(array2[left], t) === 0) swap(array2, left, j);
      else ++j, swap(array2, j, right);
      if (j <= k2) left = j + 1;
      if (k2 <= j) right = j - 1;
    }
    return array2;
  }
  function swap(array2, i, j) {
    const t = array2[i];
    array2[i] = array2[j];
    array2[j] = t;
  }
  function greatest(values, compare = ascending) {
    let max2;
    let defined2 = false;
    if (compare.length === 1) {
      let maxValue;
      for (const element of values) {
        const value = compare(element);
        if (defined2 ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {
          max2 = element;
          maxValue = value;
          defined2 = true;
        }
      }
    } else {
      for (const value of values) {
        if (defined2 ? compare(value, max2) > 0 : compare(value, value) === 0) {
          max2 = value;
          defined2 = true;
        }
      }
    }
    return max2;
  }
  function quantile$1(values, p, valueof) {
    values = Float64Array.from(numbers(values, valueof));
    if (!(n = values.length) || isNaN(p = +p)) return;
    if (p <= 0 || n < 2) return min(values);
    if (p >= 1) return max(values);
    var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min(values.subarray(i0 + 1));
    return value0 + (value1 - value0) * (i - i0);
  }
  function quantileSorted(values, p, valueof = number$2) {
    if (!(n = values.length) || isNaN(p = +p)) return;
    if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
    if (p >= 1) return +valueof(values[n - 1], n - 1, values);
    var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
    return value0 + (value1 - value0) * (i - i0);
  }
  function quantileIndex(values, p, valueof = number$2) {
    if (isNaN(p = +p)) return;
    numbers2 = Float64Array.from(values, (_, i2) => number$2(valueof(values[i2], i2, values)));
    if (p <= 0) return minIndex(numbers2);
    if (p >= 1) return maxIndex(numbers2);
    var numbers2, index2 = Uint32Array.from(values, (_, i2) => i2), j = numbers2.length - 1, i = Math.floor(j * p);
    quickselect(index2, i, 0, j, (i2, j2) => ascendingDefined(numbers2[i2], numbers2[j2]));
    i = greatest(index2.subarray(0, i + 1), (i2) => numbers2[i2]);
    return i >= 0 ? i : -1;
  }
  function thresholdFreedmanDiaconis(values, min2, max2) {
    const c2 = count(values), d = quantile$1(values, 0.75) - quantile$1(values, 0.25);
    return c2 && d ? Math.ceil((max2 - min2) / (2 * d * Math.pow(c2, -1 / 3))) : 1;
  }
  function thresholdScott(values, min2, max2) {
    const c2 = count(values), d = deviation(values);
    return c2 && d ? Math.ceil((max2 - min2) * Math.cbrt(c2) / (3.49 * d)) : 1;
  }
  function mean$1(values, valueof) {
    let count2 = 0;
    let sum2 = 0;
    if (valueof === void 0) {
      for (let value of values) {
        if (value != null && (value = +value) >= value) {
          ++count2, sum2 += value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (value = +value) >= value) {
          ++count2, sum2 += value;
        }
      }
    }
    if (count2) return sum2 / count2;
  }
  function median$1(values, valueof) {
    return quantile$1(values, 0.5, valueof);
  }
  function medianIndex(values, valueof) {
    return quantileIndex(values, 0.5, valueof);
  }
  function* flatten$1(arrays) {
    for (const array2 of arrays) {
      yield* array2;
    }
  }
  function merge$1(arrays) {
    return Array.from(flatten$1(arrays));
  }
  function mode(values, valueof) {
    const counts = new InternMap();
    if (valueof === void 0) {
      for (let value of values) {
        if (value != null && value >= value) {
          counts.set(value, (counts.get(value) || 0) + 1);
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && value >= value) {
          counts.set(value, (counts.get(value) || 0) + 1);
        }
      }
    }
    let modeValue;
    let modeCount = 0;
    for (const [value, count2] of counts) {
      if (count2 > modeCount) {
        modeCount = count2;
        modeValue = value;
      }
    }
    return modeValue;
  }
  function pairs(values, pairof = pair) {
    const pairs2 = [];
    let previous;
    let first = false;
    for (const value of values) {
      if (first) pairs2.push(pairof(previous, value));
      previous = value;
      first = true;
    }
    return pairs2;
  }
  function pair(a2, b) {
    return [a2, b];
  }
  function range$2(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
    var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range2 = new Array(n);
    while (++i < n) {
      range2[i] = start + i * step;
    }
    return range2;
  }
  function rank(values, valueof = ascending) {
    if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    let V = Array.from(values);
    const R = new Float64Array(V.length);
    if (valueof.length !== 2) V = V.map(valueof), valueof = ascending;
    const compareIndex = (i, j) => valueof(V[i], V[j]);
    let k2, r2;
    values = Uint32Array.from(V, (_, i) => i);
    values.sort(valueof === ascending ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex));
    values.forEach((j, i) => {
      const c2 = compareIndex(j, k2 === void 0 ? j : k2);
      if (c2 >= 0) {
        if (k2 === void 0 || c2 > 0) k2 = j, r2 = i;
        R[j] = r2;
      } else {
        R[j] = NaN;
      }
    });
    return R;
  }
  function least(values, compare = ascending) {
    let min2;
    let defined2 = false;
    if (compare.length === 1) {
      let minValue;
      for (const element of values) {
        const value = compare(element);
        if (defined2 ? ascending(value, minValue) < 0 : ascending(value, value) === 0) {
          min2 = element;
          minValue = value;
          defined2 = true;
        }
      }
    } else {
      for (const value of values) {
        if (defined2 ? compare(value, min2) < 0 : compare(value, value) === 0) {
          min2 = value;
          defined2 = true;
        }
      }
    }
    return min2;
  }
  function leastIndex(values, compare = ascending) {
    if (compare.length === 1) return minIndex(values, compare);
    let minValue;
    let min2 = -1;
    let index2 = -1;
    for (const value of values) {
      ++index2;
      if (min2 < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {
        minValue = value;
        min2 = index2;
      }
    }
    return min2;
  }
  function greatestIndex(values, compare = ascending) {
    if (compare.length === 1) return maxIndex(values, compare);
    let maxValue;
    let max2 = -1;
    let index2 = -1;
    for (const value of values) {
      ++index2;
      if (max2 < 0 ? compare(value, value) === 0 : compare(value, maxValue) > 0) {
        maxValue = value;
        max2 = index2;
      }
    }
    return max2;
  }
  function scan(values, compare) {
    const index2 = leastIndex(values, compare);
    return index2 < 0 ? void 0 : index2;
  }
  const shuffle$1 = shuffler(Math.random);
  function shuffler(random2) {
    return function shuffle2(array2, i0 = 0, i1 = array2.length) {
      let m = i1 - (i0 = +i0);
      while (m) {
        const i = random2() * m-- | 0, t = array2[m + i0];
        array2[m + i0] = array2[i + i0];
        array2[i + i0] = t;
      }
      return array2;
    };
  }
  function sum$1(values, valueof) {
    let sum2 = 0;
    if (valueof === void 0) {
      for (let value of values) {
        if (value = +value) {
          sum2 += value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if (value = +valueof(value, ++index2, values)) {
          sum2 += value;
        }
      }
    }
    return sum2;
  }
  function transpose(matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = min(matrix, length), transpose2 = new Array(m); ++i < m; ) {
      for (var j = -1, n, row = transpose2[i] = new Array(n); ++j < n; ) {
        row[j] = matrix[j][i];
      }
    }
    return transpose2;
  }
  function length(d) {
    return d.length;
  }
  function zip$1() {
    return transpose(arguments);
  }
  function every(values, test) {
    if (typeof test !== "function") throw new TypeError("test is not a function");
    let index2 = -1;
    for (const value of values) {
      if (!test(value, ++index2, values)) {
        return false;
      }
    }
    return true;
  }
  function some(values, test) {
    if (typeof test !== "function") throw new TypeError("test is not a function");
    let index2 = -1;
    for (const value of values) {
      if (test(value, ++index2, values)) {
        return true;
      }
    }
    return false;
  }
  function filter(values, test) {
    if (typeof test !== "function") throw new TypeError("test is not a function");
    const array2 = [];
    let index2 = -1;
    for (const value of values) {
      if (test(value, ++index2, values)) {
        array2.push(value);
      }
    }
    return array2;
  }
  function map$2(values, mapper) {
    if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
    return Array.from(values, (value, index2) => mapper(value, index2, values));
  }
  function reduce(values, reducer2, value) {
    if (typeof reducer2 !== "function") throw new TypeError("reducer is not a function");
    const iterator = values[Symbol.iterator]();
    let done, next, index2 = -1;
    if (arguments.length < 3) {
      ({ done, value } = iterator.next());
      if (done) return;
      ++index2;
    }
    while ({ done, value: next } = iterator.next(), !done) {
      value = reducer2(value, next, ++index2, values);
    }
    return value;
  }
  function reverse$1(values) {
    if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    return Array.from(values).reverse();
  }
  function difference$1(values, ...others) {
    values = new InternSet(values);
    for (const other of others) {
      for (const value of other) {
        values.delete(value);
      }
    }
    return values;
  }
  function disjoint(values, other) {
    const iterator = other[Symbol.iterator](), set2 = new InternSet();
    for (const v of values) {
      if (set2.has(v)) return false;
      let value, done;
      while ({ value, done } = iterator.next()) {
        if (done) break;
        if (Object.is(v, value)) return false;
        set2.add(value);
      }
    }
    return true;
  }
  function intersection$1(values, ...others) {
    values = new InternSet(values);
    others = others.map(set);
    out: for (const value of values) {
      for (const other of others) {
        if (!other.has(value)) {
          values.delete(value);
          continue out;
        }
      }
    }
    return values;
  }
  function set(values) {
    return values instanceof InternSet ? values : new InternSet(values);
  }
  function superset(values, other) {
    const iterator = values[Symbol.iterator](), set2 = /* @__PURE__ */ new Set();
    for (const o of other) {
      const io = intern(o);
      if (set2.has(io)) continue;
      let value, done;
      while ({ value, done } = iterator.next()) {
        if (done) return false;
        const ivalue = intern(value);
        set2.add(ivalue);
        if (Object.is(io, ivalue)) break;
      }
    }
    return true;
  }
  function intern(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }
  function subset(values, other) {
    return superset(other, values);
  }
  function union$1(...others) {
    const set2 = new InternSet();
    for (const other of others) {
      for (const o of other) {
        set2.add(o);
      }
    }
    return set2;
  }
  function initRange(domain, range2) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(domain);
        break;
      default:
        this.range(range2).domain(domain);
        break;
    }
    return this;
  }
  function initInterpolator(domain, interpolator) {
    switch (arguments.length) {
      case 0:
        break;
      case 1: {
        if (typeof domain === "function") this.interpolator(domain);
        else this.range(domain);
        break;
      }
      default: {
        this.domain(domain);
        if (typeof interpolator === "function") this.interpolator(interpolator);
        else this.range(interpolator);
        break;
      }
    }
    return this;
  }
  const implicit = Symbol("implicit");
  function ordinal() {
    var index2 = new InternMap(), domain = [], range2 = [], unknown = implicit;
    function scale(d) {
      let i = index2.get(d);
      if (i === void 0) {
        if (unknown !== implicit) return unknown;
        index2.set(d, i = domain.push(d) - 1);
      }
      return range2[i % range2.length];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [], index2 = new InternMap();
      for (const value of _) {
        if (index2.has(value)) continue;
        index2.set(value, domain.push(value) - 1);
      }
      return scale;
    };
    scale.range = function(_) {
      return arguments.length ? (range2 = Array.from(_), scale) : range2.slice();
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
      return ordinal(domain, range2).unknown(unknown);
    };
    initRange.apply(scale, arguments);
    return scale;
  }
  function band() {
    var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
    delete scale.unknown;
    function rescale() {
      var n = domain().length, reverse2 = r1 < r0, start = reverse2 ? r1 : r0, stop = reverse2 ? r0 : r1;
      step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
      if (round2) step = Math.floor(step);
      start += (stop - start - step * (n - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round2) start = Math.round(start), bandwidth = Math.round(bandwidth);
      var values = range$2(n).map(function(i) {
        return start + step * i;
      });
      return ordinalRange(reverse2 ? values.reverse() : values);
    }
    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale.range = function(_) {
      return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
    };
    scale.rangeRound = function(_) {
      return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();
    };
    scale.bandwidth = function() {
      return bandwidth;
    };
    scale.step = function() {
      return step;
    };
    scale.round = function(_) {
      return arguments.length ? (round2 = !!_, rescale()) : round2;
    };
    scale.padding = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
    };
    scale.paddingInner = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
    };
    scale.paddingOuter = function(_) {
      return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
    };
    scale.align = function(_) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };
    scale.copy = function() {
      return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
    };
    return initRange.apply(rescale(), arguments);
  }
  function pointish(scale) {
    var copy2 = scale.copy;
    scale.padding = scale.paddingOuter;
    delete scale.paddingInner;
    delete scale.paddingOuter;
    scale.copy = function() {
      return pointish(copy2());
    };
    return scale;
  }
  function point() {
    return pointish(band.apply(null, arguments).paddingInner(1));
  }
  function define2(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define2(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format2) {
    var m, l;
    format2 = (format2 + "").trim().toLowerCase();
    return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba(r2, g, b, a2) {
    if (a2 <= 0) r2 = g = b = NaN;
    return new Rgb(r2, g, b, a2);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb$1(r2, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r2, g, b, opacity) {
    this.r = +r2;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define2(Rgb, rgb$1, extend(Color, {
    brighter(k2) {
      k2 = k2 == null ? brighter : Math.pow(brighter, k2);
      return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
    },
    darker(k2) {
      k2 = k2 == null ? darker : Math.pow(darker, k2);
      return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h, s2, l, a2) {
    if (a2 <= 0) h = s2 = l = NaN;
    else if (l <= 0 || l >= 1) h = s2 = NaN;
    else if (s2 <= 0) h = NaN;
    return new Hsl(h, s2, l, a2);
  }
  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl();
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r2 = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r2, g, b), max2 = Math.max(r2, g, b), h = NaN, s2 = max2 - min2, l = (max2 + min2) / 2;
    if (s2) {
      if (r2 === max2) h = (g - b) / s2 + (g < b) * 6;
      else if (g === max2) h = (b - r2) / s2 + 2;
      else h = (r2 - g) / s2 + 4;
      s2 /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
      h *= 60;
    } else {
      s2 = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s2, l, o.opacity);
  }
  function hsl$2(h, s2, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
  }
  function Hsl(h, s2, l, opacity) {
    this.h = +h;
    this.s = +s2;
    this.l = +l;
    this.opacity = +opacity;
  }
  define2(Hsl, hsl$2, extend(Color, {
    brighter(k2) {
      k2 = k2 == null ? brighter : Math.pow(brighter, k2);
      return new Hsl(this.h, this.s, this.l * k2, this.opacity);
    },
    darker(k2) {
      k2 = k2 == null ? darker : Math.pow(darker, k2);
      return new Hsl(this.h, this.s, this.l * k2, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a2 = clampa(this.opacity);
      return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }
  const radians = Math.PI / 180;
  const degrees$1 = 180 / Math.PI;
  const K = 18, Xn = 0.96422, Yn = 1, Zn = 0.82521, t0$1 = 4 / 29, t1$1 = 6 / 29, t2 = 3 * t1$1 * t1$1, t3 = t1$1 * t1$1 * t1$1;
  function labConvert(o) {
    if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
    if (o instanceof Hcl) return hcl2lab(o);
    if (!(o instanceof Rgb)) o = rgbConvert(o);
    var r2 = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y2 = xyz2lab((0.2225045 * r2 + 0.7168786 * g + 0.0606169 * b) / Yn), x2, z;
    if (r2 === g && g === b) x2 = z = y2;
    else {
      x2 = xyz2lab((0.4360747 * r2 + 0.3850649 * g + 0.1430804 * b) / Xn);
      z = xyz2lab((0.0139322 * r2 + 0.0971045 * g + 0.7141733 * b) / Zn);
    }
    return new Lab(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z), o.opacity);
  }
  function gray(l, opacity) {
    return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
  }
  function lab$1(l, a2, b, opacity) {
    return arguments.length === 1 ? labConvert(l) : new Lab(l, a2, b, opacity == null ? 1 : opacity);
  }
  function Lab(l, a2, b, opacity) {
    this.l = +l;
    this.a = +a2;
    this.b = +b;
    this.opacity = +opacity;
  }
  define2(Lab, lab$1, extend(Color, {
    brighter(k2) {
      return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
    },
    darker(k2) {
      return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
    },
    rgb() {
      var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z = isNaN(this.b) ? y2 : y2 - this.b / 200;
      x2 = Xn * lab2xyz(x2);
      y2 = Yn * lab2xyz(y2);
      z = Zn * lab2xyz(z);
      return new Rgb(
        lrgb2rgb(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z),
        lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z),
        lrgb2rgb(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z),
        this.opacity
      );
    }
  }));
  function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
  }
  function lab2xyz(t) {
    return t > t1$1 ? t * t * t : t2 * (t - t0$1);
  }
  function lrgb2rgb(x2) {
    return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
  }
  function rgb2lrgb(x2) {
    return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
  }
  function hclConvert(o) {
    if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
    if (!(o instanceof Lab)) o = labConvert(o);
    if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
    var h = Math.atan2(o.b, o.a) * degrees$1;
    return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
  }
  function lch(l, c2, h, opacity) {
    return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c2, l, opacity == null ? 1 : opacity);
  }
  function hcl$2(h, c2, l, opacity) {
    return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c2, l, opacity == null ? 1 : opacity);
  }
  function Hcl(h, c2, l, opacity) {
    this.h = +h;
    this.c = +c2;
    this.l = +l;
    this.opacity = +opacity;
  }
  function hcl2lab(o) {
    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
    var h = o.h * radians;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  define2(Hcl, hcl$2, extend(Color, {
    brighter(k2) {
      return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
    },
    darker(k2) {
      return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
    },
    rgb() {
      return hcl2lab(this).rgb();
    }
  }));
  var A = -0.14861, B = 1.78277, C = -0.29227, D = -0.90649, E = 1.97294, ED = E * D, EB = E * B, BC_DA = B * C - D * A;
  function cubehelixConvert(o) {
    if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Rgb)) o = rgbConvert(o);
    var r2 = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r2 - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * degrees$1 - 120 : NaN;
    return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);
  }
  function cubehelix$2(h, s2, l, opacity) {
    return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity == null ? 1 : opacity);
  }
  function Cubehelix(h, s2, l, opacity) {
    this.h = +h;
    this.s = +s2;
    this.l = +l;
    this.opacity = +opacity;
  }
  define2(Cubehelix, cubehelix$2, extend(Color, {
    brighter(k2) {
      k2 = k2 == null ? brighter : Math.pow(brighter, k2);
      return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
    },
    darker(k2) {
      k2 = k2 == null ? darker : Math.pow(darker, k2);
      return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
    },
    rgb() {
      var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
      return new Rgb(
        255 * (l + a2 * (A * cosh2 + B * sinh2)),
        255 * (l + a2 * (C * cosh2 + D * sinh2)),
        255 * (l + a2 * (E * cosh2)),
        this.opacity
      );
    }
  }));
  function basis(t12, v0, v1, v2, v3) {
    var t22 = t12 * t12, t32 = t22 * t12;
    return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
  }
  function basis$1(values) {
    var n = values.length - 1;
    return function(t) {
      var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }
  function basisClosed(values) {
    var n = values.length;
    return function(t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }
  const constant = (x2) => () => x2;
  function linear$1(a2, d) {
    return function(t) {
      return a2 + t * d;
    };
  }
  function exponential(a2, b, y2) {
    return a2 = Math.pow(a2, y2), b = Math.pow(b, y2) - a2, y2 = 1 / y2, function(t) {
      return Math.pow(a2 + t * b, y2);
    };
  }
  function hue$1(a2, b) {
    var d = b - a2;
    return d ? linear$1(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a2) ? b : a2);
  }
  function gamma(y2) {
    return (y2 = +y2) === 1 ? nogamma : function(a2, b) {
      return b - a2 ? exponential(a2, b, y2) : constant(isNaN(a2) ? b : a2);
    };
  }
  function nogamma(a2, b) {
    var d = b - a2;
    return d ? linear$1(a2, d) : constant(isNaN(a2) ? b : a2);
  }
  const rgb = function rgbGamma(y2) {
    var color2 = gamma(y2);
    function rgb2(start, end) {
      var r2 = color2((start = rgb$1(start)).r, (end = rgb$1(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.r = r2(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  }(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n = colors.length, r2 = new Array(n), g = new Array(n), b = new Array(n), i, color2;
      for (i = 0; i < n; ++i) {
        color2 = rgb$1(colors[i]);
        r2[i] = color2.r || 0;
        g[i] = color2.g || 0;
        b[i] = color2.b || 0;
      }
      r2 = spline(r2);
      g = spline(g);
      b = spline(b);
      color2.opacity = 1;
      return function(t) {
        color2.r = r2(t);
        color2.g = g(t);
        color2.b = b(t);
        return color2 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis$1);
  var rgbBasisClosed = rgbSpline(basisClosed);
  function numberArray(a2, b) {
    if (!b) b = [];
    var n = a2 ? Math.min(b.length, a2.length) : 0, c2 = b.slice(), i;
    return function(t) {
      for (i = 0; i < n; ++i) c2[i] = a2[i] * (1 - t) + b[i] * t;
      return c2;
    };
  }
  function isNumberArray(x2) {
    return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
  }
  function array(a2, b) {
    return (isNumberArray(b) ? numberArray : genericArray)(a2, b);
  }
  function genericArray(a2, b) {
    var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i;
    for (i = 0; i < na; ++i) x2[i] = interpolate(a2[i], b[i]);
    for (; i < nb; ++i) c2[i] = b[i];
    return function(t) {
      for (i = 0; i < na; ++i) c2[i] = x2[i](t);
      return c2;
    };
  }
  function date$1(a2, b) {
    var d = /* @__PURE__ */ new Date();
    return a2 = +a2, b = +b, function(t) {
      return d.setTime(a2 * (1 - t) + b * t), d;
    };
  }
  function interpolateNumber$1(a2, b) {
    return a2 = +a2, b = +b, function(t) {
      return a2 * (1 - t) + b * t;
    };
  }
  function object(a2, b) {
    var i = {}, c2 = {}, k2;
    if (a2 === null || typeof a2 !== "object") a2 = {};
    if (b === null || typeof b !== "object") b = {};
    for (k2 in b) {
      if (k2 in a2) {
        i[k2] = interpolate(a2[k2], b[k2]);
      } else {
        c2[k2] = b[k2];
      }
    }
    return function(t) {
      for (k2 in i) c2[k2] = i[k2](t);
      return c2;
    };
  }
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
  function zero(b) {
    return function() {
      return b;
    };
  }
  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }
  function string(a2, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
    a2 = a2 + "", b = b + "";
    while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s2[i]) s2[i] += bs;
        else s2[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s2[i]) s2[i] += bm;
        else s2[++i] = bm;
      } else {
        s2[++i] = null;
        q.push({ i, x: interpolateNumber$1(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s2[i]) s2[i] += bs;
      else s2[++i] = bs;
    }
    return s2.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
      for (var i2 = 0, o; i2 < b; ++i2) s2[(o = q[i2]).i] = o.x(t);
      return s2.join("");
    });
  }
  function interpolate(a2, b) {
    var t = typeof b, c2;
    return b == null || t === "boolean" ? constant(b) : (t === "number" ? interpolateNumber$1 : t === "string" ? (c2 = color(b)) ? (b = c2, rgb) : string : b instanceof color ? rgb : b instanceof Date ? date$1 : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber$1)(a2, b);
  }
  function discrete(range2) {
    var n = range2.length;
    return function(t) {
      return range2[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
  }
  function hue(a2, b) {
    var i = hue$1(+a2, +b);
    return function(t) {
      var x2 = i(t);
      return x2 - 360 * Math.floor(x2 / 360);
    };
  }
  function interpolateRound(a2, b) {
    return a2 = +a2, b = +b, function(t) {
      return Math.round(a2 * (1 - t) + b * t);
    };
  }
  var degrees = 180 / Math.PI;
  var identity$5 = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function decompose(a2, b, c2, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a2 * a2 + b * b)) a2 /= scaleX, b /= scaleX;
    if (skewX = a2 * c2 + b * d) c2 -= a2 * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c2 * c2 + d * d)) c2 /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a2 * d < b * c2) a2 = -a2, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b, a2) * degrees,
      skewX: Math.atan(skewX) * degrees,
      scaleX,
      scaleY
    };
  }
  var svgNode;
  function parseCss(value) {
    const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
    return m.isIdentity ? identity$5 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
  }
  function parseSvg(value) {
    if (value == null) return identity$5;
    if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate())) return identity$5;
    value = value.matrix;
    return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
  }
  function interpolateTransform(parse, pxComma, pxParen, degParen) {
    function pop(s2) {
      return s2.length ? s2.pop() + " " : "";
    }
    function translate(xa, ya, xb, yb, s2, q) {
      if (xa !== xb || ya !== yb) {
        var i = s2.push("translate(", null, pxComma, null, pxParen);
        q.push({ i: i - 4, x: interpolateNumber$1(xa, xb) }, { i: i - 2, x: interpolateNumber$1(ya, yb) });
      } else if (xb || yb) {
        s2.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }
    function rotate(a2, b, s2, q) {
      if (a2 !== b) {
        if (a2 - b > 180) b += 360;
        else if (b - a2 > 180) a2 += 360;
        q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: interpolateNumber$1(a2, b) });
      } else if (b) {
        s2.push(pop(s2) + "rotate(" + b + degParen);
      }
    }
    function skewX(a2, b, s2, q) {
      if (a2 !== b) {
        q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: interpolateNumber$1(a2, b) });
      } else if (b) {
        s2.push(pop(s2) + "skewX(" + b + degParen);
      }
    }
    function scale(xa, ya, xb, yb, s2, q) {
      if (xa !== xb || ya !== yb) {
        var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
        q.push({ i: i - 4, x: interpolateNumber$1(xa, xb) }, { i: i - 2, x: interpolateNumber$1(ya, yb) });
      } else if (xb !== 1 || yb !== 1) {
        s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
      }
    }
    return function(a2, b) {
      var s2 = [], q = [];
      a2 = parse(a2), b = parse(b);
      translate(a2.translateX, a2.translateY, b.translateX, b.translateY, s2, q);
      rotate(a2.rotate, b.rotate, s2, q);
      skewX(a2.skewX, b.skewX, s2, q);
      scale(a2.scaleX, a2.scaleY, b.scaleX, b.scaleY, s2, q);
      a2 = b = null;
      return function(t) {
        var i = -1, n = q.length, o;
        while (++i < n) s2[(o = q[i]).i] = o.x(t);
        return s2.join("");
      };
    };
  }
  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
  var epsilon2 = 1e-12;
  function cosh(x2) {
    return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
  }
  function sinh(x2) {
    return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
  }
  function tanh(x2) {
    return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
  }
  const zoom = function zoomRho(rho, rho2, rho4) {
    function zoom2(p0, p1) {
      var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
      if (d2 < epsilon2) {
        S = Math.log(w1 / w0) / rho;
        i = function(t) {
          return [
            ux0 + t * dx,
            uy0 + t * dy,
            w0 * Math.exp(rho * t * S)
          ];
        };
      } else {
        var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
        S = (r1 - r0) / rho;
        i = function(t) {
          var s2 = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
          return [
            ux0 + u * dx,
            uy0 + u * dy,
            w0 * coshr0 / cosh(rho * s2 + r0)
          ];
        };
      }
      i.duration = S * 1e3 * rho / Math.SQRT2;
      return i;
    }
    zoom2.rho = function(_) {
      var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
      return zoomRho(_1, _2, _4);
    };
    return zoom2;
  }(Math.SQRT2, 2, 4);
  function hsl(hue2) {
    return function(start, end) {
      var h = hue2((start = hsl$2(start)).h, (end = hsl$2(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s2(t);
        start.l = l(t);
        start.opacity = opacity(t);
        return start + "";
      };
    };
  }
  const hsl$1 = hsl(hue$1);
  var hslLong = hsl(nogamma);
  function lab(start, end) {
    var l = nogamma((start = lab$1(start)).l, (end = lab$1(end)).l), a2 = nogamma(start.a, end.a), b = nogamma(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.l = l(t);
      start.a = a2(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  function hcl(hue2) {
    return function(start, end) {
      var h = hue2((start = hcl$2(start)).h, (end = hcl$2(end)).h), c2 = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.c = c2(t);
        start.l = l(t);
        start.opacity = opacity(t);
        return start + "";
      };
    };
  }
  const hcl$1 = hcl(hue$1);
  var hclLong = hcl(nogamma);
  function cubehelix(hue2) {
    return function cubehelixGamma(y2) {
      y2 = +y2;
      function cubehelix2(start, end) {
        var h = hue2((start = cubehelix$2(start)).h, (end = cubehelix$2(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.s = s2(t);
          start.l = l(Math.pow(t, y2));
          start.opacity = opacity(t);
          return start + "";
        };
      }
      cubehelix2.gamma = cubehelixGamma;
      return cubehelix2;
    }(1);
  }
  const cubehelix$1 = cubehelix(hue$1);
  var cubehelixLong = cubehelix(nogamma);
  function piecewise(interpolate$12, values) {
    if (values === void 0) values = interpolate$12, interpolate$12 = interpolate;
    var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
    while (i < n) I[i] = interpolate$12(v, v = values[++i]);
    return function(t) {
      var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
      return I[i2](t - i2);
    };
  }
  function quantize$1(interpolator, n) {
    var samples = new Array(n);
    for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
    return samples;
  }
  function constants(x2) {
    return function() {
      return x2;
    };
  }
  function number$1(x2) {
    return +x2;
  }
  var unit = [0, 1];
  function identity$4(x2) {
    return x2;
  }
  function normalize(a2, b) {
    return (b -= a2 = +a2) ? function(x2) {
      return (x2 - a2) / b;
    } : constants(isNaN(b) ? NaN : 0.5);
  }
  function clamper(a2, b) {
    var t;
    if (a2 > b) t = a2, a2 = b, b = t;
    return function(x2) {
      return Math.max(a2, Math.min(b, x2));
    };
  }
  function bimap(domain, range2, interpolate2) {
    var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
    if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
    else d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
    return function(x2) {
      return r0(d0(x2));
    };
  }
  function polymap(domain, range2, interpolate2) {
    var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r2 = new Array(j), i = -1;
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range2 = range2.slice().reverse();
    }
    while (++i < j) {
      d[i] = normalize(domain[i], domain[i + 1]);
      r2[i] = interpolate2(range2[i], range2[i + 1]);
    }
    return function(x2) {
      var i2 = bisectRight(domain, x2, 1, j) - 1;
      return r2[i2](d[i2](x2));
    };
  }
  function copy$1(source, target) {
    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
  }
  function transformer$2() {
    var domain = unit, range2 = unit, interpolate$12 = interpolate, transform, untransform, unknown, clamp2 = identity$4, piecewise2, output, input;
    function rescale() {
      var n = Math.min(domain.length, range2.length);
      if (clamp2 !== identity$4) clamp2 = clamper(domain[0], domain[n - 1]);
      piecewise2 = n > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }
    function scale(x2) {
      return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise2(domain.map(transform), range2, interpolate$12)))(transform(clamp2(x2)));
    }
    scale.invert = function(y2) {
      return clamp2(untransform((input || (input = piecewise2(range2, domain.map(transform), interpolateNumber$1)))(y2)));
    };
    scale.domain = function(_) {
      return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
    };
    scale.range = function(_) {
      return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
    };
    scale.rangeRound = function(_) {
      return range2 = Array.from(_), interpolate$12 = interpolateRound, rescale();
    };
    scale.clamp = function(_) {
      return arguments.length ? (clamp2 = _ ? true : identity$4, rescale()) : clamp2 !== identity$4;
    };
    scale.interpolate = function(_) {
      return arguments.length ? (interpolate$12 = _, rescale()) : interpolate$12;
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function(t, u) {
      transform = t, untransform = u;
      return rescale();
    };
  }
  function continuous() {
    return transformer$2()(identity$4, identity$4);
  }
  function formatDecimal(x2) {
    return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
  }
  function formatDecimalParts(x2, p) {
    if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0) return null;
    var i, coefficient = x2.slice(0, i);
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x2.slice(i + 1)
    ];
  }
  function exponent(x2) {
    return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
  }
  function formatGroup(grouping, thousands) {
    return function(value, width) {
      var i = value.length, t = [], j = 0, g = grouping[0], length2 = 0;
      while (i > 0 && g > 0) {
        if (length2 + g + 1 > width) g = Math.max(1, width - length2);
        t.push(value.substring(i -= g, i + g));
        if ((length2 += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }
      return t.reverse().join(thousands);
    };
  }
  function formatNumerals(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  }
  formatSpecifier.prototype = FormatSpecifier.prototype;
  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === void 0 ? "" : specifier.type + "";
  }
  FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };
  function formatTrim(s2) {
    out: for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0) i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i]) break out;
          if (i0 > 0) i0 = 0;
          break;
      }
    }
    return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
  }
  var prefixExponent;
  function formatPrefixAuto(x2, p) {
    var d = formatDecimalParts(x2, p);
    if (!d) return x2 + "";
    var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p + i - 1))[0];
  }
  function formatRounded(x2, p) {
    var d = formatDecimalParts(x2, p);
    if (!d) return x2 + "";
    var coefficient = d[0], exponent2 = d[1];
    return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
  }
  const formatTypes = {
    "%": (x2, p) => (x2 * 100).toFixed(p),
    "b": (x2) => Math.round(x2).toString(2),
    "c": (x2) => x2 + "",
    "d": formatDecimal,
    "e": (x2, p) => x2.toExponential(p),
    "f": (x2, p) => x2.toFixed(p),
    "g": (x2, p) => x2.toPrecision(p),
    "o": (x2) => Math.round(x2).toString(8),
    "p": (x2, p) => formatRounded(x2 * 100, p),
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
    "x": (x2) => Math.round(x2).toString(16)
  };
  function identity$3(x2) {
    return x2;
  }
  var map$1 = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function formatLocale$1(locale2) {
    var group2 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$3 : formatGroup(map$1.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$3 : formatNumerals(map$1.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "−" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);
      var fill2 = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type = specifier.type;
      if (type === "n") comma = true, type = "g";
      else if (!formatTypes[type]) precision === void 0 && (precision = 12), trim2 = true, type = "g";
      if (zero2 || fill2 === "0" && align === "=") zero2 = true, fill2 = "0", align = "=";
      var prefix2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
      var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
      precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
      function format2(value) {
        var valuePrefix = prefix2, valueSuffix = suffix, i, n, c2;
        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;
          var valueNegative = value < 0 || 1 / value < 0;
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
          if (trim2) value = formatTrim(value);
          if (valueNegative && +value === 0 && sign2 !== "+") valueNegative = false;
          valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c2 = value.charCodeAt(i), 48 > c2 || c2 > 57) {
                valueSuffix = (c2 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }
        if (comma && !zero2) value = group2(value, Infinity);
        var length2 = valuePrefix.length + value.length + valueSuffix.length, padding = length2 < width ? new Array(width - length2 + 1).join(fill2) : "";
        if (comma && zero2) value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
        switch (align) {
          case "<":
            value = valuePrefix + value + valueSuffix + padding;
            break;
          case "=":
            value = valuePrefix + padding + value + valueSuffix;
            break;
          case "^":
            value = padding.slice(0, length2 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length2);
            break;
          default:
            value = padding + valuePrefix + value + valueSuffix;
            break;
        }
        return numerals(value);
      }
      format2.toString = function() {
        return specifier + "";
      };
      return format2;
    }
    function formatPrefix2(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix2 = prefixes[8 + e / 3];
      return function(value2) {
        return f(k2 * value2) + prefix2;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix2
    };
  }
  var locale$1;
  var format;
  var formatPrefix;
  defaultLocale$1({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale$1(definition) {
    locale$1 = formatLocale$1(definition);
    format = locale$1.format;
    formatPrefix = locale$1.formatPrefix;
    return locale$1;
  }
  function precisionFixed(step) {
    return Math.max(0, -exponent(Math.abs(step)));
  }
  function precisionPrefix(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
  }
  function precisionRound(step, max2) {
    step = Math.abs(step), max2 = Math.abs(max2) - step;
    return Math.max(0, exponent(max2) - exponent(step)) + 1;
  }
  function tickFormat(start, stop, count2, specifier) {
    var step = tickStep(start, stop, count2), precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }
  function linearish(scale) {
    var domain = scale.domain;
    scale.ticks = function(count2) {
      var d = domain();
      return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
    };
    scale.tickFormat = function(count2, specifier) {
      var d = domain();
      return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
    };
    scale.nice = function(count2) {
      if (count2 == null) count2 = 10;
      var d = domain();
      var i0 = 0;
      var i1 = d.length - 1;
      var start = d[i0];
      var stop = d[i1];
      var prestep;
      var step;
      var maxIter = 10;
      if (stop < start) {
        step = start, start = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }
      while (maxIter-- > 0) {
        step = tickIncrement(start, stop, count2);
        if (step === prestep) {
          d[i0] = start;
          d[i1] = stop;
          return domain(d);
        } else if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
        } else {
          break;
        }
        prestep = step;
      }
      return scale;
    };
    return scale;
  }
  function linear() {
    var scale = continuous();
    scale.copy = function() {
      return copy$1(scale, linear());
    };
    initRange.apply(scale, arguments);
    return linearish(scale);
  }
  function identity$2(domain) {
    var unknown;
    function scale(x2) {
      return x2 == null || isNaN(x2 = +x2) ? unknown : x2;
    }
    scale.invert = scale;
    scale.domain = scale.range = function(_) {
      return arguments.length ? (domain = Array.from(_, number$1), scale) : domain.slice();
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
      return identity$2(domain).unknown(unknown);
    };
    domain = arguments.length ? Array.from(domain, number$1) : [0, 1];
    return linearish(scale);
  }
  function nice(domain, interval) {
    domain = domain.slice();
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
    if (x1 < x0) {
      t = i0, i0 = i1, i1 = t;
      t = x0, x0 = x1, x1 = t;
    }
    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
  }
  function transformLog(x2) {
    return Math.log(x2);
  }
  function transformExp(x2) {
    return Math.exp(x2);
  }
  function transformLogn(x2) {
    return -Math.log(-x2);
  }
  function transformExpn(x2) {
    return -Math.exp(-x2);
  }
  function pow10(x2) {
    return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
  }
  function powp(base) {
    return base === 10 ? pow10 : base === Math.E ? Math.exp : (x2) => Math.pow(base, x2);
  }
  function logp(base) {
    return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x2) => Math.log(x2) / base);
  }
  function reflect(f) {
    return (x2, k2) => -f(-x2, k2);
  }
  function loggish(transform) {
    const scale = transform(transformLog, transformExp);
    const domain = scale.domain;
    let base = 10;
    let logs;
    let pows;
    function rescale() {
      logs = logp(base), pows = powp(base);
      if (domain()[0] < 0) {
        logs = reflect(logs), pows = reflect(pows);
        transform(transformLogn, transformExpn);
      } else {
        transform(transformLog, transformExp);
      }
      return scale;
    }
    scale.base = function(_) {
      return arguments.length ? (base = +_, rescale()) : base;
    };
    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale.ticks = (count2) => {
      const d = domain();
      let u = d[0];
      let v = d[d.length - 1];
      const r2 = v < u;
      if (r2) [u, v] = [v, u];
      let i = logs(u);
      let j = logs(v);
      let k2;
      let t;
      const n = count2 == null ? 10 : +count2;
      let z = [];
      if (!(base % 1) && j - i < n) {
        i = Math.floor(i), j = Math.ceil(j);
        if (u > 0) for (; i <= j; ++i) {
          for (k2 = 1; k2 < base; ++k2) {
            t = i < 0 ? k2 / pows(-i) : k2 * pows(i);
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        }
        else for (; i <= j; ++i) {
          for (k2 = base - 1; k2 >= 1; --k2) {
            t = i > 0 ? k2 / pows(-i) : k2 * pows(i);
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        }
        if (z.length * 2 < n) z = ticks(u, v, n);
      } else {
        z = ticks(i, j, Math.min(j - i, n)).map(pows);
      }
      return r2 ? z.reverse() : z;
    };
    scale.tickFormat = (count2, specifier) => {
      if (count2 == null) count2 = 10;
      if (specifier == null) specifier = base === 10 ? "s" : ",";
      if (typeof specifier !== "function") {
        if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
        specifier = format(specifier);
      }
      if (count2 === Infinity) return specifier;
      const k2 = Math.max(1, base * count2 / scale.ticks().length);
      return (d) => {
        let i = d / pows(Math.round(logs(d)));
        if (i * base < base - 0.5) i *= base;
        return i <= k2 ? specifier(d) : "";
      };
    };
    scale.nice = () => {
      return domain(nice(domain(), {
        floor: (x2) => pows(Math.floor(logs(x2))),
        ceil: (x2) => pows(Math.ceil(logs(x2)))
      }));
    };
    return scale;
  }
  function log() {
    const scale = loggish(transformer$2()).domain([1, 10]);
    scale.copy = () => copy$1(scale, log()).base(scale.base());
    initRange.apply(scale, arguments);
    return scale;
  }
  function transformSymlog(c2) {
    return function(x2) {
      return Math.sign(x2) * Math.log1p(Math.abs(x2 / c2));
    };
  }
  function transformSymexp(c2) {
    return function(x2) {
      return Math.sign(x2) * Math.expm1(Math.abs(x2)) * c2;
    };
  }
  function symlogish(transform) {
    var c2 = 1, scale = transform(transformSymlog(c2), transformSymexp(c2));
    scale.constant = function(_) {
      return arguments.length ? transform(transformSymlog(c2 = +_), transformSymexp(c2)) : c2;
    };
    return linearish(scale);
  }
  function symlog() {
    var scale = symlogish(transformer$2());
    scale.copy = function() {
      return copy$1(scale, symlog()).constant(scale.constant());
    };
    return initRange.apply(scale, arguments);
  }
  function transformPow(exponent2) {
    return function(x2) {
      return x2 < 0 ? -Math.pow(-x2, exponent2) : Math.pow(x2, exponent2);
    };
  }
  function transformSqrt(x2) {
    return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
  }
  function transformSquare(x2) {
    return x2 < 0 ? -x2 * x2 : x2 * x2;
  }
  function powish(transform) {
    var scale = transform(identity$4, identity$4), exponent2 = 1;
    function rescale() {
      return exponent2 === 1 ? transform(identity$4, identity$4) : exponent2 === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent2), transformPow(1 / exponent2));
    }
    scale.exponent = function(_) {
      return arguments.length ? (exponent2 = +_, rescale()) : exponent2;
    };
    return linearish(scale);
  }
  function pow() {
    var scale = powish(transformer$2());
    scale.copy = function() {
      return copy$1(scale, pow()).exponent(scale.exponent());
    };
    initRange.apply(scale, arguments);
    return scale;
  }
  function sqrt() {
    return pow.apply(null, arguments).exponent(0.5);
  }
  function square(x2) {
    return Math.sign(x2) * x2 * x2;
  }
  function unsquare(x2) {
    return Math.sign(x2) * Math.sqrt(Math.abs(x2));
  }
  function radial() {
    var squared = continuous(), range2 = [0, 1], round2 = false, unknown;
    function scale(x2) {
      var y2 = unsquare(squared(x2));
      return isNaN(y2) ? unknown : round2 ? Math.round(y2) : y2;
    }
    scale.invert = function(y2) {
      return squared.invert(square(y2));
    };
    scale.domain = function(_) {
      return arguments.length ? (squared.domain(_), scale) : squared.domain();
    };
    scale.range = function(_) {
      return arguments.length ? (squared.range((range2 = Array.from(_, number$1)).map(square)), scale) : range2.slice();
    };
    scale.rangeRound = function(_) {
      return scale.range(_).round(true);
    };
    scale.round = function(_) {
      return arguments.length ? (round2 = !!_, scale) : round2;
    };
    scale.clamp = function(_) {
      return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
      return radial(squared.domain(), range2).round(round2).clamp(squared.clamp()).unknown(unknown);
    };
    initRange.apply(scale, arguments);
    return linearish(scale);
  }
  function quantile() {
    var domain = [], range2 = [], thresholds = [], unknown;
    function rescale() {
      var i = 0, n = Math.max(1, range2.length);
      thresholds = new Array(n - 1);
      while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
      return scale;
    }
    function scale(x2) {
      return x2 == null || isNaN(x2 = +x2) ? unknown : range2[bisectRight(thresholds, x2)];
    }
    scale.invertExtent = function(y2) {
      var i = range2.indexOf(y2);
      return i < 0 ? [NaN, NaN] : [
        i > 0 ? thresholds[i - 1] : domain[0],
        i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
      ];
    };
    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [];
      for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
      domain.sort(ascending);
      return rescale();
    };
    scale.range = function(_) {
      return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.quantiles = function() {
      return thresholds.slice();
    };
    scale.copy = function() {
      return quantile().domain(domain).range(range2).unknown(unknown);
    };
    return initRange.apply(scale, arguments);
  }
  function quantize() {
    var x0 = 0, x1 = 1, n = 1, domain = [0.5], range2 = [0, 1], unknown;
    function scale(x2) {
      return x2 != null && x2 <= x2 ? range2[bisectRight(domain, x2, 0, n)] : unknown;
    }
    function rescale() {
      var i = -1;
      domain = new Array(n);
      while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
      return scale;
    }
    scale.domain = function(_) {
      return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
    };
    scale.range = function(_) {
      return arguments.length ? (n = (range2 = Array.from(_)).length - 1, rescale()) : range2.slice();
    };
    scale.invertExtent = function(y2) {
      var i = range2.indexOf(y2);
      return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : scale;
    };
    scale.thresholds = function() {
      return domain.slice();
    };
    scale.copy = function() {
      return quantize().domain([x0, x1]).range(range2).unknown(unknown);
    };
    return initRange.apply(linearish(scale), arguments);
  }
  function threshold() {
    var domain = [0.5], range2 = [0, 1], unknown, n = 1;
    function scale(x2) {
      return x2 != null && x2 <= x2 ? range2[bisectRight(domain, x2, 0, n)] : unknown;
    }
    scale.domain = function(_) {
      return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range2.length - 1), scale) : domain.slice();
    };
    scale.range = function(_) {
      return arguments.length ? (range2 = Array.from(_), n = Math.min(domain.length, range2.length - 1), scale) : range2.slice();
    };
    scale.invertExtent = function(y2) {
      var i = range2.indexOf(y2);
      return [domain[i - 1], domain[i]];
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
      return threshold().domain(domain).range(range2).unknown(unknown);
    };
    return initRange.apply(scale, arguments);
  }
  const t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
  function timeInterval(floori, offseti, count2, field) {
    function interval(date2) {
      return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
    }
    interval.floor = (date2) => {
      return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
    };
    interval.ceil = (date2) => {
      return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
    };
    interval.round = (date2) => {
      const d0 = interval(date2), d1 = interval.ceil(date2);
      return date2 - d0 < d1 - date2 ? d0 : d1;
    };
    interval.offset = (date2, step) => {
      return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
    };
    interval.range = (start, stop, step) => {
      const range2 = [];
      start = interval.ceil(start);
      step = step == null ? 1 : Math.floor(step);
      if (!(start < stop) || !(step > 0)) return range2;
      let previous;
      do
        range2.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
      while (previous < start && start < stop);
      return range2;
    };
    interval.filter = (test) => {
      return timeInterval((date2) => {
        if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
      }, (date2, step) => {
        if (date2 >= date2) {
          if (step < 0) while (++step <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
          else while (--step >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
        }
      });
    };
    if (count2) {
      interval.count = (start, end) => {
        t0.setTime(+start), t1.setTime(+end);
        floori(t0), floori(t1);
        return Math.floor(count2(t0, t1));
      };
      interval.every = (step) => {
        step = Math.floor(step);
        return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d) => field(d) % step === 0 : (d) => interval.count(0, d) % step === 0);
      };
    }
    return interval;
  }
  const millisecond = timeInterval(() => {
  }, (date2, step) => {
    date2.setTime(+date2 + step);
  }, (start, end) => {
    return end - start;
  });
  millisecond.every = (k2) => {
    k2 = Math.floor(k2);
    if (!isFinite(k2) || !(k2 > 0)) return null;
    if (!(k2 > 1)) return millisecond;
    return timeInterval((date2) => {
      date2.setTime(Math.floor(date2 / k2) * k2);
    }, (date2, step) => {
      date2.setTime(+date2 + step * k2);
    }, (start, end) => {
      return (end - start) / k2;
    });
  };
  const milliseconds = millisecond.range;
  const durationSecond = 1e3;
  const durationMinute = durationSecond * 60;
  const durationHour = durationMinute * 60;
  const durationDay = durationHour * 24;
  const durationWeek = durationDay * 7;
  const durationMonth = durationDay * 30;
  const durationYear = durationDay * 365;
  const second = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds());
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationSecond);
  }, (start, end) => {
    return (end - start) / durationSecond;
  }, (date2) => {
    return date2.getUTCSeconds();
  });
  const seconds = second.range;
  const timeMinute = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationMinute);
  }, (start, end) => {
    return (end - start) / durationMinute;
  }, (date2) => {
    return date2.getMinutes();
  });
  const timeMinutes = timeMinute.range;
  const utcMinute = timeInterval((date2) => {
    date2.setUTCSeconds(0, 0);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationMinute);
  }, (start, end) => {
    return (end - start) / durationMinute;
  }, (date2) => {
    return date2.getUTCMinutes();
  });
  const utcMinutes = utcMinute.range;
  const timeHour = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationHour);
  }, (start, end) => {
    return (end - start) / durationHour;
  }, (date2) => {
    return date2.getHours();
  });
  const timeHours = timeHour.range;
  const utcHour = timeInterval((date2) => {
    date2.setUTCMinutes(0, 0, 0);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationHour);
  }, (start, end) => {
    return (end - start) / durationHour;
  }, (date2) => {
    return date2.getUTCHours();
  });
  const utcHours = utcHour.range;
  const timeDay = timeInterval(
    (date2) => date2.setHours(0, 0, 0, 0),
    (date2, step) => date2.setDate(date2.getDate() + step),
    (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
    (date2) => date2.getDate() - 1
  );
  const timeDays = timeDay.range;
  const utcDay = timeInterval((date2) => {
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step);
  }, (start, end) => {
    return (end - start) / durationDay;
  }, (date2) => {
    return date2.getUTCDate() - 1;
  });
  const utcDays = utcDay.range;
  const unixDay = timeInterval((date2) => {
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step);
  }, (start, end) => {
    return (end - start) / durationDay;
  }, (date2) => {
    return Math.floor(date2 / durationDay);
  });
  const unixDays = unixDay.range;
  function timeWeekday(i) {
    return timeInterval((date2) => {
      date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setDate(date2.getDate() + step * 7);
    }, (start, end) => {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
    });
  }
  const timeSunday = timeWeekday(0);
  const timeMonday = timeWeekday(1);
  const timeTuesday = timeWeekday(2);
  const timeWednesday = timeWeekday(3);
  const timeThursday = timeWeekday(4);
  const timeFriday = timeWeekday(5);
  const timeSaturday = timeWeekday(6);
  const timeSundays = timeSunday.range;
  const timeMondays = timeMonday.range;
  const timeTuesdays = timeTuesday.range;
  const timeWednesdays = timeWednesday.range;
  const timeThursdays = timeThursday.range;
  const timeFridays = timeFriday.range;
  const timeSaturdays = timeSaturday.range;
  function utcWeekday(i) {
    return timeInterval((date2) => {
      date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCDate(date2.getUTCDate() + step * 7);
    }, (start, end) => {
      return (end - start) / durationWeek;
    });
  }
  const utcSunday = utcWeekday(0);
  const utcMonday = utcWeekday(1);
  const utcTuesday = utcWeekday(2);
  const utcWednesday = utcWeekday(3);
  const utcThursday = utcWeekday(4);
  const utcFriday = utcWeekday(5);
  const utcSaturday = utcWeekday(6);
  const utcSundays = utcSunday.range;
  const utcMondays = utcMonday.range;
  const utcTuesdays = utcTuesday.range;
  const utcWednesdays = utcWednesday.range;
  const utcThursdays = utcThursday.range;
  const utcFridays = utcFriday.range;
  const utcSaturdays = utcSaturday.range;
  const timeMonth = timeInterval((date2) => {
    date2.setDate(1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setMonth(date2.getMonth() + step);
  }, (start, end) => {
    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
  }, (date2) => {
    return date2.getMonth();
  });
  const timeMonths = timeMonth.range;
  const utcMonth = timeInterval((date2) => {
    date2.setUTCDate(1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCMonth(date2.getUTCMonth() + step);
  }, (start, end) => {
    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
  }, (date2) => {
    return date2.getUTCMonth();
  });
  const utcMonths = utcMonth.range;
  const timeYear = timeInterval((date2) => {
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step);
  }, (start, end) => {
    return end.getFullYear() - start.getFullYear();
  }, (date2) => {
    return date2.getFullYear();
  });
  timeYear.every = (k2) => {
    return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
      date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
      date2.setMonth(0, 1);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setFullYear(date2.getFullYear() + step * k2);
    });
  };
  const timeYears = timeYear.range;
  const utcYear = timeInterval((date2) => {
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step);
  }, (start, end) => {
    return end.getUTCFullYear() - start.getUTCFullYear();
  }, (date2) => {
    return date2.getUTCFullYear();
  });
  utcYear.every = (k2) => {
    return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
      date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
      date2.setUTCMonth(0, 1);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
    });
  };
  const utcYears = utcYear.range;
  function ticker(year, month, week, day, hour, minute) {
    const tickIntervals = [
      [second, 1, durationSecond],
      [second, 5, 5 * durationSecond],
      [second, 15, 15 * durationSecond],
      [second, 30, 30 * durationSecond],
      [minute, 1, durationMinute],
      [minute, 5, 5 * durationMinute],
      [minute, 15, 15 * durationMinute],
      [minute, 30, 30 * durationMinute],
      [hour, 1, durationHour],
      [hour, 3, 3 * durationHour],
      [hour, 6, 6 * durationHour],
      [hour, 12, 12 * durationHour],
      [day, 1, durationDay],
      [day, 2, 2 * durationDay],
      [week, 1, durationWeek],
      [month, 1, durationMonth],
      [month, 3, 3 * durationMonth],
      [year, 1, durationYear]
    ];
    function ticks2(start, stop, count2) {
      const reverse2 = stop < start;
      if (reverse2) [start, stop] = [stop, start];
      const interval = count2 && typeof count2.range === "function" ? count2 : tickInterval(start, stop, count2);
      const ticks3 = interval ? interval.range(start, +stop + 1) : [];
      return reverse2 ? ticks3.reverse() : ticks3;
    }
    function tickInterval(start, stop, count2) {
      const target = Math.abs(stop - start) / count2;
      const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
      if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count2));
      if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count2), 1));
      const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
      return t.every(step);
    }
    return [ticks2, tickInterval];
  }
  const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
  const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
  function localDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
      date2.setFullYear(d.y);
      return date2;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
  }
  function utcDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      date2.setUTCFullYear(d.y);
      return date2;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  }
  function newDate(y2, m, d) {
    return { y: y2, m, d, H: 0, M: 0, S: 0, L: 0 };
  }
  function formatLocale(locale2) {
    var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
    var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday,
      "b": formatShortMonth,
      "B": formatMonth,
      "c": null,
      "d": formatDayOfMonth,
      "e": formatDayOfMonth,
      "f": formatMicroseconds,
      "g": formatYearISO,
      "G": formatFullYearISO,
      "H": formatHour24,
      "I": formatHour12,
      "j": formatDayOfYear,
      "L": formatMilliseconds,
      "m": formatMonthNumber,
      "M": formatMinutes,
      "p": formatPeriod,
      "q": formatQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatSeconds,
      "u": formatWeekdayNumberMonday,
      "U": formatWeekNumberSunday,
      "V": formatWeekNumberISO,
      "w": formatWeekdayNumberSunday,
      "W": formatWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatYear,
      "Y": formatFullYear,
      "Z": formatZone,
      "%": formatLiteralPercent
    };
    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth,
      "e": formatUTCDayOfMonth,
      "f": formatUTCMicroseconds,
      "g": formatUTCYearISO,
      "G": formatUTCFullYearISO,
      "H": formatUTCHour24,
      "I": formatUTCHour12,
      "j": formatUTCDayOfYear,
      "L": formatUTCMilliseconds,
      "m": formatUTCMonthNumber,
      "M": formatUTCMinutes,
      "p": formatUTCPeriod,
      "q": formatUTCQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatUTCSeconds,
      "u": formatUTCWeekdayNumberMonday,
      "U": formatUTCWeekNumberSunday,
      "V": formatUTCWeekNumberISO,
      "w": formatUTCWeekdayNumberSunday,
      "W": formatUTCWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatUTCYear,
      "Y": formatUTCFullYear,
      "Z": formatUTCZone,
      "%": formatLiteralPercent
    };
    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth,
      "e": parseDayOfMonth,
      "f": parseMicroseconds,
      "g": parseYear,
      "G": parseFullYear,
      "H": parseHour24,
      "I": parseHour24,
      "j": parseDayOfYear,
      "L": parseMilliseconds,
      "m": parseMonthNumber,
      "M": parseMinutes,
      "p": parsePeriod,
      "q": parseQuarter,
      "Q": parseUnixTimestamp,
      "s": parseUnixTimestampSeconds,
      "S": parseSeconds,
      "u": parseWeekdayNumberMonday,
      "U": parseWeekNumberSunday,
      "V": parseWeekNumberISO,
      "w": parseWeekdayNumberSunday,
      "W": parseWeekNumberMonday,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear,
      "Y": parseFullYear,
      "Z": parseZone,
      "%": parseLiteralPercent
    };
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);
    function newFormat(specifier, formats2) {
      return function(date2) {
        var string2 = [], i = -1, j = 0, n = specifier.length, c2, pad2, format2;
        if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
        while (++i < n) {
          if (specifier.charCodeAt(i) === 37) {
            string2.push(specifier.slice(j, i));
            if ((pad2 = pads[c2 = specifier.charAt(++i)]) != null) c2 = specifier.charAt(++i);
            else pad2 = c2 === "e" ? " " : "0";
            if (format2 = formats2[c2]) c2 = format2(date2, pad2);
            string2.push(c2);
            j = i + 1;
          }
        }
        string2.push(specifier.slice(j, i));
        return string2.join("");
      };
    }
    function newParse(specifier, Z) {
      return function(string2) {
        var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string2 += "", 0), week, day;
        if (i != string2.length) return null;
        if ("Q" in d) return new Date(d.Q);
        if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
        if (Z && !("Z" in d)) d.Z = 0;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        if (d.m === void 0) d.m = "q" in d ? d.q : 0;
        if ("V" in d) {
          if (d.V < 1 || d.V > 53) return null;
          if (!("w" in d)) d.w = 1;
          if ("Z" in d) {
            week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
            week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
            week = utcDay.offset(week, (d.V - 1) * 7);
            d.y = week.getUTCFullYear();
            d.m = week.getUTCMonth();
            d.d = week.getUTCDate() + (d.w + 6) % 7;
          } else {
            week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
            week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
            week = timeDay.offset(week, (d.V - 1) * 7);
            d.y = week.getFullYear();
            d.m = week.getMonth();
            d.d = week.getDate() + (d.w + 6) % 7;
          }
        } else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
          day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
          d.m = 0;
          d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
        }
        if ("Z" in d) {
          d.H += d.Z / 100 | 0;
          d.M += d.Z % 100;
          return utcDate(d);
        }
        return localDate(d);
      };
    }
    function parseSpecifier(d, specifier, string2, j) {
      var i = 0, n = specifier.length, m = string2.length, c2, parse;
      while (i < n) {
        if (j >= m) return -1;
        c2 = specifier.charCodeAt(i++);
        if (c2 === 37) {
          c2 = specifier.charAt(i++);
          parse = parses[c2 in pads ? specifier.charAt(i++) : c2];
          if (!parse || (j = parse(d, string2, j)) < 0) return -1;
        } else if (c2 != string2.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    function parsePeriod(d, string2, i) {
      var n = periodRe.exec(string2.slice(i));
      return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseShortWeekday(d, string2, i) {
      var n = shortWeekdayRe.exec(string2.slice(i));
      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseWeekday(d, string2, i) {
      var n = weekdayRe.exec(string2.slice(i));
      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseShortMonth(d, string2, i) {
      var n = shortMonthRe.exec(string2.slice(i));
      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseMonth(d, string2, i) {
      var n = monthRe.exec(string2.slice(i));
      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseLocaleDateTime(d, string2, i) {
      return parseSpecifier(d, locale_dateTime, string2, i);
    }
    function parseLocaleDate(d, string2, i) {
      return parseSpecifier(d, locale_date, string2, i);
    }
    function parseLocaleTime(d, string2, i) {
      return parseSpecifier(d, locale_time, string2, i);
    }
    function formatShortWeekday(d) {
      return locale_shortWeekdays[d.getDay()];
    }
    function formatWeekday(d) {
      return locale_weekdays[d.getDay()];
    }
    function formatShortMonth(d) {
      return locale_shortMonths[d.getMonth()];
    }
    function formatMonth(d) {
      return locale_months[d.getMonth()];
    }
    function formatPeriod(d) {
      return locale_periods[+(d.getHours() >= 12)];
    }
    function formatQuarter(d) {
      return 1 + ~~(d.getMonth() / 3);
    }
    function formatUTCShortWeekday(d) {
      return locale_shortWeekdays[d.getUTCDay()];
    }
    function formatUTCWeekday(d) {
      return locale_weekdays[d.getUTCDay()];
    }
    function formatUTCShortMonth(d) {
      return locale_shortMonths[d.getUTCMonth()];
    }
    function formatUTCMonth(d) {
      return locale_months[d.getUTCMonth()];
    }
    function formatUTCPeriod(d) {
      return locale_periods[+(d.getUTCHours() >= 12)];
    }
    function formatUTCQuarter(d) {
      return 1 + ~~(d.getUTCMonth() / 3);
    }
    return {
      format: function(specifier) {
        var f = newFormat(specifier += "", formats);
        f.toString = function() {
          return specifier;
        };
        return f;
      },
      parse: function(specifier) {
        var p = newParse(specifier += "", false);
        p.toString = function() {
          return specifier;
        };
        return p;
      },
      utcFormat: function(specifier) {
        var f = newFormat(specifier += "", utcFormats);
        f.toString = function() {
          return specifier;
        };
        return f;
      },
      utcParse: function(specifier) {
        var p = newParse(specifier += "", true);
        p.toString = function() {
          return specifier;
        };
        return p;
      }
    };
  }
  var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
  function pad$1(value, fill2, width) {
    var sign2 = value < 0 ? "-" : "", string2 = (sign2 ? -value : value) + "", length2 = string2.length;
    return sign2 + (length2 < width ? new Array(width - length2 + 1).join(fill2) + string2 : string2);
  }
  function requote(s2) {
    return s2.replace(requoteRe, "\\$&");
  }
  function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
  }
  function formatLookup(names) {
    return new Map(names.map((name, i) => [name.toLowerCase(), i]));
  }
  function parseWeekdayNumberSunday(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 1));
    return n ? (d.w = +n[0], i + n[0].length) : -1;
  }
  function parseWeekdayNumberMonday(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 1));
    return n ? (d.u = +n[0], i + n[0].length) : -1;
  }
  function parseWeekNumberSunday(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 2));
    return n ? (d.U = +n[0], i + n[0].length) : -1;
  }
  function parseWeekNumberISO(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 2));
    return n ? (d.V = +n[0], i + n[0].length) : -1;
  }
  function parseWeekNumberMonday(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 2));
    return n ? (d.W = +n[0], i + n[0].length) : -1;
  }
  function parseFullYear(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 4));
    return n ? (d.y = +n[0], i + n[0].length) : -1;
  }
  function parseYear(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 2));
    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
  }
  function parseZone(d, string2, i) {
    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i, i + 6));
    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
  }
  function parseQuarter(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 1));
    return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
  }
  function parseMonthNumber(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 2));
    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
  }
  function parseDayOfMonth(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 2));
    return n ? (d.d = +n[0], i + n[0].length) : -1;
  }
  function parseDayOfYear(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 3));
    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
  }
  function parseHour24(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 2));
    return n ? (d.H = +n[0], i + n[0].length) : -1;
  }
  function parseMinutes(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 2));
    return n ? (d.M = +n[0], i + n[0].length) : -1;
  }
  function parseSeconds(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 2));
    return n ? (d.S = +n[0], i + n[0].length) : -1;
  }
  function parseMilliseconds(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 3));
    return n ? (d.L = +n[0], i + n[0].length) : -1;
  }
  function parseMicroseconds(d, string2, i) {
    var n = numberRe.exec(string2.slice(i, i + 6));
    return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
  }
  function parseLiteralPercent(d, string2, i) {
    var n = percentRe.exec(string2.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function parseUnixTimestamp(d, string2, i) {
    var n = numberRe.exec(string2.slice(i));
    return n ? (d.Q = +n[0], i + n[0].length) : -1;
  }
  function parseUnixTimestampSeconds(d, string2, i) {
    var n = numberRe.exec(string2.slice(i));
    return n ? (d.s = +n[0], i + n[0].length) : -1;
  }
  function formatDayOfMonth(d, p) {
    return pad$1(d.getDate(), p, 2);
  }
  function formatHour24(d, p) {
    return pad$1(d.getHours(), p, 2);
  }
  function formatHour12(d, p) {
    return pad$1(d.getHours() % 12 || 12, p, 2);
  }
  function formatDayOfYear(d, p) {
    return pad$1(1 + timeDay.count(timeYear(d), d), p, 3);
  }
  function formatMilliseconds(d, p) {
    return pad$1(d.getMilliseconds(), p, 3);
  }
  function formatMicroseconds(d, p) {
    return formatMilliseconds(d, p) + "000";
  }
  function formatMonthNumber(d, p) {
    return pad$1(d.getMonth() + 1, p, 2);
  }
  function formatMinutes(d, p) {
    return pad$1(d.getMinutes(), p, 2);
  }
  function formatSeconds(d, p) {
    return pad$1(d.getSeconds(), p, 2);
  }
  function formatWeekdayNumberMonday(d) {
    var day = d.getDay();
    return day === 0 ? 7 : day;
  }
  function formatWeekNumberSunday(d, p) {
    return pad$1(timeSunday.count(timeYear(d) - 1, d), p, 2);
  }
  function dISO(d) {
    var day = d.getDay();
    return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  }
  function formatWeekNumberISO(d, p) {
    d = dISO(d);
    return pad$1(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
  }
  function formatWeekdayNumberSunday(d) {
    return d.getDay();
  }
  function formatWeekNumberMonday(d, p) {
    return pad$1(timeMonday.count(timeYear(d) - 1, d), p, 2);
  }
  function formatYear(d, p) {
    return pad$1(d.getFullYear() % 100, p, 2);
  }
  function formatYearISO(d, p) {
    d = dISO(d);
    return pad$1(d.getFullYear() % 100, p, 2);
  }
  function formatFullYear(d, p) {
    return pad$1(d.getFullYear() % 1e4, p, 4);
  }
  function formatFullYearISO(d, p) {
    var day = d.getDay();
    d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
    return pad$1(d.getFullYear() % 1e4, p, 4);
  }
  function formatZone(d) {
    var z = d.getTimezoneOffset();
    return (z > 0 ? "-" : (z *= -1, "+")) + pad$1(z / 60 | 0, "0", 2) + pad$1(z % 60, "0", 2);
  }
  function formatUTCDayOfMonth(d, p) {
    return pad$1(d.getUTCDate(), p, 2);
  }
  function formatUTCHour24(d, p) {
    return pad$1(d.getUTCHours(), p, 2);
  }
  function formatUTCHour12(d, p) {
    return pad$1(d.getUTCHours() % 12 || 12, p, 2);
  }
  function formatUTCDayOfYear(d, p) {
    return pad$1(1 + utcDay.count(utcYear(d), d), p, 3);
  }
  function formatUTCMilliseconds(d, p) {
    return pad$1(d.getUTCMilliseconds(), p, 3);
  }
  function formatUTCMicroseconds(d, p) {
    return formatUTCMilliseconds(d, p) + "000";
  }
  function formatUTCMonthNumber(d, p) {
    return pad$1(d.getUTCMonth() + 1, p, 2);
  }
  function formatUTCMinutes(d, p) {
    return pad$1(d.getUTCMinutes(), p, 2);
  }
  function formatUTCSeconds(d, p) {
    return pad$1(d.getUTCSeconds(), p, 2);
  }
  function formatUTCWeekdayNumberMonday(d) {
    var dow = d.getUTCDay();
    return dow === 0 ? 7 : dow;
  }
  function formatUTCWeekNumberSunday(d, p) {
    return pad$1(utcSunday.count(utcYear(d) - 1, d), p, 2);
  }
  function UTCdISO(d) {
    var day = d.getUTCDay();
    return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  }
  function formatUTCWeekNumberISO(d, p) {
    d = UTCdISO(d);
    return pad$1(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
  }
  function formatUTCWeekdayNumberSunday(d) {
    return d.getUTCDay();
  }
  function formatUTCWeekNumberMonday(d, p) {
    return pad$1(utcMonday.count(utcYear(d) - 1, d), p, 2);
  }
  function formatUTCYear(d, p) {
    return pad$1(d.getUTCFullYear() % 100, p, 2);
  }
  function formatUTCYearISO(d, p) {
    d = UTCdISO(d);
    return pad$1(d.getUTCFullYear() % 100, p, 2);
  }
  function formatUTCFullYear(d, p) {
    return pad$1(d.getUTCFullYear() % 1e4, p, 4);
  }
  function formatUTCFullYearISO(d, p) {
    var day = d.getUTCDay();
    d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
    return pad$1(d.getUTCFullYear() % 1e4, p, 4);
  }
  function formatUTCZone() {
    return "+0000";
  }
  function formatLiteralPercent() {
    return "%";
  }
  function formatUnixTimestamp(d) {
    return +d;
  }
  function formatUnixTimestampSeconds(d) {
    return Math.floor(+d / 1e3);
  }
  var locale;
  var timeFormat;
  var timeParse;
  var utcFormat;
  var utcParse;
  defaultLocale({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });
  function defaultLocale(definition) {
    locale = formatLocale(definition);
    timeFormat = locale.format;
    timeParse = locale.parse;
    utcFormat = locale.utcFormat;
    utcParse = locale.utcParse;
    return locale;
  }
  var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
  function formatIsoNative(date2) {
    return date2.toISOString();
  }
  var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);
  function parseIsoNative(string2) {
    var date2 = new Date(string2);
    return isNaN(date2) ? null : date2;
  }
  var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);
  function date(t) {
    return new Date(t);
  }
  function number(t) {
    return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
  }
  function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
    var scale = continuous(), invert2 = scale.invert, domain = scale.domain;
    var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
    function tickFormat2(date2) {
      return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
    }
    scale.invert = function(y2) {
      return new Date(invert2(y2));
    };
    scale.domain = function(_) {
      return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
    };
    scale.ticks = function(interval) {
      var d = domain();
      return ticks2(d[0], d[d.length - 1], interval == null ? 10 : interval);
    };
    scale.tickFormat = function(count2, specifier) {
      return specifier == null ? tickFormat2 : format2(specifier);
    };
    scale.nice = function(interval) {
      var d = domain();
      if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
      return interval ? domain(nice(d, interval)) : scale;
    };
    scale.copy = function() {
      return copy$1(scale, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
    };
    return scale;
  }
  function time() {
    return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
  }
  function utcTime() {
    return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
  }
  function transformer$1() {
    var x0 = 0, x1 = 1, t02, t12, k10, transform, interpolator = identity$4, clamp2 = false, unknown;
    function scale(x2) {
      return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform(x2) - t02) * k10, clamp2 ? Math.max(0, Math.min(1, x2)) : x2));
    }
    scale.domain = function(_) {
      return arguments.length ? ([x0, x1] = _, t02 = transform(x0 = +x0), t12 = transform(x1 = +x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale) : [x0, x1];
    };
    scale.clamp = function(_) {
      return arguments.length ? (clamp2 = !!_, scale) : clamp2;
    };
    scale.interpolator = function(_) {
      return arguments.length ? (interpolator = _, scale) : interpolator;
    };
    function range2(interpolate2) {
      return function(_) {
        var r0, r1;
        return arguments.length ? ([r0, r1] = _, interpolator = interpolate2(r0, r1), scale) : [interpolator(0), interpolator(1)];
      };
    }
    scale.range = range2(interpolate);
    scale.rangeRound = range2(interpolateRound);
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function(t) {
      transform = t, t02 = t(x0), t12 = t(x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
      return scale;
    };
  }
  function copy(source, target) {
    return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
  }
  function sequential() {
    var scale = linearish(transformer$1()(identity$4));
    scale.copy = function() {
      return copy(scale, sequential());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function sequentialLog() {
    var scale = loggish(transformer$1()).domain([1, 10]);
    scale.copy = function() {
      return copy(scale, sequentialLog()).base(scale.base());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function sequentialSymlog() {
    var scale = symlogish(transformer$1());
    scale.copy = function() {
      return copy(scale, sequentialSymlog()).constant(scale.constant());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function sequentialPow() {
    var scale = powish(transformer$1());
    scale.copy = function() {
      return copy(scale, sequentialPow()).exponent(scale.exponent());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function sequentialSqrt() {
    return sequentialPow.apply(null, arguments).exponent(0.5);
  }
  function sequentialQuantile() {
    var domain = [], interpolator = identity$4;
    function scale(x2) {
      if (x2 != null && !isNaN(x2 = +x2)) return interpolator((bisectRight(domain, x2, 1) - 1) / (domain.length - 1));
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [];
      for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
      domain.sort(ascending);
      return scale;
    };
    scale.interpolator = function(_) {
      return arguments.length ? (interpolator = _, scale) : interpolator;
    };
    scale.range = function() {
      return domain.map((d, i) => interpolator(i / (domain.length - 1)));
    };
    scale.quantiles = function(n) {
      return Array.from({ length: n + 1 }, (_, i) => quantile$1(domain, i / n));
    };
    scale.copy = function() {
      return sequentialQuantile(interpolator).domain(domain);
    };
    return initInterpolator.apply(scale, arguments);
  }
  function transformer() {
    var x0 = 0, x1 = 0.5, x2 = 1, s2 = 1, t02, t12, t22, k10, k21, interpolator = identity$4, transform, clamp2 = false, unknown;
    function scale(x3) {
      return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform(x3)) - t12) * (s2 * x3 < s2 * t12 ? k10 : k21), interpolator(clamp2 ? Math.max(0, Math.min(1, x3)) : x3));
    }
    scale.domain = function(_) {
      return arguments.length ? ([x0, x1, x2] = _, t02 = transform(x0 = +x0), t12 = transform(x1 = +x1), t22 = transform(x2 = +x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t22 ? 0 : 0.5 / (t22 - t12), s2 = t12 < t02 ? -1 : 1, scale) : [x0, x1, x2];
    };
    scale.clamp = function(_) {
      return arguments.length ? (clamp2 = !!_, scale) : clamp2;
    };
    scale.interpolator = function(_) {
      return arguments.length ? (interpolator = _, scale) : interpolator;
    };
    function range2(interpolate2) {
      return function(_) {
        var r0, r1, r2;
        return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate2, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
      };
    }
    scale.range = range2(interpolate);
    scale.rangeRound = range2(interpolateRound);
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function(t) {
      transform = t, t02 = t(x0), t12 = t(x1), t22 = t(x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t22 ? 0 : 0.5 / (t22 - t12), s2 = t12 < t02 ? -1 : 1;
      return scale;
    };
  }
  function diverging() {
    var scale = linearish(transformer()(identity$4));
    scale.copy = function() {
      return copy(scale, diverging());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function divergingLog() {
    var scale = loggish(transformer()).domain([0.1, 1, 10]);
    scale.copy = function() {
      return copy(scale, divergingLog()).base(scale.base());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function divergingSymlog() {
    var scale = symlogish(transformer());
    scale.copy = function() {
      return copy(scale, divergingSymlog()).constant(scale.constant());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function divergingPow() {
    var scale = powish(transformer());
    scale.copy = function() {
      return copy(scale, divergingPow()).exponent(scale.exponent());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function divergingSqrt() {
    return divergingPow.apply(null, arguments).exponent(0.5);
  }
  const d3Scales = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    scaleBand: band,
    scaleDiverging: diverging,
    scaleDivergingLog: divergingLog,
    scaleDivergingPow: divergingPow,
    scaleDivergingSqrt: divergingSqrt,
    scaleDivergingSymlog: divergingSymlog,
    scaleIdentity: identity$2,
    scaleImplicit: implicit,
    scaleLinear: linear,
    scaleLog: log,
    scaleOrdinal: ordinal,
    scalePoint: point,
    scalePow: pow,
    scaleQuantile: quantile,
    scaleQuantize: quantize,
    scaleRadial: radial,
    scaleSequential: sequential,
    scaleSequentialLog: sequentialLog,
    scaleSequentialPow: sequentialPow,
    scaleSequentialQuantile: sequentialQuantile,
    scaleSequentialSqrt: sequentialSqrt,
    scaleSequentialSymlog: sequentialSymlog,
    scaleSqrt: sqrt,
    scaleSymlog: symlog,
    scaleThreshold: threshold,
    scaleTime: time,
    scaleUtc: utcTime,
    tickFormat
  }, Symbol.toStringTag, { value: "Module" }));
  var selectChartDataWithIndexes = (state) => state.chartData;
  var selectChartDataAndAlwaysIgnoreIndexes = createSelector([selectChartDataWithIndexes], (dataState) => {
    var dataEndIndex = dataState.chartData != null ? dataState.chartData.length - 1 : 0;
    return {
      chartData: dataState.chartData,
      computedData: dataState.computedData,
      dataEndIndex,
      dataStartIndex: 0
    };
  });
  var selectChartDataWithIndexesIfNotInPanorama = (state, _unused1, _unused2, isPanorama) => {
    if (isPanorama) {
      return selectChartDataAndAlwaysIgnoreIndexes(state);
    }
    return selectChartDataWithIndexes(state);
  };
  function isWellFormedNumberDomain(v) {
    if (Array.isArray(v) && v.length === 2) {
      var [min2, max2] = v;
      if (isWellBehavedNumber(min2) && isWellBehavedNumber(max2)) {
        return true;
      }
    }
    return false;
  }
  function extendDomain(providedDomain, boundaryDomain, allowDataOverflow) {
    if (allowDataOverflow) {
      return providedDomain;
    }
    return [Math.min(providedDomain[0], boundaryDomain[0]), Math.max(providedDomain[1], boundaryDomain[1])];
  }
  function numericalDomainSpecifiedWithoutRequiringData(userDomain, allowDataOverflow) {
    if (!allowDataOverflow) {
      return void 0;
    }
    if (typeof userDomain === "function") {
      return void 0;
    }
    if (Array.isArray(userDomain) && userDomain.length === 2) {
      var [providedMin, providedMax] = userDomain;
      var finalMin, finalMax;
      if (isWellBehavedNumber(providedMin)) {
        finalMin = providedMin;
      } else if (typeof providedMin === "function") {
        return void 0;
      }
      if (isWellBehavedNumber(providedMax)) {
        finalMax = providedMax;
      } else if (typeof providedMax === "function") {
        return void 0;
      }
      var candidate = [finalMin, finalMax];
      if (isWellFormedNumberDomain(candidate)) {
        return candidate;
      }
    }
    return void 0;
  }
  function parseNumericalUserDomain(userDomain, dataDomain, allowDataOverflow) {
    if (!allowDataOverflow && dataDomain == null) {
      return void 0;
    }
    if (typeof userDomain === "function" && dataDomain != null) {
      try {
        var result = userDomain(dataDomain, allowDataOverflow);
        if (isWellFormedNumberDomain(result)) {
          return extendDomain(result, dataDomain, allowDataOverflow);
        }
      } catch (_unused) {
      }
    }
    if (Array.isArray(userDomain) && userDomain.length === 2) {
      var [providedMin, providedMax] = userDomain;
      var finalMin, finalMax;
      if (providedMin === "auto") {
        if (dataDomain != null) {
          finalMin = Math.min(...dataDomain);
        }
      } else if (isNumber(providedMin)) {
        finalMin = providedMin;
      } else if (typeof providedMin === "function") {
        try {
          if (dataDomain != null) {
            finalMin = providedMin(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0]);
          }
        } catch (_unused2) {
        }
      } else if (typeof providedMin === "string" && MIN_VALUE_REG.test(providedMin)) {
        var match = MIN_VALUE_REG.exec(providedMin);
        if (match == null || dataDomain == null) {
          finalMin = void 0;
        } else {
          var value = +match[1];
          finalMin = dataDomain[0] - value;
        }
      } else {
        finalMin = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0];
      }
      if (providedMax === "auto") {
        if (dataDomain != null) {
          finalMax = Math.max(...dataDomain);
        }
      } else if (isNumber(providedMax)) {
        finalMax = providedMax;
      } else if (typeof providedMax === "function") {
        try {
          if (dataDomain != null) {
            finalMax = providedMax(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1]);
          }
        } catch (_unused3) {
        }
      } else if (typeof providedMax === "string" && MAX_VALUE_REG.test(providedMax)) {
        var _match = MAX_VALUE_REG.exec(providedMax);
        if (_match == null || dataDomain == null) {
          finalMax = void 0;
        } else {
          var _value = +_match[1];
          finalMax = dataDomain[1] + _value;
        }
      } else {
        finalMax = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1];
      }
      var candidate = [finalMin, finalMax];
      if (isWellFormedNumberDomain(candidate)) {
        if (dataDomain == null) {
          return candidate;
        }
        return extendDomain(candidate, dataDomain, allowDataOverflow);
      }
    }
    return void 0;
  }
  var MAX_DIGITS = 1e9, defaults = {
    // These values must be integers within the stated ranges (inclusive).
    // Most of these values can be changed during run-time using `Decimal.config`.
    // The maximum number of significant digits of the result of a calculation or base conversion.
    // E.g. `Decimal.config({ precision: 20 });`
    precision: 20,
    // 1 to MAX_DIGITS
    // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
    // `toFixed`, `toPrecision` and `toSignificantDigits`.
    //
    // ROUND_UP         0 Away from zero.
    // ROUND_DOWN       1 Towards zero.
    // ROUND_CEIL       2 Towards +Infinity.
    // ROUND_FLOOR      3 Towards -Infinity.
    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    //
    // E.g.
    // `Decimal.rounding = 4;`
    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
    rounding: 4,
    // 0 to 8
    // The exponent value at and beneath which `toString` returns exponential notation.
    // JavaScript numbers: -7
    toExpNeg: -7,
    // 0 to -MAX_E
    // The exponent value at and above which `toString` returns exponential notation.
    // JavaScript numbers: 21
    toExpPos: 21,
    // 0 to MAX_E
    // The natural logarithm of 10.
    // 115 digits
    LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
  }, Decimal, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", exponentOutOfRange = decimalError + "Exponent out of range: ", mathfloor = Math.floor, mathpow = Math.pow, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE), P = {};
  P.absoluteValue = P.abs = function() {
    var x2 = new this.constructor(this);
    if (x2.s) x2.s = 1;
    return x2;
  };
  P.comparedTo = P.cmp = function(y2) {
    var i, j, xdL, ydL, x2 = this;
    y2 = new x2.constructor(y2);
    if (x2.s !== y2.s) return x2.s || -y2.s;
    if (x2.e !== y2.e) return x2.e > y2.e ^ x2.s < 0 ? 1 : -1;
    xdL = x2.d.length;
    ydL = y2.d.length;
    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
      if (x2.d[i] !== y2.d[i]) return x2.d[i] > y2.d[i] ^ x2.s < 0 ? 1 : -1;
    }
    return xdL === ydL ? 0 : xdL > ydL ^ x2.s < 0 ? 1 : -1;
  };
  P.decimalPlaces = P.dp = function() {
    var x2 = this, w = x2.d.length - 1, dp = (w - x2.e) * LOG_BASE;
    w = x2.d[w];
    if (w) for (; w % 10 == 0; w /= 10) dp--;
    return dp < 0 ? 0 : dp;
  };
  P.dividedBy = P.div = function(y2) {
    return divide(this, new this.constructor(y2));
  };
  P.dividedToIntegerBy = P.idiv = function(y2) {
    var x2 = this, Ctor = x2.constructor;
    return round$1(divide(x2, new Ctor(y2), 0, 1), Ctor.precision);
  };
  P.equals = P.eq = function(y2) {
    return !this.cmp(y2);
  };
  P.exponent = function() {
    return getBase10Exponent(this);
  };
  P.greaterThan = P.gt = function(y2) {
    return this.cmp(y2) > 0;
  };
  P.greaterThanOrEqualTo = P.gte = function(y2) {
    return this.cmp(y2) >= 0;
  };
  P.isInteger = P.isint = function() {
    return this.e > this.d.length - 2;
  };
  P.isNegative = P.isneg = function() {
    return this.s < 0;
  };
  P.isPositive = P.ispos = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return this.s === 0;
  };
  P.lessThan = P.lt = function(y2) {
    return this.cmp(y2) < 0;
  };
  P.lessThanOrEqualTo = P.lte = function(y2) {
    return this.cmp(y2) < 1;
  };
  P.logarithm = P.log = function(base) {
    var r2, x2 = this, Ctor = x2.constructor, pr = Ctor.precision, wpr = pr + 5;
    if (base === void 0) {
      base = new Ctor(10);
    } else {
      base = new Ctor(base);
      if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + "NaN");
    }
    if (x2.s < 1) throw Error(decimalError + (x2.s ? "NaN" : "-Infinity"));
    if (x2.eq(ONE)) return new Ctor(0);
    external = false;
    r2 = divide(ln(x2, wpr), ln(base, wpr), wpr);
    external = true;
    return round$1(r2, pr);
  };
  P.minus = P.sub = function(y2) {
    var x2 = this;
    y2 = new x2.constructor(y2);
    return x2.s == y2.s ? subtract(x2, y2) : add(x2, (y2.s = -y2.s, y2));
  };
  P.modulo = P.mod = function(y2) {
    var q, x2 = this, Ctor = x2.constructor, pr = Ctor.precision;
    y2 = new Ctor(y2);
    if (!y2.s) throw Error(decimalError + "NaN");
    if (!x2.s) return round$1(new Ctor(x2), pr);
    external = false;
    q = divide(x2, y2, 0, 1).times(y2);
    external = true;
    return x2.minus(q);
  };
  P.naturalExponential = P.exp = function() {
    return exp(this);
  };
  P.naturalLogarithm = P.ln = function() {
    return ln(this);
  };
  P.negated = P.neg = function() {
    var x2 = new this.constructor(this);
    x2.s = -x2.s || 0;
    return x2;
  };
  P.plus = P.add = function(y2) {
    var x2 = this;
    y2 = new x2.constructor(y2);
    return x2.s == y2.s ? add(x2, y2) : subtract(x2, (y2.s = -y2.s, y2));
  };
  P.precision = P.sd = function(z) {
    var e, sd, w, x2 = this;
    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
    e = getBase10Exponent(x2) + 1;
    w = x2.d.length - 1;
    sd = w * LOG_BASE + 1;
    w = x2.d[w];
    if (w) {
      for (; w % 10 == 0; w /= 10) sd--;
      for (w = x2.d[0]; w >= 10; w /= 10) sd++;
    }
    return z && e > sd ? e : sd;
  };
  P.squareRoot = P.sqrt = function() {
    var e, n, pr, r2, s2, t, wpr, x2 = this, Ctor = x2.constructor;
    if (x2.s < 1) {
      if (!x2.s) return new Ctor(0);
      throw Error(decimalError + "NaN");
    }
    e = getBase10Exponent(x2);
    external = false;
    s2 = Math.sqrt(+x2);
    if (s2 == 0 || s2 == 1 / 0) {
      n = digitsToString(x2.d);
      if ((n.length + e) % 2 == 0) n += "0";
      s2 = Math.sqrt(n);
      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s2 == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s2.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r2 = new Ctor(n);
    } else {
      r2 = new Ctor(s2.toString());
    }
    pr = Ctor.precision;
    s2 = wpr = pr + 3;
    for (; ; ) {
      t = r2;
      r2 = t.plus(divide(x2, t, wpr + 2)).times(0.5);
      if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r2.d)).slice(0, wpr)) {
        n = n.slice(wpr - 3, wpr + 1);
        if (s2 == wpr && n == "4999") {
          round$1(t, pr + 1, 0);
          if (t.times(t).eq(x2)) {
            r2 = t;
            break;
          }
        } else if (n != "9999") {
          break;
        }
        wpr += 4;
      }
    }
    external = true;
    return round$1(r2, pr);
  };
  P.times = P.mul = function(y2) {
    var carry, e, i, k2, r2, rL, t, xdL, ydL, x2 = this, Ctor = x2.constructor, xd = x2.d, yd = (y2 = new Ctor(y2)).d;
    if (!x2.s || !y2.s) return new Ctor(0);
    y2.s *= x2.s;
    e = x2.e + y2.e;
    xdL = xd.length;
    ydL = yd.length;
    if (xdL < ydL) {
      r2 = xd;
      xd = yd;
      yd = r2;
      rL = xdL;
      xdL = ydL;
      ydL = rL;
    }
    r2 = [];
    rL = xdL + ydL;
    for (i = rL; i--; ) r2.push(0);
    for (i = ydL; --i >= 0; ) {
      carry = 0;
      for (k2 = xdL + i; k2 > i; ) {
        t = r2[k2] + yd[i] * xd[k2 - i - 1] + carry;
        r2[k2--] = t % BASE | 0;
        carry = t / BASE | 0;
      }
      r2[k2] = (r2[k2] + carry) % BASE | 0;
    }
    for (; !r2[--rL]; ) r2.pop();
    if (carry) ++e;
    else r2.shift();
    y2.d = r2;
    y2.e = e;
    return external ? round$1(y2, Ctor.precision) : y2;
  };
  P.toDecimalPlaces = P.todp = function(dp, rm) {
    var x2 = this, Ctor = x2.constructor;
    x2 = new Ctor(x2);
    if (dp === void 0) return x2;
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    return round$1(x2, dp + getBase10Exponent(x2) + 1, rm);
  };
  P.toExponential = function(dp, rm) {
    var str, x2 = this, Ctor = x2.constructor;
    if (dp === void 0) {
      str = toString(x2, true);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
      x2 = round$1(new Ctor(x2), dp + 1, rm);
      str = toString(x2, true, dp + 1);
    }
    return str;
  };
  P.toFixed = function(dp, rm) {
    var str, y2, x2 = this, Ctor = x2.constructor;
    if (dp === void 0) return toString(x2);
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    y2 = round$1(new Ctor(x2), dp + getBase10Exponent(x2) + 1, rm);
    str = toString(y2.abs(), false, dp + getBase10Exponent(y2) + 1);
    return x2.isneg() && !x2.isZero() ? "-" + str : str;
  };
  P.toInteger = P.toint = function() {
    var x2 = this, Ctor = x2.constructor;
    return round$1(new Ctor(x2), getBase10Exponent(x2) + 1, Ctor.rounding);
  };
  P.toNumber = function() {
    return +this;
  };
  P.toPower = P.pow = function(y2) {
    var e, k2, pr, r2, sign2, yIsInt, x2 = this, Ctor = x2.constructor, guard = 12, yn = +(y2 = new Ctor(y2));
    if (!y2.s) return new Ctor(ONE);
    x2 = new Ctor(x2);
    if (!x2.s) {
      if (y2.s < 1) throw Error(decimalError + "Infinity");
      return x2;
    }
    if (x2.eq(ONE)) return x2;
    pr = Ctor.precision;
    if (y2.eq(ONE)) return round$1(x2, pr);
    e = y2.e;
    k2 = y2.d.length - 1;
    yIsInt = e >= k2;
    sign2 = x2.s;
    if (!yIsInt) {
      if (sign2 < 0) throw Error(decimalError + "NaN");
    } else if ((k2 = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
      r2 = new Ctor(ONE);
      e = Math.ceil(pr / LOG_BASE + 4);
      external = false;
      for (; ; ) {
        if (k2 % 2) {
          r2 = r2.times(x2);
          truncate(r2.d, e);
        }
        k2 = mathfloor(k2 / 2);
        if (k2 === 0) break;
        x2 = x2.times(x2);
        truncate(x2.d, e);
      }
      external = true;
      return y2.s < 0 ? new Ctor(ONE).div(r2) : round$1(r2, pr);
    }
    sign2 = sign2 < 0 && y2.d[Math.max(e, k2)] & 1 ? -1 : 1;
    x2.s = 1;
    external = false;
    r2 = y2.times(ln(x2, pr + guard));
    external = true;
    r2 = exp(r2);
    r2.s = sign2;
    return r2;
  };
  P.toPrecision = function(sd, rm) {
    var e, str, x2 = this, Ctor = x2.constructor;
    if (sd === void 0) {
      e = getBase10Exponent(x2);
      str = toString(x2, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
    } else {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
      x2 = round$1(new Ctor(x2), sd, rm);
      e = getBase10Exponent(x2);
      str = toString(x2, sd <= e || e <= Ctor.toExpNeg, sd);
    }
    return str;
  };
  P.toSignificantDigits = P.tosd = function(sd, rm) {
    var x2 = this, Ctor = x2.constructor;
    if (sd === void 0) {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    } else {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
    }
    return round$1(new Ctor(x2), sd, rm);
  };
  P.toString = P.valueOf = P.val = P.toJSON = P[Symbol.for("nodejs.util.inspect.custom")] = function() {
    var x2 = this, e = getBase10Exponent(x2), Ctor = x2.constructor;
    return toString(x2, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
  };
  function add(x2, y2) {
    var carry, d, e, i, k2, len, xd, yd, Ctor = x2.constructor, pr = Ctor.precision;
    if (!x2.s || !y2.s) {
      if (!y2.s) y2 = new Ctor(x2);
      return external ? round$1(y2, pr) : y2;
    }
    xd = x2.d;
    yd = y2.d;
    k2 = x2.e;
    e = y2.e;
    xd = xd.slice();
    i = k2 - e;
    if (i) {
      if (i < 0) {
        d = xd;
        i = -i;
        len = yd.length;
      } else {
        d = yd;
        e = k2;
        len = xd.length;
      }
      k2 = Math.ceil(pr / LOG_BASE);
      len = k2 > len ? k2 + 1 : len + 1;
      if (i > len) {
        i = len;
        d.length = 1;
      }
      d.reverse();
      for (; i--; ) d.push(0);
      d.reverse();
    }
    len = xd.length;
    i = yd.length;
    if (len - i < 0) {
      i = len;
      d = yd;
      yd = xd;
      xd = d;
    }
    for (carry = 0; i; ) {
      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
      xd[i] %= BASE;
    }
    if (carry) {
      xd.unshift(carry);
      ++e;
    }
    for (len = xd.length; xd[--len] == 0; ) xd.pop();
    y2.d = xd;
    y2.e = e;
    return external ? round$1(y2, pr) : y2;
  }
  function checkInt32(i, min2, max2) {
    if (i !== ~~i || i < min2 || i > max2) {
      throw Error(invalidArgument + i);
    }
  }
  function digitsToString(d) {
    var i, k2, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
    if (indexOfLastWord > 0) {
      str += w;
      for (i = 1; i < indexOfLastWord; i++) {
        ws = d[i] + "";
        k2 = LOG_BASE - ws.length;
        if (k2) str += getZeroString(k2);
        str += ws;
      }
      w = d[i];
      ws = w + "";
      k2 = LOG_BASE - ws.length;
      if (k2) str += getZeroString(k2);
    } else if (w === 0) {
      return "0";
    }
    for (; w % 10 === 0; ) w /= 10;
    return str + w;
  }
  var divide = /* @__PURE__ */ function() {
    function multiplyInteger(x2, k2) {
      var temp, carry = 0, i = x2.length;
      for (x2 = x2.slice(); i--; ) {
        temp = x2[i] * k2 + carry;
        x2[i] = temp % BASE | 0;
        carry = temp / BASE | 0;
      }
      if (carry) x2.unshift(carry);
      return x2;
    }
    function compare(a2, b, aL, bL) {
      var i, r2;
      if (aL != bL) {
        r2 = aL > bL ? 1 : -1;
      } else {
        for (i = r2 = 0; i < aL; i++) {
          if (a2[i] != b[i]) {
            r2 = a2[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return r2;
    }
    function subtract2(a2, b, aL) {
      var i = 0;
      for (; aL--; ) {
        a2[aL] -= i;
        i = a2[aL] < b[aL] ? 1 : 0;
        a2[aL] = i * BASE + a2[aL] - b[aL];
      }
      for (; !a2[0] && a2.length > 1; ) a2.shift();
    }
    return function(x2, y2, pr, dp) {
      var cmp, e, i, k2, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x2.constructor, sign2 = x2.s == y2.s ? 1 : -1, xd = x2.d, yd = y2.d;
      if (!x2.s) return new Ctor(x2);
      if (!y2.s) throw Error(decimalError + "Division by zero");
      e = x2.e - y2.e;
      yL = yd.length;
      xL = xd.length;
      q = new Ctor(sign2);
      qd = q.d = [];
      for (i = 0; yd[i] == (xd[i] || 0); ) ++i;
      if (yd[i] > (xd[i] || 0)) --e;
      if (pr == null) {
        sd = pr = Ctor.precision;
      } else if (dp) {
        sd = pr + (getBase10Exponent(x2) - getBase10Exponent(y2)) + 1;
      } else {
        sd = pr;
      }
      if (sd < 0) return new Ctor(0);
      sd = sd / LOG_BASE + 2 | 0;
      i = 0;
      if (yL == 1) {
        k2 = 0;
        yd = yd[0];
        sd++;
        for (; (i < xL || k2) && sd--; i++) {
          t = k2 * BASE + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k2 = t % yd | 0;
        }
      } else {
        k2 = BASE / (yd[0] + 1) | 0;
        if (k2 > 1) {
          yd = multiplyInteger(yd, k2);
          xd = multiplyInteger(xd, k2);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; ) rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= BASE / 2) ++yd0;
        do {
          k2 = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);
            k2 = rem0 / yd0 | 0;
            if (k2 > 1) {
              if (k2 >= BASE) k2 = BASE - 1;
              prod = multiplyInteger(yd, k2);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k2--;
                subtract2(prod, yL < prodL ? yz : yd, prodL);
              }
            } else {
              if (k2 == 0) cmp = k2 = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL) prod.unshift(0);
            subtract2(rem, prod, remL);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k2++;
                subtract2(rem, yL < remL ? yz : yd, remL);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k2++;
            rem = [0];
          }
          qd[i++] = k2;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
      }
      if (!qd[0]) qd.shift();
      q.e = e;
      return round$1(q, dp ? pr + getBase10Exponent(q) + 1 : pr);
    };
  }();
  function exp(x2, sd) {
    var denominator, guard, pow2, sum2, t, wpr, i = 0, k2 = 0, Ctor = x2.constructor, pr = Ctor.precision;
    if (getBase10Exponent(x2) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x2));
    if (!x2.s) return new Ctor(ONE);
    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }
    t = new Ctor(0.03125);
    while (x2.abs().gte(0.1)) {
      x2 = x2.times(t);
      k2 += 5;
    }
    guard = Math.log(mathpow(2, k2)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow2 = sum2 = new Ctor(ONE);
    Ctor.precision = wpr;
    for (; ; ) {
      pow2 = round$1(pow2.times(x2), wpr);
      denominator = denominator.times(++i);
      t = sum2.plus(divide(pow2, denominator, wpr));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
        while (k2--) sum2 = round$1(sum2.times(sum2), wpr);
        Ctor.precision = pr;
        return sd == null ? (external = true, round$1(sum2, pr)) : sum2;
      }
      sum2 = t;
    }
  }
  function getBase10Exponent(x2) {
    var e = x2.e * LOG_BASE, w = x2.d[0];
    for (; w >= 10; w /= 10) e++;
    return e;
  }
  function getLn10(Ctor, sd, pr) {
    if (sd > Ctor.LN10.sd()) {
      external = true;
      if (pr) Ctor.precision = pr;
      throw Error(decimalError + "LN10 precision limit exceeded");
    }
    return round$1(new Ctor(Ctor.LN10), sd);
  }
  function getZeroString(k2) {
    var zs = "";
    for (; k2--; ) zs += "0";
    return zs;
  }
  function ln(y2, sd) {
    var c2, c0, denominator, e, numerator, sum2, t, wpr, x2, n = 1, guard = 10, x3 = y2, xd = x3.d, Ctor = x3.constructor, pr = Ctor.precision;
    if (x3.s < 1) throw Error(decimalError + (x3.s ? "NaN" : "-Infinity"));
    if (x3.eq(ONE)) return new Ctor(0);
    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }
    if (x3.eq(10)) {
      if (sd == null) external = true;
      return getLn10(Ctor, wpr);
    }
    wpr += guard;
    Ctor.precision = wpr;
    c2 = digitsToString(xd);
    c0 = c2.charAt(0);
    e = getBase10Exponent(x3);
    if (Math.abs(e) < 15e14) {
      while (c0 < 7 && c0 != 1 || c0 == 1 && c2.charAt(1) > 3) {
        x3 = x3.times(y2);
        c2 = digitsToString(x3.d);
        c0 = c2.charAt(0);
        n++;
      }
      e = getBase10Exponent(x3);
      if (c0 > 1) {
        x3 = new Ctor("0." + c2);
        e++;
      } else {
        x3 = new Ctor(c0 + "." + c2.slice(1));
      }
    } else {
      t = getLn10(Ctor, wpr + 2, pr).times(e + "");
      x3 = ln(new Ctor(c0 + "." + c2.slice(1)), wpr - guard).plus(t);
      Ctor.precision = pr;
      return sd == null ? (external = true, round$1(x3, pr)) : x3;
    }
    sum2 = numerator = x3 = divide(x3.minus(ONE), x3.plus(ONE), wpr);
    x2 = round$1(x3.times(x3), wpr);
    denominator = 3;
    for (; ; ) {
      numerator = round$1(numerator.times(x2), wpr);
      t = sum2.plus(divide(numerator, new Ctor(denominator), wpr));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
        sum2 = sum2.times(2);
        if (e !== 0) sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
        sum2 = divide(sum2, new Ctor(n), wpr);
        Ctor.precision = pr;
        return sd == null ? (external = true, round$1(sum2, pr)) : sum2;
      }
      sum2 = t;
      denominator += 2;
    }
  }
  function parseDecimal(x2, str) {
    var e, i, len;
    if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
    if ((i = str.search(/e/i)) > 0) {
      if (e < 0) e = i;
      e += +str.slice(i + 1);
      str = str.substring(0, i);
    } else if (e < 0) {
      e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; ) ++i;
    for (len = str.length; str.charCodeAt(len - 1) === 48; ) --len;
    str = str.slice(i, len);
    if (str) {
      len -= i;
      e = e - i - 1;
      x2.e = mathfloor(e / LOG_BASE);
      x2.d = [];
      i = (e + 1) % LOG_BASE;
      if (e < 0) i += LOG_BASE;
      if (i < len) {
        if (i) x2.d.push(+str.slice(0, i));
        for (len -= LOG_BASE; i < len; ) x2.d.push(+str.slice(i, i += LOG_BASE));
        str = str.slice(i);
        i = LOG_BASE - str.length;
      } else {
        i -= len;
      }
      for (; i--; ) str += "0";
      x2.d.push(+str);
      if (external && (x2.e > MAX_E || x2.e < -MAX_E)) throw Error(exponentOutOfRange + e);
    } else {
      x2.s = 0;
      x2.e = 0;
      x2.d = [0];
    }
    return x2;
  }
  function round$1(x2, sd, rm) {
    var i, j, k2, n, rd, doRound, w, xdi, xd = x2.d;
    for (n = 1, k2 = xd[0]; k2 >= 10; k2 /= 10) n++;
    i = sd - n;
    if (i < 0) {
      i += LOG_BASE;
      j = sd;
      w = xd[xdi = 0];
    } else {
      xdi = Math.ceil((i + 1) / LOG_BASE);
      k2 = xd.length;
      if (xdi >= k2) return x2;
      w = k2 = xd[xdi];
      for (n = 1; k2 >= 10; k2 /= 10) n++;
      i %= LOG_BASE;
      j = i - LOG_BASE + n;
    }
    if (rm !== void 0) {
      k2 = mathpow(10, n - j - 1);
      rd = w / k2 % 10 | 0;
      doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k2;
      doRound = rm < 4 ? (rd || doRound) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
    }
    if (sd < 1 || !xd[0]) {
      if (doRound) {
        k2 = getBase10Exponent(x2);
        xd.length = 1;
        sd = sd - k2 - 1;
        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
        x2.e = mathfloor(-sd / LOG_BASE) || 0;
      } else {
        xd.length = 1;
        xd[0] = x2.e = x2.s = 0;
      }
      return x2;
    }
    if (i == 0) {
      xd.length = xdi;
      k2 = 1;
      xdi--;
    } else {
      xd.length = xdi + 1;
      k2 = mathpow(10, LOG_BASE - i);
      xd[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k2 : 0;
    }
    if (doRound) {
      for (; ; ) {
        if (xdi == 0) {
          if ((xd[0] += k2) == BASE) {
            xd[0] = 1;
            ++x2.e;
          }
          break;
        } else {
          xd[xdi] += k2;
          if (xd[xdi] != BASE) break;
          xd[xdi--] = 0;
          k2 = 1;
        }
      }
    }
    for (i = xd.length; xd[--i] === 0; ) xd.pop();
    if (external && (x2.e > MAX_E || x2.e < -MAX_E)) {
      throw Error(exponentOutOfRange + getBase10Exponent(x2));
    }
    return x2;
  }
  function subtract(x2, y2) {
    var d, e, i, j, k2, len, xd, xe, xLTy, yd, Ctor = x2.constructor, pr = Ctor.precision;
    if (!x2.s || !y2.s) {
      if (y2.s) y2.s = -y2.s;
      else y2 = new Ctor(x2);
      return external ? round$1(y2, pr) : y2;
    }
    xd = x2.d;
    yd = y2.d;
    e = y2.e;
    xe = x2.e;
    xd = xd.slice();
    k2 = xe - e;
    if (k2) {
      xLTy = k2 < 0;
      if (xLTy) {
        d = xd;
        k2 = -k2;
        len = yd.length;
      } else {
        d = yd;
        e = xe;
        len = xd.length;
      }
      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
      if (k2 > i) {
        k2 = i;
        d.length = 1;
      }
      d.reverse();
      for (i = k2; i--; ) d.push(0);
      d.reverse();
    } else {
      i = xd.length;
      len = yd.length;
      xLTy = i < len;
      if (xLTy) len = i;
      for (i = 0; i < len; i++) {
        if (xd[i] != yd[i]) {
          xLTy = xd[i] < yd[i];
          break;
        }
      }
      k2 = 0;
    }
    if (xLTy) {
      d = xd;
      xd = yd;
      yd = d;
      y2.s = -y2.s;
    }
    len = xd.length;
    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
    for (i = yd.length; i > k2; ) {
      if (xd[--i] < yd[i]) {
        for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;
        --xd[j];
        xd[i] += BASE;
      }
      xd[i] -= yd[i];
    }
    for (; xd[--len] === 0; ) xd.pop();
    for (; xd[0] === 0; xd.shift()) --e;
    if (!xd[0]) return new Ctor(0);
    y2.d = xd;
    y2.e = e;
    return external ? round$1(y2, pr) : y2;
  }
  function toString(x2, isExp, sd) {
    var k2, e = getBase10Exponent(x2), str = digitsToString(x2.d), len = str.length;
    if (isExp) {
      if (sd && (k2 = sd - len) > 0) {
        str = str.charAt(0) + "." + str.slice(1) + getZeroString(k2);
      } else if (len > 1) {
        str = str.charAt(0) + "." + str.slice(1);
      }
      str = str + (e < 0 ? "e" : "e+") + e;
    } else if (e < 0) {
      str = "0." + getZeroString(-e - 1) + str;
      if (sd && (k2 = sd - len) > 0) str += getZeroString(k2);
    } else if (e >= len) {
      str += getZeroString(e + 1 - len);
      if (sd && (k2 = sd - e - 1) > 0) str = str + "." + getZeroString(k2);
    } else {
      if ((k2 = e + 1) < len) str = str.slice(0, k2) + "." + str.slice(k2);
      if (sd && (k2 = sd - len) > 0) {
        if (e + 1 === len) str += ".";
        str += getZeroString(k2);
      }
    }
    return x2.s < 0 ? "-" + str : str;
  }
  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  }
  function clone$1(obj) {
    var i, p, ps;
    function Decimal2(value) {
      var x2 = this;
      if (!(x2 instanceof Decimal2)) return new Decimal2(value);
      x2.constructor = Decimal2;
      if (value instanceof Decimal2) {
        x2.s = value.s;
        x2.e = value.e;
        x2.d = (value = value.d) ? value.slice() : value;
        return;
      }
      if (typeof value === "number") {
        if (value * 0 !== 0) {
          throw Error(invalidArgument + value);
        }
        if (value > 0) {
          x2.s = 1;
        } else if (value < 0) {
          value = -value;
          x2.s = -1;
        } else {
          x2.s = 0;
          x2.e = 0;
          x2.d = [0];
          return;
        }
        if (value === ~~value && value < 1e7) {
          x2.e = 0;
          x2.d = [value];
          return;
        }
        return parseDecimal(x2, value.toString());
      } else if (typeof value !== "string") {
        throw Error(invalidArgument + value);
      }
      if (value.charCodeAt(0) === 45) {
        value = value.slice(1);
        x2.s = -1;
      } else {
        x2.s = 1;
      }
      if (isDecimal.test(value)) parseDecimal(x2, value);
      else throw Error(invalidArgument + value);
    }
    Decimal2.prototype = P;
    Decimal2.ROUND_UP = 0;
    Decimal2.ROUND_DOWN = 1;
    Decimal2.ROUND_CEIL = 2;
    Decimal2.ROUND_FLOOR = 3;
    Decimal2.ROUND_HALF_UP = 4;
    Decimal2.ROUND_HALF_DOWN = 5;
    Decimal2.ROUND_HALF_EVEN = 6;
    Decimal2.ROUND_HALF_CEIL = 7;
    Decimal2.ROUND_HALF_FLOOR = 8;
    Decimal2.clone = clone$1;
    Decimal2.config = Decimal2.set = config;
    if (obj === void 0) obj = {};
    if (obj) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
      for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
    }
    Decimal2.config(obj);
    return Decimal2;
  }
  function config(obj) {
    if (!obj || typeof obj !== "object") {
      throw Error(decimalError + "Object expected");
    }
    var i, p, v, ps = [
      "precision",
      1,
      MAX_DIGITS,
      "rounding",
      0,
      8,
      "toExpNeg",
      -1 / 0,
      0,
      "toExpPos",
      0,
      1 / 0
    ];
    for (i = 0; i < ps.length; i += 3) {
      if ((v = obj[p = ps[i]]) !== void 0) {
        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
        else throw Error(invalidArgument + p + ": " + v);
      }
    }
    if ((v = obj[p = "LN10"]) !== void 0) {
      if (v == Math.LN10) this[p] = new this(v);
      else throw Error(invalidArgument + p + ": " + v);
    }
    return this;
  }
  var Decimal = clone$1(defaults);
  ONE = new Decimal(1);
  const Decimal$1 = Decimal;
  var identity$1 = (i) => i;
  var PLACE_HOLDER = {
    "@@functional/placeholder": true
  };
  var isPlaceHolder = (val) => val === PLACE_HOLDER;
  var curry0 = (fn) => function _curried() {
    if (arguments.length === 0 || arguments.length === 1 && isPlaceHolder(arguments.length <= 0 ? void 0 : arguments[0])) {
      return _curried;
    }
    return fn(...arguments);
  };
  var curryN = (n, fn) => {
    if (n === 1) {
      return fn;
    }
    return curry0(function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var argsLength = args.filter((arg) => arg !== PLACE_HOLDER).length;
      if (argsLength >= n) {
        return fn(...args);
      }
      return curryN(n - argsLength, curry0(function() {
        for (var _len2 = arguments.length, restArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          restArgs[_key2] = arguments[_key2];
        }
        var newArgs = args.map((arg) => isPlaceHolder(arg) ? restArgs.shift() : arg);
        return fn(...newArgs, ...restArgs);
      }));
    });
  };
  var curry$1 = (fn) => curryN(fn.length, fn);
  var range$1 = (begin, end) => {
    var arr = [];
    for (var i = begin; i < end; ++i) {
      arr[i - begin] = i;
    }
    return arr;
  };
  var map = curry$1((fn, arr) => {
    if (Array.isArray(arr)) {
      return arr.map(fn);
    }
    return Object.keys(arr).map((key) => arr[key]).map(fn);
  });
  var compose = function compose2() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    if (!args.length) {
      return identity$1;
    }
    var fns = args.reverse();
    var firstFn = fns[0];
    var tailsFn = fns.slice(1);
    return function() {
      return tailsFn.reduce((res, fn) => fn(res), firstFn(...arguments));
    };
  };
  var reverse = (arr) => {
    if (Array.isArray(arr)) {
      return arr.reverse();
    }
    return arr.split("").reverse().join("");
  };
  var memoize$1 = (fn) => {
    var lastArgs = null;
    var lastResult2 = null;
    return function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      if (lastArgs && args.every((val, i) => {
        var _lastArgs;
        return val === ((_lastArgs = lastArgs) === null || _lastArgs === void 0 ? void 0 : _lastArgs[i]);
      })) {
        return lastResult2;
      }
      lastArgs = args;
      lastResult2 = fn(...args);
      return lastResult2;
    };
  };
  function getDigitCount(value) {
    var result;
    if (value === 0) {
      result = 1;
    } else {
      result = Math.floor(new Decimal$1(value).abs().log(10).toNumber()) + 1;
    }
    return result;
  }
  function rangeStep(start, end, step) {
    var num = new Decimal$1(start);
    var i = 0;
    var result = [];
    while (num.lt(end) && i < 1e5) {
      result.push(num.toNumber());
      num = num.add(step);
      i++;
    }
    return result;
  }
  var interpolateNumber = curry$1((a2, b, t) => {
    var newA = +a2;
    var newB = +b;
    return newA + t * (newB - newA);
  });
  var uninterpolateNumber = curry$1((a2, b, x2) => {
    var diff = b - +a2;
    diff = diff || Infinity;
    return (x2 - a2) / diff;
  });
  var uninterpolateTruncation = curry$1((a2, b, x2) => {
    var diff = b - +a2;
    diff = diff || Infinity;
    return Math.max(0, Math.min(1, (x2 - a2) / diff));
  });
  var getValidInterval = (_ref2) => {
    var [min2, max2] = _ref2;
    var [validMin, validMax] = [min2, max2];
    if (min2 > max2) {
      [validMin, validMax] = [max2, min2];
    }
    return [validMin, validMax];
  };
  var getFormatStep = (roughStep, allowDecimals, correctionFactor) => {
    if (roughStep.lte(0)) {
      return new Decimal$1(0);
    }
    var digitCount = getDigitCount(roughStep.toNumber());
    var digitCountValue = new Decimal$1(10).pow(digitCount);
    var stepRatio = roughStep.div(digitCountValue);
    var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;
    var amendStepRatio = new Decimal$1(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);
    var formatStep = amendStepRatio.mul(digitCountValue);
    return allowDecimals ? new Decimal$1(formatStep.toNumber()) : new Decimal$1(Math.ceil(formatStep.toNumber()));
  };
  var getTickOfSingleValue = (value, tickCount, allowDecimals) => {
    var step = new Decimal$1(1);
    var middle = new Decimal$1(value);
    if (!middle.isint() && allowDecimals) {
      var absVal = Math.abs(value);
      if (absVal < 1) {
        step = new Decimal$1(10).pow(getDigitCount(value) - 1);
        middle = new Decimal$1(Math.floor(middle.div(step).toNumber())).mul(step);
      } else if (absVal > 1) {
        middle = new Decimal$1(Math.floor(value));
      }
    } else if (value === 0) {
      middle = new Decimal$1(Math.floor((tickCount - 1) / 2));
    } else if (!allowDecimals) {
      middle = new Decimal$1(Math.floor(value));
    }
    var middleIndex = Math.floor((tickCount - 1) / 2);
    var fn = compose(map((n) => middle.add(new Decimal$1(n - middleIndex).mul(step)).toNumber()), range$1);
    return fn(0, tickCount);
  };
  var _calculateStep = function calculateStep(min2, max2, tickCount, allowDecimals) {
    var correctionFactor = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    if (!Number.isFinite((max2 - min2) / (tickCount - 1))) {
      return {
        step: new Decimal$1(0),
        tickMin: new Decimal$1(0),
        tickMax: new Decimal$1(0)
      };
    }
    var step = getFormatStep(new Decimal$1(max2).sub(min2).div(tickCount - 1), allowDecimals, correctionFactor);
    var middle;
    if (min2 <= 0 && max2 >= 0) {
      middle = new Decimal$1(0);
    } else {
      middle = new Decimal$1(min2).add(max2).div(2);
      middle = middle.sub(new Decimal$1(middle).mod(step));
    }
    var belowCount = Math.ceil(middle.sub(min2).div(step).toNumber());
    var upCount = Math.ceil(new Decimal$1(max2).sub(middle).div(step).toNumber());
    var scaleCount = belowCount + upCount + 1;
    if (scaleCount > tickCount) {
      return _calculateStep(min2, max2, tickCount, allowDecimals, correctionFactor + 1);
    }
    if (scaleCount < tickCount) {
      upCount = max2 > 0 ? upCount + (tickCount - scaleCount) : upCount;
      belowCount = max2 > 0 ? belowCount : belowCount + (tickCount - scaleCount);
    }
    return {
      step,
      tickMin: middle.sub(new Decimal$1(belowCount).mul(step)),
      tickMax: middle.add(new Decimal$1(upCount).mul(step))
    };
  };
  function getNiceTickValuesFn(_ref2) {
    var [min2, max2] = _ref2;
    var tickCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;
    var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var count2 = Math.max(tickCount, 2);
    var [cormin, cormax] = getValidInterval([min2, max2]);
    if (cormin === -Infinity || cormax === Infinity) {
      var _values = cormax === Infinity ? [cormin, ...range$1(0, tickCount - 1).map(() => Infinity)] : [...range$1(0, tickCount - 1).map(() => -Infinity), cormax];
      return min2 > max2 ? reverse(_values) : _values;
    }
    if (cormin === cormax) {
      return getTickOfSingleValue(cormin, tickCount, allowDecimals);
    }
    var {
      step,
      tickMin,
      tickMax
    } = _calculateStep(cormin, cormax, count2, allowDecimals, 0);
    var values = rangeStep(tickMin, tickMax.add(new Decimal$1(0.1).mul(step)), step);
    return min2 > max2 ? reverse(values) : values;
  }
  function getTickValuesFixedDomainFn(_ref3, tickCount) {
    var [min2, max2] = _ref3;
    var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var [cormin, cormax] = getValidInterval([min2, max2]);
    if (cormin === -Infinity || cormax === Infinity) {
      return [min2, max2];
    }
    if (cormin === cormax) {
      return [cormin];
    }
    var count2 = Math.max(tickCount, 2);
    var step = getFormatStep(new Decimal$1(cormax).sub(cormin).div(count2 - 1), allowDecimals, 0);
    var values = [...rangeStep(new Decimal$1(cormin), new Decimal$1(cormax), step), cormax];
    if (allowDecimals === false) {
      values = values.map((value) => Math.round(value));
    }
    return min2 > max2 ? reverse(values) : values;
  }
  var getNiceTickValues = memoize$1(getNiceTickValuesFn);
  var getTickValuesFixedDomain = memoize$1(getTickValuesFixedDomainFn);
  var selectRootMaxBarSize = (state) => state.rootProps.maxBarSize;
  var selectBarGap = (state) => state.rootProps.barGap;
  var selectBarCategoryGap = (state) => state.rootProps.barCategoryGap;
  var selectRootBarSize = (state) => state.rootProps.barSize;
  var selectStackOffsetType = (state) => state.rootProps.stackOffset;
  var selectChartName = (state) => state.options.chartName;
  var selectSyncId = (state) => state.rootProps.syncId;
  var selectSyncMethod = (state) => state.rootProps.syncMethod;
  var selectEventEmitter = (state) => state.options.eventEmitter;
  var defaultPolarAngleAxisProps = {
    allowDuplicatedCategory: true,
    // if I set this to false then Tooltip synchronisation stops working in Radar, wtf
    angleAxisId: 0,
    axisLine: true,
    cx: 0,
    cy: 0,
    orientation: "outer",
    reversed: false,
    scale: "auto",
    tick: true,
    tickLine: true,
    tickSize: 8,
    type: "category"
  };
  var defaultPolarRadiusAxisProps = {
    allowDataOverflow: false,
    allowDuplicatedCategory: true,
    angle: 0,
    axisLine: true,
    cx: 0,
    cy: 0,
    orientation: "right",
    radiusAxisId: 0,
    scale: "auto",
    stroke: "#ccc",
    tick: true,
    tickCount: 5,
    type: "number"
  };
  var combineAxisRangeWithReverse = (axisSettings, axisRange) => {
    if (!axisSettings || !axisRange) {
      return void 0;
    }
    if (axisSettings !== null && axisSettings !== void 0 && axisSettings.reversed) {
      return [axisRange[1], axisRange[0]];
    }
    return axisRange;
  };
  var implicitAngleAxis = {
    allowDataOverflow: false,
    allowDecimals: false,
    allowDuplicatedCategory: false,
    // defaultPolarAngleAxisProps.allowDuplicatedCategory has it set to true but the actual axis rendering ignores the prop because reasons,
    dataKey: void 0,
    domain: void 0,
    id: defaultPolarAngleAxisProps.angleAxisId,
    includeHidden: false,
    name: void 0,
    reversed: defaultPolarAngleAxisProps.reversed,
    scale: defaultPolarAngleAxisProps.scale,
    tick: defaultPolarAngleAxisProps.tick,
    tickCount: void 0,
    ticks: void 0,
    type: defaultPolarAngleAxisProps.type,
    unit: void 0
  };
  var implicitRadiusAxis = {
    allowDataOverflow: defaultPolarRadiusAxisProps.allowDataOverflow,
    allowDecimals: false,
    allowDuplicatedCategory: defaultPolarRadiusAxisProps.allowDuplicatedCategory,
    dataKey: void 0,
    domain: void 0,
    id: defaultPolarRadiusAxisProps.radiusAxisId,
    includeHidden: false,
    name: void 0,
    reversed: false,
    scale: defaultPolarRadiusAxisProps.scale,
    tick: defaultPolarRadiusAxisProps.tick,
    tickCount: defaultPolarRadiusAxisProps.tickCount,
    ticks: void 0,
    type: defaultPolarRadiusAxisProps.type,
    unit: void 0
  };
  var implicitRadialBarAngleAxis = {
    allowDataOverflow: false,
    allowDecimals: false,
    allowDuplicatedCategory: defaultPolarAngleAxisProps.allowDuplicatedCategory,
    dataKey: void 0,
    domain: void 0,
    id: defaultPolarAngleAxisProps.angleAxisId,
    includeHidden: false,
    name: void 0,
    reversed: false,
    scale: defaultPolarAngleAxisProps.scale,
    tick: defaultPolarAngleAxisProps.tick,
    tickCount: void 0,
    ticks: void 0,
    type: "number",
    unit: void 0
  };
  var implicitRadialBarRadiusAxis = {
    allowDataOverflow: defaultPolarRadiusAxisProps.allowDataOverflow,
    allowDecimals: false,
    allowDuplicatedCategory: defaultPolarRadiusAxisProps.allowDuplicatedCategory,
    dataKey: void 0,
    domain: void 0,
    id: defaultPolarRadiusAxisProps.radiusAxisId,
    includeHidden: false,
    name: void 0,
    reversed: false,
    scale: defaultPolarRadiusAxisProps.scale,
    tick: defaultPolarRadiusAxisProps.tick,
    tickCount: defaultPolarRadiusAxisProps.tickCount,
    ticks: void 0,
    type: "category",
    unit: void 0
  };
  var selectAngleAxis = (state, angleAxisId) => {
    if (state.polarAxis.angleAxis[angleAxisId] != null) {
      return state.polarAxis.angleAxis[angleAxisId];
    }
    if (state.layout.layoutType === "radial") {
      return implicitRadialBarAngleAxis;
    }
    return implicitAngleAxis;
  };
  var selectRadiusAxis = (state, radiusAxisId) => {
    if (state.polarAxis.radiusAxis[radiusAxisId] != null) {
      return state.polarAxis.radiusAxis[radiusAxisId];
    }
    if (state.layout.layoutType === "radial") {
      return implicitRadialBarRadiusAxis;
    }
    return implicitRadiusAxis;
  };
  var selectPolarOptions = (state) => state.polarOptions;
  var selectMaxRadius = createSelector([selectChartWidth, selectChartHeight, selectChartOffsetInternal], getMaxRadius);
  var selectInnerRadius = createSelector([selectPolarOptions, selectMaxRadius], (polarChartOptions, maxRadius) => {
    if (polarChartOptions == null) {
      return void 0;
    }
    return getPercentValue(polarChartOptions.innerRadius, maxRadius, 0);
  });
  var selectOuterRadius = createSelector([selectPolarOptions, selectMaxRadius], (polarChartOptions, maxRadius) => {
    if (polarChartOptions == null) {
      return void 0;
    }
    return getPercentValue(polarChartOptions.outerRadius, maxRadius, maxRadius * 0.8);
  });
  var combineAngleAxisRange = (polarOptions) => {
    if (polarOptions == null) {
      return [0, 0];
    }
    var {
      startAngle,
      endAngle
    } = polarOptions;
    return [startAngle, endAngle];
  };
  var selectAngleAxisRange = createSelector([selectPolarOptions], combineAngleAxisRange);
  var selectAngleAxisRangeWithReversed = createSelector([selectAngleAxis, selectAngleAxisRange], combineAxisRangeWithReverse);
  var selectRadiusAxisRange = createSelector([selectMaxRadius, selectInnerRadius, selectOuterRadius], (maxRadius, innerRadius, outerRadius) => {
    if (maxRadius == null || innerRadius == null || outerRadius == null) {
      return void 0;
    }
    return [innerRadius, outerRadius];
  });
  var selectRadiusAxisRangeWithReversed = createSelector([selectRadiusAxis, selectRadiusAxisRange], combineAxisRangeWithReverse);
  var selectPolarViewBox = createSelector([selectChartLayout, selectPolarOptions, selectInnerRadius, selectOuterRadius, selectChartWidth, selectChartHeight], (layout, polarOptions, innerRadius, outerRadius, width, height) => {
    if (layout !== "centric" && layout !== "radial" || polarOptions == null || innerRadius == null || outerRadius == null) {
      return void 0;
    }
    var {
      cx,
      cy,
      startAngle,
      endAngle
    } = polarOptions;
    return {
      cx: getPercentValue(cx, width, width / 2),
      cy: getPercentValue(cy, height, height / 2),
      innerRadius,
      outerRadius,
      startAngle,
      endAngle,
      clockWise: false
    };
  });
  var pickAxisType = (_state, axisType) => axisType;
  var pickAxisId = (_state, _axisType, axisId) => axisId;
  function getStackSeriesIdentifier(graphicalItem) {
    return graphicalItem === null || graphicalItem === void 0 ? void 0 : graphicalItem.id;
  }
  var selectTooltipAxisType = (state) => {
    var layout = selectChartLayout(state);
    if (layout === "horizontal") {
      return "xAxis";
    }
    if (layout === "vertical") {
      return "yAxis";
    }
    if (layout === "centric") {
      return "angleAxis";
    }
    return "radiusAxis";
  };
  var selectTooltipAxisId = (state) => state.tooltip.settings.axisId;
  var selectTooltipAxis = (state) => {
    var axisType = selectTooltipAxisType(state);
    var axisId = selectTooltipAxisId(state);
    return selectAxisSettings(state, axisType, axisId);
  };
  function combineDisplayedStackedData(stackedGraphicalItems, _ref2, tooltipAxisSettings) {
    var {
      chartData = []
    } = _ref2;
    var tooltipDataKey = tooltipAxisSettings === null || tooltipAxisSettings === void 0 ? void 0 : tooltipAxisSettings.dataKey;
    var knownItemsByDataKey = /* @__PURE__ */ new Map();
    stackedGraphicalItems.forEach((item) => {
      var _item$data;
      var resolvedData = (_item$data = item.data) !== null && _item$data !== void 0 ? _item$data : chartData;
      if (resolvedData == null || resolvedData.length === 0) {
        return;
      }
      var stackIdentifier = getStackSeriesIdentifier(item);
      resolvedData.forEach((entry, index2) => {
        var tooltipValue = tooltipDataKey == null ? index2 : String(getValueByDataKey(entry, tooltipDataKey, null));
        var numericValue = getValueByDataKey(entry, item.dataKey, 0);
        var curr;
        if (knownItemsByDataKey.has(tooltipValue)) {
          curr = knownItemsByDataKey.get(tooltipValue);
        } else {
          curr = {};
        }
        Object.assign(curr, {
          [stackIdentifier]: numericValue
        });
        knownItemsByDataKey.set(tooltipValue, curr);
      });
    });
    return Array.from(knownItemsByDataKey.values());
  }
  function isStacked(graphicalItem) {
    return graphicalItem.stackId != null && graphicalItem.dataKey != null;
  }
  function ownKeys$J(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$J(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$J(Object(t), true).forEach(function(r3) {
        _defineProperty$N(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$J(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$N(e, r2, t) {
    return (r2 = _toPropertyKey$N(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$N(t) {
    var i = _toPrimitive$N(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$N(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var defaultNumericDomain = [0, "auto"];
  var implicitXAxis = {
    allowDataOverflow: false,
    allowDecimals: true,
    allowDuplicatedCategory: true,
    angle: 0,
    dataKey: void 0,
    domain: void 0,
    height: 30,
    hide: true,
    id: 0,
    includeHidden: false,
    interval: "preserveEnd",
    minTickGap: 5,
    mirror: false,
    name: void 0,
    orientation: "bottom",
    padding: {
      left: 0,
      right: 0
    },
    reversed: false,
    scale: "auto",
    tick: true,
    tickCount: 5,
    tickFormatter: void 0,
    ticks: void 0,
    type: "category",
    unit: void 0
  };
  var selectXAxisSettings = (state, axisId) => {
    var axis = state.cartesianAxis.xAxis[axisId];
    if (axis == null) {
      return implicitXAxis;
    }
    return axis;
  };
  var implicitYAxis = {
    allowDataOverflow: false,
    allowDecimals: true,
    allowDuplicatedCategory: true,
    angle: 0,
    dataKey: void 0,
    domain: defaultNumericDomain,
    hide: true,
    id: 0,
    includeHidden: false,
    interval: "preserveEnd",
    minTickGap: 5,
    mirror: false,
    name: void 0,
    orientation: "left",
    padding: {
      top: 0,
      bottom: 0
    },
    reversed: false,
    scale: "auto",
    tick: true,
    tickCount: 5,
    tickFormatter: void 0,
    ticks: void 0,
    type: "number",
    unit: void 0,
    width: DEFAULT_Y_AXIS_WIDTH
  };
  var selectYAxisSettings = (state, axisId) => {
    var axis = state.cartesianAxis.yAxis[axisId];
    if (axis == null) {
      return implicitYAxis;
    }
    return axis;
  };
  var implicitZAxis = {
    domain: [0, "auto"],
    includeHidden: false,
    reversed: false,
    allowDataOverflow: false,
    allowDuplicatedCategory: false,
    dataKey: void 0,
    id: 0,
    name: "",
    range: [64, 64],
    scale: "auto",
    type: "number",
    unit: ""
  };
  var selectZAxisSettings = (state, axisId) => {
    var axis = state.cartesianAxis.zAxis[axisId];
    if (axis == null) {
      return implicitZAxis;
    }
    return axis;
  };
  var selectBaseAxis = (state, axisType, axisId) => {
    switch (axisType) {
      case "xAxis": {
        return selectXAxisSettings(state, axisId);
      }
      case "yAxis": {
        return selectYAxisSettings(state, axisId);
      }
      case "zAxis": {
        return selectZAxisSettings(state, axisId);
      }
      case "angleAxis": {
        return selectAngleAxis(state, axisId);
      }
      case "radiusAxis": {
        return selectRadiusAxis(state, axisId);
      }
      default:
        throw new Error("Unexpected axis type: ".concat(axisType));
    }
  };
  var selectCartesianAxisSettings = (state, axisType, axisId) => {
    switch (axisType) {
      case "xAxis": {
        return selectXAxisSettings(state, axisId);
      }
      case "yAxis": {
        return selectYAxisSettings(state, axisId);
      }
      default:
        throw new Error("Unexpected axis type: ".concat(axisType));
    }
  };
  var selectAxisSettings = (state, axisType, axisId) => {
    switch (axisType) {
      case "xAxis": {
        return selectXAxisSettings(state, axisId);
      }
      case "yAxis": {
        return selectYAxisSettings(state, axisId);
      }
      case "angleAxis": {
        return selectAngleAxis(state, axisId);
      }
      case "radiusAxis": {
        return selectRadiusAxis(state, axisId);
      }
      default:
        throw new Error("Unexpected axis type: ".concat(axisType));
    }
  };
  var selectHasBar = (state) => state.graphicalItems.cartesianItems.some((item) => item.type === "bar") || state.graphicalItems.polarItems.some((item) => item.type === "radialBar");
  function itemAxisPredicate(axisType, axisId) {
    return (item) => {
      switch (axisType) {
        case "xAxis":
          return "xAxisId" in item && item.xAxisId === axisId;
        case "yAxis":
          return "yAxisId" in item && item.yAxisId === axisId;
        case "zAxis":
          return "zAxisId" in item && item.zAxisId === axisId;
        case "angleAxis":
          return "angleAxisId" in item && item.angleAxisId === axisId;
        case "radiusAxis":
          return "radiusAxisId" in item && item.radiusAxisId === axisId;
        default:
          return false;
      }
    };
  }
  var selectUnfilteredCartesianItems = (state) => state.graphicalItems.cartesianItems;
  var selectAxisPredicate$1 = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);
  var combineGraphicalItemsSettings = (graphicalItems, axisSettings, axisPredicate) => graphicalItems.filter(axisPredicate).filter((item) => {
    if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.includeHidden) === true) {
      return true;
    }
    return !item.hide;
  });
  var selectCartesianItemsSettings = createSelector([selectUnfilteredCartesianItems, selectBaseAxis, selectAxisPredicate$1], combineGraphicalItemsSettings);
  var selectStackedCartesianItemsSettings = createSelector([selectCartesianItemsSettings], (cartesianItems) => {
    return cartesianItems.filter((item) => item.type === "area" || item.type === "bar").filter(isStacked);
  });
  var filterGraphicalNotStackedItems = (cartesianItems) => cartesianItems.filter((item) => !("stackId" in item) || item.stackId === void 0);
  var selectCartesianItemsSettingsExceptStacked = createSelector([selectCartesianItemsSettings], filterGraphicalNotStackedItems);
  var combineGraphicalItemsData = (cartesianItems) => cartesianItems.map((item) => item.data).filter(Boolean).flat(1);
  var selectCartesianGraphicalItemsData = createSelector([selectCartesianItemsSettings], combineGraphicalItemsData);
  var combineDisplayedData = (graphicalItemsData, _ref2) => {
    var {
      chartData = [],
      dataStartIndex,
      dataEndIndex
    } = _ref2;
    if (graphicalItemsData.length > 0) {
      return graphicalItemsData;
    }
    return chartData.slice(dataStartIndex, dataEndIndex + 1);
  };
  var selectDisplayedData$1 = createSelector([selectCartesianGraphicalItemsData, selectChartDataWithIndexesIfNotInPanorama], combineDisplayedData);
  var combineAppliedValues = (data, axisSettings, items) => {
    if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {
      return data.map((item) => ({
        value: getValueByDataKey(item, axisSettings.dataKey)
      }));
    }
    if (items.length > 0) {
      return items.map((item) => item.dataKey).flatMap((dataKey) => data.map((entry) => ({
        value: getValueByDataKey(entry, dataKey)
      })));
    }
    return data.map((entry) => ({
      value: entry
    }));
  };
  var selectAllAppliedValues = createSelector([selectDisplayedData$1, selectBaseAxis, selectCartesianItemsSettings], combineAppliedValues);
  function isErrorBarRelevantForAxisType(axisType, errorBar) {
    switch (axisType) {
      case "xAxis":
        return errorBar.direction === "x";
      case "yAxis":
        return errorBar.direction === "y";
      default:
        return false;
    }
  }
  function fromMainValueToError(value) {
    if (isNumber(value) && Number.isFinite(value)) {
      return [value, value];
    }
    if (Array.isArray(value)) {
      var minError = Math.min(...value);
      var maxError = Math.max(...value);
      if (!isNan(minError) && !isNan(maxError) && Number.isFinite(minError) && Number.isFinite(maxError)) {
        return [minError, maxError];
      }
    }
    return void 0;
  }
  function onlyAllowNumbers(data) {
    return data.filter((v) => isNumOrStr(v) || v instanceof Date).map(Number).filter((n) => isNan(n) === false);
  }
  function getErrorDomainByDataKey(entry, appliedValue, relevantErrorBars) {
    if (!relevantErrorBars || typeof appliedValue !== "number" || isNan(appliedValue)) {
      return [];
    }
    if (!relevantErrorBars.length) {
      return [];
    }
    return onlyAllowNumbers(relevantErrorBars.flatMap((eb) => {
      var errorValue = getValueByDataKey(entry, eb.dataKey);
      var lowBound, highBound;
      if (Array.isArray(errorValue)) {
        [lowBound, highBound] = errorValue;
      } else {
        lowBound = highBound = errorValue;
      }
      if (!isWellBehavedNumber(lowBound) || !isWellBehavedNumber(highBound)) {
        return void 0;
      }
      return [appliedValue - lowBound, appliedValue + highBound];
    }));
  }
  var selectDisplayedStackedData = createSelector([selectStackedCartesianItemsSettings, selectChartDataWithIndexesIfNotInPanorama, selectTooltipAxis], combineDisplayedStackedData);
  var combineStackGroups = (displayedData, items, stackOffsetType) => {
    var initialItemsGroups = {};
    var itemsGroup = items.reduce((acc, item) => {
      if (item.stackId == null) {
        return acc;
      }
      if (acc[item.stackId] == null) {
        acc[item.stackId] = [];
      }
      acc[item.stackId].push(item);
      return acc;
    }, initialItemsGroups);
    return Object.fromEntries(Object.entries(itemsGroup).map((_ref2) => {
      var [stackId, graphicalItems] = _ref2;
      var dataKeys = graphicalItems.map(getStackSeriesIdentifier);
      return [stackId, {
        // @ts-expect-error getStackedData requires that the input is array of objects, Recharts does not test for that
        stackedData: getStackedData(displayedData, dataKeys, stackOffsetType),
        graphicalItems
      }];
    }));
  };
  var selectStackGroups$1 = createSelector([selectDisplayedStackedData, selectStackedCartesianItemsSettings, selectStackOffsetType], combineStackGroups);
  var combineDomainOfStackGroups = (stackGroups, _ref3, axisType) => {
    var {
      dataStartIndex,
      dataEndIndex
    } = _ref3;
    if (axisType === "zAxis") {
      return void 0;
    }
    var domainOfStackGroups = getDomainOfStackGroups(stackGroups, dataStartIndex, dataEndIndex);
    if (domainOfStackGroups != null && domainOfStackGroups[0] === 0 && domainOfStackGroups[1] === 0) {
      return void 0;
    }
    return domainOfStackGroups;
  };
  var selectDomainOfStackGroups = createSelector([selectStackGroups$1, selectChartDataWithIndexes, pickAxisType], combineDomainOfStackGroups);
  var combineAppliedNumericalValuesIncludingErrorValues = (data, axisSettings, items, errorBars, axisType) => {
    if (items.length > 0) {
      return data.flatMap((entry) => {
        return items.flatMap((item) => {
          var _errorBars$item$id, _axisSettings$dataKey;
          var relevantErrorBars = (_errorBars$item$id = errorBars[item.id]) === null || _errorBars$item$id === void 0 ? void 0 : _errorBars$item$id.filter((errorBar) => isErrorBarRelevantForAxisType(axisType, errorBar));
          var valueByDataKey = getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey);
          return {
            value: valueByDataKey,
            errorDomain: getErrorDomainByDataKey(entry, valueByDataKey, relevantErrorBars)
          };
        });
      }).filter(Boolean);
    }
    if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {
      return data.map((item) => ({
        value: getValueByDataKey(item, axisSettings.dataKey),
        errorDomain: []
      }));
    }
    return data.map((entry) => ({
      value: entry,
      errorDomain: []
    }));
  };
  var selectAllErrorBarSettings = (state) => state.errorBars;
  var combineRelevantErrorBarSettings = (cartesianItemsSettings, allErrorBarSettings, axisType) => {
    return cartesianItemsSettings.flatMap((item) => {
      return allErrorBarSettings[item.id];
    }).filter(Boolean).filter((e) => {
      return isErrorBarRelevantForAxisType(axisType, e);
    });
  };
  var selectErrorBarsSettingsExceptStacked = createSelector([selectCartesianItemsSettingsExceptStacked, selectAllErrorBarSettings, pickAxisType], combineRelevantErrorBarSettings);
  var selectAllAppliedNumericalValuesIncludingErrorValues = createSelector([selectDisplayedData$1, selectBaseAxis, selectCartesianItemsSettingsExceptStacked, selectAllErrorBarSettings, pickAxisType], combineAppliedNumericalValuesIncludingErrorValues);
  function onlyAllowNumbersAndStringsAndDates(item) {
    var {
      value
    } = item;
    if (isNumOrStr(value) || value instanceof Date) {
      return value;
    }
    return void 0;
  }
  var computeNumericalDomain = (dataWithErrorDomains) => {
    var allDataSquished = dataWithErrorDomains.flatMap((d) => [d.value, d.errorDomain]).flat(1);
    var onlyNumbers = onlyAllowNumbers(allDataSquished);
    if (onlyNumbers.length === 0) {
      return void 0;
    }
    return [Math.min(...onlyNumbers), Math.max(...onlyNumbers)];
  };
  var computeDomainOfTypeCategory = (allDataSquished, axisSettings, isCategorical) => {
    var categoricalDomain = allDataSquished.map(onlyAllowNumbersAndStringsAndDates).filter((v) => v != null);
    if (isCategorical && (axisSettings.dataKey == null || axisSettings.allowDuplicatedCategory && hasDuplicate(categoricalDomain))) {
      return range$4(0, allDataSquished.length);
    }
    if (axisSettings.allowDuplicatedCategory) {
      return categoricalDomain;
    }
    return Array.from(new Set(categoricalDomain));
  };
  var getDomainDefinition = (axisSettings) => {
    var _axisSettings$domain;
    if (axisSettings == null || !("domain" in axisSettings)) {
      return defaultNumericDomain;
    }
    if (axisSettings.domain != null) {
      return axisSettings.domain;
    }
    if (axisSettings.ticks != null) {
      if (axisSettings.type === "number") {
        var allValues = onlyAllowNumbers(axisSettings.ticks);
        return [Math.min(...allValues), Math.max(...allValues)];
      }
      if (axisSettings.type === "category") {
        return axisSettings.ticks.map(String);
      }
    }
    return (_axisSettings$domain = axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.domain) !== null && _axisSettings$domain !== void 0 ? _axisSettings$domain : defaultNumericDomain;
  };
  var mergeDomains = function mergeDomains2() {
    for (var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++) {
      domains[_key] = arguments[_key];
    }
    var allDomains = domains.filter(Boolean);
    if (allDomains.length === 0) {
      return void 0;
    }
    var allValues = allDomains.flat();
    var min2 = Math.min(...allValues);
    var max2 = Math.max(...allValues);
    return [min2, max2];
  };
  var selectReferenceDots = (state) => state.referenceElements.dots;
  var filterReferenceElements = (elements, axisType, axisId) => {
    return elements.filter((el) => el.ifOverflow === "extendDomain").filter((el) => {
      if (axisType === "xAxis") {
        return el.xAxisId === axisId;
      }
      return el.yAxisId === axisId;
    });
  };
  var selectReferenceDotsByAxis = createSelector([selectReferenceDots, pickAxisType, pickAxisId], filterReferenceElements);
  var selectReferenceAreas = (state) => state.referenceElements.areas;
  var selectReferenceAreasByAxis = createSelector([selectReferenceAreas, pickAxisType, pickAxisId], filterReferenceElements);
  var selectReferenceLines = (state) => state.referenceElements.lines;
  var selectReferenceLinesByAxis = createSelector([selectReferenceLines, pickAxisType, pickAxisId], filterReferenceElements);
  var combineDotsDomain = (dots, axisType) => {
    var allCoords = onlyAllowNumbers(dots.map((dot) => axisType === "xAxis" ? dot.x : dot.y));
    if (allCoords.length === 0) {
      return void 0;
    }
    return [Math.min(...allCoords), Math.max(...allCoords)];
  };
  var selectReferenceDotsDomain = createSelector(selectReferenceDotsByAxis, pickAxisType, combineDotsDomain);
  var combineAreasDomain = (areas, axisType) => {
    var allCoords = onlyAllowNumbers(areas.flatMap((area) => [axisType === "xAxis" ? area.x1 : area.y1, axisType === "xAxis" ? area.x2 : area.y2]));
    if (allCoords.length === 0) {
      return void 0;
    }
    return [Math.min(...allCoords), Math.max(...allCoords)];
  };
  var selectReferenceAreasDomain = createSelector([selectReferenceAreasByAxis, pickAxisType], combineAreasDomain);
  var combineLinesDomain = (lines, axisType) => {
    var allCoords = onlyAllowNumbers(lines.map((line) => axisType === "xAxis" ? line.x : line.y));
    if (allCoords.length === 0) {
      return void 0;
    }
    return [Math.min(...allCoords), Math.max(...allCoords)];
  };
  var selectReferenceLinesDomain = createSelector(selectReferenceLinesByAxis, pickAxisType, combineLinesDomain);
  var selectReferenceElementsDomain = createSelector(selectReferenceDotsDomain, selectReferenceLinesDomain, selectReferenceAreasDomain, (dotsDomain, linesDomain, areasDomain) => {
    return mergeDomains(dotsDomain, areasDomain, linesDomain);
  });
  var selectDomainDefinition = createSelector([selectBaseAxis], getDomainDefinition);
  var combineNumericalDomain = (axisSettings, domainDefinition, domainOfStackGroups, allDataWithErrorDomains, referenceElementsDomain, layout, axisType) => {
    var domainFromUserPreference = numericalDomainSpecifiedWithoutRequiringData(domainDefinition, axisSettings.allowDataOverflow);
    if (domainFromUserPreference != null) {
      return domainFromUserPreference;
    }
    var shouldIncludeDomainOfStackGroups = layout === "vertical" && axisType === "xAxis" || layout === "horizontal" && axisType === "yAxis";
    var mergedDomains = shouldIncludeDomainOfStackGroups ? mergeDomains(domainOfStackGroups, referenceElementsDomain, computeNumericalDomain(allDataWithErrorDomains)) : mergeDomains(referenceElementsDomain, computeNumericalDomain(allDataWithErrorDomains));
    return parseNumericalUserDomain(domainDefinition, mergedDomains, axisSettings.allowDataOverflow);
  };
  var selectNumericalDomain = createSelector([selectBaseAxis, selectDomainDefinition, selectDomainOfStackGroups, selectAllAppliedNumericalValuesIncludingErrorValues, selectReferenceElementsDomain, selectChartLayout, pickAxisType], combineNumericalDomain);
  var expandDomain = [0, 1];
  var combineAxisDomain = (axisSettings, layout, displayedData, allAppliedValues, stackOffsetType, axisType, numericalDomain) => {
    if ((axisSettings == null || displayedData == null || displayedData.length === 0) && numericalDomain === void 0) {
      return void 0;
    }
    var {
      dataKey,
      type
    } = axisSettings;
    var isCategorical = isCategoricalAxis(layout, axisType);
    if (isCategorical && dataKey == null) {
      return range$4(0, displayedData.length);
    }
    if (type === "category") {
      return computeDomainOfTypeCategory(allAppliedValues, axisSettings, isCategorical);
    }
    if (stackOffsetType === "expand") {
      return expandDomain;
    }
    return numericalDomain;
  };
  var selectAxisDomain = createSelector([selectBaseAxis, selectChartLayout, selectDisplayedData$1, selectAllAppliedValues, selectStackOffsetType, pickAxisType, selectNumericalDomain], combineAxisDomain);
  var combineRealScaleType = (axisConfig, layout, hasBar, chartType, axisType) => {
    if (axisConfig == null) {
      return void 0;
    }
    var {
      scale,
      type
    } = axisConfig;
    if (scale === "auto") {
      if (layout === "radial" && axisType === "radiusAxis") {
        return "band";
      }
      if (layout === "radial" && axisType === "angleAxis") {
        return "linear";
      }
      if (type === "category" && chartType && (chartType.indexOf("LineChart") >= 0 || chartType.indexOf("AreaChart") >= 0 || chartType.indexOf("ComposedChart") >= 0 && !hasBar)) {
        return "point";
      }
      if (type === "category") {
        return "band";
      }
      return "linear";
    }
    if (typeof scale === "string") {
      var name = "scale".concat(upperFirst$1(scale));
      return name in d3Scales ? name : "point";
    }
    return void 0;
  };
  var selectRealScaleType = createSelector([selectBaseAxis, selectChartLayout, selectHasBar, selectChartName, pickAxisType], combineRealScaleType);
  function getD3ScaleFromType(realScaleType) {
    if (realScaleType == null) {
      return void 0;
    }
    if (realScaleType in d3Scales) {
      return d3Scales[realScaleType]();
    }
    var name = "scale".concat(upperFirst$1(realScaleType));
    if (name in d3Scales) {
      return d3Scales[name]();
    }
    return void 0;
  }
  function combineScaleFunction(axis, realScaleType, axisDomain, axisRange) {
    if (axisDomain == null || axisRange == null) {
      return void 0;
    }
    if (typeof axis.scale === "function") {
      return axis.scale.copy().domain(axisDomain).range(axisRange);
    }
    var d3ScaleFunction = getD3ScaleFromType(realScaleType);
    if (d3ScaleFunction == null) {
      return void 0;
    }
    var scale = d3ScaleFunction.domain(axisDomain).range(axisRange);
    checkDomainOfScale(scale);
    return scale;
  }
  var combineNiceTicks = (axisDomain, axisSettings, realScaleType) => {
    var domainDefinition = getDomainDefinition(axisSettings);
    if (realScaleType !== "auto" && realScaleType !== "linear") {
      return void 0;
    }
    if (axisSettings != null && axisSettings.tickCount && Array.isArray(domainDefinition) && (domainDefinition[0] === "auto" || domainDefinition[1] === "auto") && isWellFormedNumberDomain(axisDomain)) {
      return getNiceTickValues(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);
    }
    if (axisSettings != null && axisSettings.tickCount && axisSettings.type === "number" && isWellFormedNumberDomain(axisDomain)) {
      return getTickValuesFixedDomain(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);
    }
    return void 0;
  };
  var selectNiceTicks = createSelector([selectAxisDomain, selectAxisSettings, selectRealScaleType], combineNiceTicks);
  var combineAxisDomainWithNiceTicks = (axisSettings, domain, niceTicks, axisType) => {
    if (
      /*
       * Angle axis for some reason uses nice ticks when rendering axis tick labels,
       * but doesn't use nice ticks for extending domain like all the other axes do.
       * Not really sure why? Is there a good reason,
       * or is it just because someone added support for nice ticks to the other axes and forgot this one?
       */
      axisType !== "angleAxis" && (axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.type) === "number" && isWellFormedNumberDomain(domain) && Array.isArray(niceTicks) && niceTicks.length > 0
    ) {
      var minFromDomain = domain[0];
      var minFromTicks = niceTicks[0];
      var maxFromDomain = domain[1];
      var maxFromTicks = niceTicks[niceTicks.length - 1];
      return [Math.min(minFromDomain, minFromTicks), Math.max(maxFromDomain, maxFromTicks)];
    }
    return domain;
  };
  var selectAxisDomainIncludingNiceTicks = createSelector([selectBaseAxis, selectAxisDomain, selectNiceTicks, pickAxisType], combineAxisDomainWithNiceTicks);
  var selectSmallestDistanceBetweenValues = createSelector(selectAllAppliedValues, selectBaseAxis, (allDataSquished, axisSettings) => {
    if (!axisSettings || axisSettings.type !== "number") {
      return void 0;
    }
    var smallestDistanceBetweenValues = Infinity;
    var sortedValues = Array.from(onlyAllowNumbers(allDataSquished.map((d) => d.value))).sort((a2, b) => a2 - b);
    if (sortedValues.length < 2) {
      return Infinity;
    }
    var diff = sortedValues[sortedValues.length - 1] - sortedValues[0];
    if (diff === 0) {
      return Infinity;
    }
    for (var i = 0; i < sortedValues.length - 1; i++) {
      var distance = sortedValues[i + 1] - sortedValues[i];
      smallestDistanceBetweenValues = Math.min(smallestDistanceBetweenValues, distance);
    }
    return smallestDistanceBetweenValues / diff;
  });
  var selectCalculatedPadding = createSelector(selectSmallestDistanceBetweenValues, selectChartLayout, selectBarCategoryGap, selectChartOffsetInternal, (_1, _2, _3, padding) => padding, (smallestDistanceInPercent, layout, barCategoryGap, offset, padding) => {
    if (!isWellBehavedNumber(smallestDistanceInPercent)) {
      return 0;
    }
    var rangeWidth = layout === "vertical" ? offset.height : offset.width;
    if (padding === "gap") {
      return smallestDistanceInPercent * rangeWidth / 2;
    }
    if (padding === "no-gap") {
      var gap = getPercentValue(barCategoryGap, smallestDistanceInPercent * rangeWidth);
      var halfBand = smallestDistanceInPercent * rangeWidth / 2;
      return halfBand - gap - (halfBand - gap) / rangeWidth * gap;
    }
    return 0;
  });
  var selectCalculatedXAxisPadding = (state, axisId) => {
    var xAxisSettings = selectXAxisSettings(state, axisId);
    if (xAxisSettings == null || typeof xAxisSettings.padding !== "string") {
      return 0;
    }
    return selectCalculatedPadding(state, "xAxis", axisId, xAxisSettings.padding);
  };
  var selectCalculatedYAxisPadding = (state, axisId) => {
    var yAxisSettings = selectYAxisSettings(state, axisId);
    if (yAxisSettings == null || typeof yAxisSettings.padding !== "string") {
      return 0;
    }
    return selectCalculatedPadding(state, "yAxis", axisId, yAxisSettings.padding);
  };
  var selectXAxisPadding = createSelector(selectXAxisSettings, selectCalculatedXAxisPadding, (xAxisSettings, calculated) => {
    var _padding$left, _padding$right;
    if (xAxisSettings == null) {
      return {
        left: 0,
        right: 0
      };
    }
    var {
      padding
    } = xAxisSettings;
    if (typeof padding === "string") {
      return {
        left: calculated,
        right: calculated
      };
    }
    return {
      left: ((_padding$left = padding.left) !== null && _padding$left !== void 0 ? _padding$left : 0) + calculated,
      right: ((_padding$right = padding.right) !== null && _padding$right !== void 0 ? _padding$right : 0) + calculated
    };
  });
  var selectYAxisPadding = createSelector(selectYAxisSettings, selectCalculatedYAxisPadding, (yAxisSettings, calculated) => {
    var _padding$top, _padding$bottom;
    if (yAxisSettings == null) {
      return {
        top: 0,
        bottom: 0
      };
    }
    var {
      padding
    } = yAxisSettings;
    if (typeof padding === "string") {
      return {
        top: calculated,
        bottom: calculated
      };
    }
    return {
      top: ((_padding$top = padding.top) !== null && _padding$top !== void 0 ? _padding$top : 0) + calculated,
      bottom: ((_padding$bottom = padding.bottom) !== null && _padding$bottom !== void 0 ? _padding$bottom : 0) + calculated
    };
  });
  var combineXAxisRange = createSelector([selectChartOffsetInternal, selectXAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, padding, brushDimensions, _ref4, isPanorama) => {
    var {
      padding: brushPadding
    } = _ref4;
    if (isPanorama) {
      return [brushPadding.left, brushDimensions.width - brushPadding.right];
    }
    return [offset.left + padding.left, offset.left + offset.width - padding.right];
  });
  var combineYAxisRange = createSelector([selectChartOffsetInternal, selectChartLayout, selectYAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, layout, padding, brushDimensions, _ref5, isPanorama) => {
    var {
      padding: brushPadding
    } = _ref5;
    if (isPanorama) {
      return [brushDimensions.height - brushPadding.bottom, brushPadding.top];
    }
    if (layout === "horizontal") {
      return [offset.top + offset.height - padding.bottom, offset.top + padding.top];
    }
    return [offset.top + padding.top, offset.top + offset.height - padding.bottom];
  });
  var selectAxisRange = (state, axisType, axisId, isPanorama) => {
    var _selectZAxisSettings;
    switch (axisType) {
      case "xAxis":
        return combineXAxisRange(state, axisId, isPanorama);
      case "yAxis":
        return combineYAxisRange(state, axisId, isPanorama);
      case "zAxis":
        return (_selectZAxisSettings = selectZAxisSettings(state, axisId)) === null || _selectZAxisSettings === void 0 ? void 0 : _selectZAxisSettings.range;
      case "angleAxis":
        return selectAngleAxisRange(state);
      case "radiusAxis":
        return selectRadiusAxisRange(state, axisId);
      default:
        return void 0;
    }
  };
  var selectAxisRangeWithReverse = createSelector([selectBaseAxis, selectAxisRange], combineAxisRangeWithReverse);
  var selectAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomainIncludingNiceTicks, selectAxisRangeWithReverse], combineScaleFunction);
  var selectErrorBarsSettings = createSelector([selectCartesianItemsSettings, selectAllErrorBarSettings, pickAxisType], combineRelevantErrorBarSettings);
  function compareIds(a2, b) {
    if (a2.id < b.id) {
      return -1;
    }
    if (a2.id > b.id) {
      return 1;
    }
    return 0;
  }
  var pickAxisOrientation = (_state, orientation) => orientation;
  var pickMirror = (_state, _orientation, mirror) => mirror;
  var selectAllXAxesWithOffsetType = createSelector(selectAllXAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter((axis) => axis.orientation === orientation).filter((axis) => axis.mirror === mirror).sort(compareIds));
  var selectAllYAxesWithOffsetType = createSelector(selectAllYAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter((axis) => axis.orientation === orientation).filter((axis) => axis.mirror === mirror).sort(compareIds));
  var getXAxisSize = (offset, axisSettings) => {
    return {
      width: offset.width,
      height: axisSettings.height
    };
  };
  var getYAxisSize = (offset, axisSettings) => {
    var width = typeof axisSettings.width === "number" ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;
    return {
      width,
      height: offset.height
    };
  };
  var selectXAxisSize = createSelector(selectChartOffsetInternal, selectXAxisSettings, getXAxisSize);
  var combineXAxisPositionStartingPoint = (offset, orientation, chartHeight) => {
    switch (orientation) {
      case "top":
        return offset.top;
      case "bottom":
        return chartHeight - offset.bottom;
      default:
        return 0;
    }
  };
  var combineYAxisPositionStartingPoint = (offset, orientation, chartWidth) => {
    switch (orientation) {
      case "left":
        return offset.left;
      case "right":
        return chartWidth - offset.right;
      default:
        return 0;
    }
  };
  var selectAllXAxesOffsetSteps = createSelector(selectChartHeight, selectChartOffsetInternal, selectAllXAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartHeight, offset, allAxesWithSameOffsetType, orientation, mirror) => {
    var steps = {};
    var position2;
    allAxesWithSameOffsetType.forEach((axis) => {
      var axisSize = getXAxisSize(offset, axis);
      if (position2 == null) {
        position2 = combineXAxisPositionStartingPoint(offset, orientation, chartHeight);
      }
      var needSpace = orientation === "top" && !mirror || orientation === "bottom" && mirror;
      steps[axis.id] = position2 - Number(needSpace) * axisSize.height;
      position2 += (needSpace ? -1 : 1) * axisSize.height;
    });
    return steps;
  });
  var selectAllYAxesOffsetSteps = createSelector(selectChartWidth, selectChartOffsetInternal, selectAllYAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartWidth, offset, allAxesWithSameOffsetType, orientation, mirror) => {
    var steps = {};
    var position2;
    allAxesWithSameOffsetType.forEach((axis) => {
      var axisSize = getYAxisSize(offset, axis);
      if (position2 == null) {
        position2 = combineYAxisPositionStartingPoint(offset, orientation, chartWidth);
      }
      var needSpace = orientation === "left" && !mirror || orientation === "right" && mirror;
      steps[axis.id] = position2 - Number(needSpace) * axisSize.width;
      position2 += (needSpace ? -1 : 1) * axisSize.width;
    });
    return steps;
  });
  var selectXAxisPosition = (state, axisId) => {
    var offset = selectChartOffsetInternal(state);
    var axisSettings = selectXAxisSettings(state, axisId);
    if (axisSettings == null) {
      return void 0;
    }
    var allSteps = selectAllXAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);
    var stepOfThisAxis = allSteps[axisId];
    if (stepOfThisAxis == null) {
      return {
        x: offset.left,
        y: 0
      };
    }
    return {
      x: offset.left,
      y: stepOfThisAxis
    };
  };
  var selectYAxisPosition = (state, axisId) => {
    var offset = selectChartOffsetInternal(state);
    var axisSettings = selectYAxisSettings(state, axisId);
    if (axisSettings == null) {
      return void 0;
    }
    var allSteps = selectAllYAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);
    var stepOfThisAxis = allSteps[axisId];
    if (stepOfThisAxis == null) {
      return {
        x: 0,
        y: offset.top
      };
    }
    return {
      x: stepOfThisAxis,
      y: offset.top
    };
  };
  var selectYAxisSize = createSelector(selectChartOffsetInternal, selectYAxisSettings, (offset, axisSettings) => {
    var width = typeof axisSettings.width === "number" ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;
    return {
      width,
      height: offset.height
    };
  });
  var selectCartesianAxisSize = (state, axisType, axisId) => {
    switch (axisType) {
      case "xAxis": {
        return selectXAxisSize(state, axisId).width;
      }
      case "yAxis": {
        return selectYAxisSize(state, axisId).height;
      }
      default: {
        return void 0;
      }
    }
  };
  var combineDuplicateDomain = (chartLayout, appliedValues, axis, axisType) => {
    if (axis == null) {
      return void 0;
    }
    var {
      allowDuplicatedCategory,
      type,
      dataKey
    } = axis;
    var isCategorical = isCategoricalAxis(chartLayout, axisType);
    var allData = appliedValues.map((av) => av.value);
    if (dataKey && isCategorical && type === "category" && allowDuplicatedCategory && hasDuplicate(allData)) {
      return allData;
    }
    return void 0;
  };
  var selectDuplicateDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectBaseAxis, pickAxisType], combineDuplicateDomain);
  var combineCategoricalDomain = (layout, appliedValues, axis, axisType) => {
    if (axis == null || axis.dataKey == null) {
      return void 0;
    }
    var {
      type,
      scale
    } = axis;
    var isCategorical = isCategoricalAxis(layout, axisType);
    if (isCategorical && (type === "number" || scale !== "auto")) {
      return appliedValues.map((d) => d.value);
    }
    return void 0;
  };
  var selectCategoricalDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectAxisSettings, pickAxisType], combineCategoricalDomain);
  var selectAxisPropsNeededForCartesianGridTicksGenerator = createSelector([selectChartLayout, selectCartesianAxisSettings, selectRealScaleType, selectAxisScale, selectDuplicateDomain, selectCategoricalDomain, selectAxisRange, selectNiceTicks, pickAxisType], (layout, axis, realScaleType, scale, duplicateDomain, categoricalDomain, axisRange, niceTicks, axisType) => {
    if (axis == null) {
      return null;
    }
    var isCategorical = isCategoricalAxis(layout, axisType);
    return {
      angle: axis.angle,
      interval: axis.interval,
      minTickGap: axis.minTickGap,
      orientation: axis.orientation,
      tick: axis.tick,
      tickCount: axis.tickCount,
      tickFormatter: axis.tickFormatter,
      ticks: axis.ticks,
      type: axis.type,
      unit: axis.unit,
      axisType,
      categoricalDomain,
      duplicateDomain,
      isCategorical,
      niceTicks,
      range: axisRange,
      realScaleType,
      scale
    };
  });
  var combineAxisTicks = (layout, axis, realScaleType, scale, niceTicks, axisRange, duplicateDomain, categoricalDomain, axisType) => {
    if (axis == null || scale == null) {
      return void 0;
    }
    var isCategorical = isCategoricalAxis(layout, axisType);
    var {
      type,
      ticks: ticks2,
      tickCount
    } = axis;
    var offsetForBand = realScaleType === "scaleBand" && typeof scale.bandwidth === "function" ? scale.bandwidth() / 2 : 2;
    var offset = type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
    offset = axisType === "angleAxis" && axisRange != null && axisRange.length >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;
    var ticksOrNiceTicks = ticks2 || niceTicks;
    if (ticksOrNiceTicks) {
      var result = ticksOrNiceTicks.map((entry, index2) => {
        var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
        return {
          index: index2,
          // If the scaleContent is not a number, the coordinate will be NaN.
          // That could be the case for example with a PointScale and a string as domain.
          coordinate: scale(scaleContent) + offset,
          value: entry,
          offset
        };
      });
      return result.filter((row) => !isNan(row.coordinate));
    }
    if (isCategorical && categoricalDomain) {
      return categoricalDomain.map((entry, index2) => ({
        coordinate: scale(entry) + offset,
        value: entry,
        index: index2,
        offset
      }));
    }
    if (scale.ticks) {
      return scale.ticks(tickCount).map((entry) => ({
        coordinate: scale(entry) + offset,
        value: entry,
        offset
      }));
    }
    return scale.domain().map((entry, index2) => ({
      coordinate: scale(entry) + offset,
      value: duplicateDomain ? duplicateDomain[entry] : entry,
      index: index2,
      offset
    }));
  };
  var selectTicksOfAxis = createSelector([selectChartLayout, selectAxisSettings, selectRealScaleType, selectAxisScale, selectNiceTicks, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineAxisTicks);
  var combineGraphicalItemTicks = (layout, axis, scale, axisRange, duplicateDomain, categoricalDomain, axisType) => {
    if (axis == null || scale == null || axisRange == null || axisRange[0] === axisRange[1]) {
      return void 0;
    }
    var isCategorical = isCategoricalAxis(layout, axisType);
    var {
      tickCount
    } = axis;
    var offset = 0;
    offset = axisType === "angleAxis" && (axisRange === null || axisRange === void 0 ? void 0 : axisRange.length) >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;
    if (isCategorical && categoricalDomain) {
      return categoricalDomain.map((entry, index2) => ({
        coordinate: scale(entry) + offset,
        value: entry,
        index: index2,
        offset
      }));
    }
    if (scale.ticks) {
      return scale.ticks(tickCount).map((entry) => ({
        coordinate: scale(entry) + offset,
        value: entry,
        offset
      }));
    }
    return scale.domain().map((entry, index2) => ({
      coordinate: scale(entry) + offset,
      value: duplicateDomain ? duplicateDomain[entry] : entry,
      index: index2,
      offset
    }));
  };
  var selectTicksOfGraphicalItem = createSelector([selectChartLayout, selectAxisSettings, selectAxisScale, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineGraphicalItemTicks);
  var selectAxisWithScale = createSelector(selectBaseAxis, selectAxisScale, (axis, scale) => {
    if (axis == null || scale == null) {
      return void 0;
    }
    return _objectSpread$J(_objectSpread$J({}, axis), {}, {
      scale
    });
  });
  var selectZAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomain, selectAxisRangeWithReverse], combineScaleFunction);
  var selectZAxisWithScale = createSelector((state, _axisType, axisId) => selectZAxisSettings(state, axisId), selectZAxisScale, (axis, scale) => {
    if (axis == null || scale == null) {
      return void 0;
    }
    return _objectSpread$J(_objectSpread$J({}, axis), {}, {
      scale
    });
  });
  var selectChartDirection = createSelector([selectChartLayout, selectAllXAxes, selectAllYAxes], (layout, allXAxes, allYAxes) => {
    switch (layout) {
      case "horizontal": {
        return allXAxes.some((axis) => axis.reversed) ? "right-to-left" : "left-to-right";
      }
      case "vertical": {
        return allYAxes.some((axis) => axis.reversed) ? "bottom-to-top" : "top-to-bottom";
      }
      case "centric":
      case "radial": {
        return "left-to-right";
      }
      default: {
        return void 0;
      }
    }
  });
  var selectDefaultTooltipEventType = (state) => state.options.defaultTooltipEventType;
  var selectValidateTooltipEventTypes = (state) => state.options.validateTooltipEventTypes;
  function combineTooltipEventType(shared, defaultTooltipEventType, validateTooltipEventTypes) {
    if (shared == null) {
      return defaultTooltipEventType;
    }
    var eventType = shared ? "axis" : "item";
    if (validateTooltipEventTypes == null) {
      return defaultTooltipEventType;
    }
    return validateTooltipEventTypes.includes(eventType) ? eventType : defaultTooltipEventType;
  }
  function selectTooltipEventType$1(state, shared) {
    var defaultTooltipEventType = selectDefaultTooltipEventType(state);
    var validateTooltipEventTypes = selectValidateTooltipEventTypes(state);
    return combineTooltipEventType(shared, defaultTooltipEventType, validateTooltipEventTypes);
  }
  function useTooltipEventType(shared) {
    return useAppSelector((state) => selectTooltipEventType$1(state, shared));
  }
  var combineActiveLabel = (tooltipTicks, activeIndex) => {
    var _tooltipTicks$n;
    var n = Number(activeIndex);
    if (isNan(n) || activeIndex == null) {
      return void 0;
    }
    return n >= 0 ? tooltipTicks === null || tooltipTicks === void 0 || (_tooltipTicks$n = tooltipTicks[n]) === null || _tooltipTicks$n === void 0 ? void 0 : _tooltipTicks$n.value : void 0;
  };
  var selectTooltipSettings = (state) => state.tooltip.settings;
  var noInteraction = {
    active: false,
    index: null,
    dataKey: void 0,
    coordinate: void 0
  };
  var initialState$8 = {
    itemInteraction: {
      click: noInteraction,
      hover: noInteraction
    },
    axisInteraction: {
      click: noInteraction,
      hover: noInteraction
    },
    keyboardInteraction: noInteraction,
    syncInteraction: {
      active: false,
      index: null,
      dataKey: void 0,
      label: void 0,
      coordinate: void 0
    },
    tooltipItemPayloads: [],
    settings: {
      shared: void 0,
      trigger: "hover",
      axisId: 0,
      active: false,
      defaultIndex: void 0
    }
  };
  var tooltipSlice = createSlice({
    name: "tooltip",
    initialState: initialState$8,
    reducers: {
      addTooltipEntrySettings(state, action) {
        state.tooltipItemPayloads.push(castDraft(action.payload));
      },
      removeTooltipEntrySettings(state, action) {
        var index2 = current(state).tooltipItemPayloads.indexOf(castDraft(action.payload));
        if (index2 > -1) {
          state.tooltipItemPayloads.splice(index2, 1);
        }
      },
      setTooltipSettingsState(state, action) {
        state.settings = action.payload;
      },
      setActiveMouseOverItemIndex(state, action) {
        state.syncInteraction.active = false;
        state.keyboardInteraction.active = false;
        state.itemInteraction.hover.active = true;
        state.itemInteraction.hover.index = action.payload.activeIndex;
        state.itemInteraction.hover.dataKey = action.payload.activeDataKey;
        state.itemInteraction.hover.coordinate = action.payload.activeCoordinate;
      },
      mouseLeaveChart(state) {
        state.itemInteraction.hover.active = false;
        state.axisInteraction.hover.active = false;
      },
      mouseLeaveItem(state) {
        state.itemInteraction.hover.active = false;
      },
      setActiveClickItemIndex(state, action) {
        state.syncInteraction.active = false;
        state.itemInteraction.click.active = true;
        state.keyboardInteraction.active = false;
        state.itemInteraction.click.index = action.payload.activeIndex;
        state.itemInteraction.click.dataKey = action.payload.activeDataKey;
        state.itemInteraction.click.coordinate = action.payload.activeCoordinate;
      },
      setMouseOverAxisIndex(state, action) {
        state.syncInteraction.active = false;
        state.axisInteraction.hover.active = true;
        state.keyboardInteraction.active = false;
        state.axisInteraction.hover.index = action.payload.activeIndex;
        state.axisInteraction.hover.dataKey = action.payload.activeDataKey;
        state.axisInteraction.hover.coordinate = action.payload.activeCoordinate;
      },
      setMouseClickAxisIndex(state, action) {
        state.syncInteraction.active = false;
        state.keyboardInteraction.active = false;
        state.axisInteraction.click.active = true;
        state.axisInteraction.click.index = action.payload.activeIndex;
        state.axisInteraction.click.dataKey = action.payload.activeDataKey;
        state.axisInteraction.click.coordinate = action.payload.activeCoordinate;
      },
      setSyncInteraction(state, action) {
        state.syncInteraction = action.payload;
      },
      setKeyboardInteraction(state, action) {
        state.keyboardInteraction.active = action.payload.active;
        state.keyboardInteraction.index = action.payload.activeIndex;
        state.keyboardInteraction.coordinate = action.payload.activeCoordinate;
        state.keyboardInteraction.dataKey = action.payload.activeDataKey;
      }
    }
  });
  var {
    addTooltipEntrySettings,
    removeTooltipEntrySettings,
    setTooltipSettingsState,
    setActiveMouseOverItemIndex,
    mouseLeaveItem,
    mouseLeaveChart,
    setActiveClickItemIndex,
    setMouseOverAxisIndex,
    setMouseClickAxisIndex,
    setSyncInteraction,
    setKeyboardInteraction
  } = tooltipSlice.actions;
  var tooltipReducer = tooltipSlice.reducer;
  function ownKeys$I(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$I(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$I(Object(t), true).forEach(function(r3) {
        _defineProperty$M(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$I(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$M(e, r2, t) {
    return (r2 = _toPropertyKey$M(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$M(t) {
    var i = _toPrimitive$M(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$M(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function chooseAppropriateMouseInteraction(tooltipState, tooltipEventType, trigger) {
    if (tooltipEventType === "axis") {
      if (trigger === "click") {
        return tooltipState.axisInteraction.click;
      }
      return tooltipState.axisInteraction.hover;
    }
    if (trigger === "click") {
      return tooltipState.itemInteraction.click;
    }
    return tooltipState.itemInteraction.hover;
  }
  function hasBeenActivePreviously(tooltipInteractionState) {
    return tooltipInteractionState.index != null;
  }
  var combineTooltipInteractionState = (tooltipState, tooltipEventType, trigger, defaultIndex) => {
    if (tooltipEventType == null) {
      return noInteraction;
    }
    var appropriateMouseInteraction = chooseAppropriateMouseInteraction(tooltipState, tooltipEventType, trigger);
    if (appropriateMouseInteraction == null) {
      return noInteraction;
    }
    if (appropriateMouseInteraction.active) {
      return appropriateMouseInteraction;
    }
    if (tooltipState.keyboardInteraction.active) {
      return tooltipState.keyboardInteraction;
    }
    if (tooltipState.syncInteraction.active && tooltipState.syncInteraction.index != null) {
      return tooltipState.syncInteraction;
    }
    var activeFromProps = tooltipState.settings.active === true;
    if (hasBeenActivePreviously(appropriateMouseInteraction)) {
      if (activeFromProps) {
        return _objectSpread$I(_objectSpread$I({}, appropriateMouseInteraction), {}, {
          active: true
        });
      }
    } else if (defaultIndex != null) {
      return {
        active: true,
        coordinate: void 0,
        dataKey: void 0,
        index: defaultIndex
      };
    }
    return _objectSpread$I(_objectSpread$I({}, noInteraction), {}, {
      coordinate: appropriateMouseInteraction.coordinate
    });
  };
  var combineActiveTooltipIndex = (tooltipInteraction, chartData) => {
    var desiredIndex = tooltipInteraction === null || tooltipInteraction === void 0 ? void 0 : tooltipInteraction.index;
    if (desiredIndex == null) {
      return null;
    }
    var indexAsNumber = Number(desiredIndex);
    if (!isWellBehavedNumber(indexAsNumber)) {
      return desiredIndex;
    }
    var lowerLimit = 0;
    var upperLimit = Infinity;
    if (chartData.length > 0) {
      upperLimit = chartData.length - 1;
    }
    return String(Math.max(lowerLimit, Math.min(indexAsNumber, upperLimit)));
  };
  var combineCoordinateForDefaultIndex = (width, height, layout, offset, tooltipTicks, defaultIndex, tooltipConfigurations, tooltipPayloadSearcher) => {
    if (defaultIndex == null || tooltipPayloadSearcher == null) {
      return void 0;
    }
    var firstConfiguration = tooltipConfigurations[0];
    var maybePosition = firstConfiguration == null ? void 0 : tooltipPayloadSearcher(firstConfiguration.positions, defaultIndex);
    if (maybePosition != null) {
      return maybePosition;
    }
    var tick = tooltipTicks === null || tooltipTicks === void 0 ? void 0 : tooltipTicks[Number(defaultIndex)];
    if (!tick) {
      return void 0;
    }
    switch (layout) {
      case "horizontal": {
        return {
          x: tick.coordinate,
          y: (offset.top + height) / 2
        };
      }
      default: {
        return {
          x: (offset.left + width) / 2,
          y: tick.coordinate
        };
      }
    }
  };
  var combineTooltipPayloadConfigurations = (tooltipState, tooltipEventType, trigger, defaultIndex) => {
    if (tooltipEventType === "axis") {
      return tooltipState.tooltipItemPayloads;
    }
    if (tooltipState.tooltipItemPayloads.length === 0) {
      return [];
    }
    var filterByDataKey;
    if (trigger === "hover") {
      filterByDataKey = tooltipState.itemInteraction.hover.dataKey;
    } else {
      filterByDataKey = tooltipState.itemInteraction.click.dataKey;
    }
    if (filterByDataKey == null && defaultIndex != null) {
      return [tooltipState.tooltipItemPayloads[0]];
    }
    return tooltipState.tooltipItemPayloads.filter((tpc) => {
      var _tpc$settings;
      return ((_tpc$settings = tpc.settings) === null || _tpc$settings === void 0 ? void 0 : _tpc$settings.dataKey) === filterByDataKey;
    });
  };
  var selectTooltipPayloadSearcher = (state) => state.options.tooltipPayloadSearcher;
  var selectTooltipState = (state) => state.tooltip;
  function ownKeys$H(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$H(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$H(Object(t), true).forEach(function(r3) {
        _defineProperty$L(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$H(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$L(e, r2, t) {
    return (r2 = _toPropertyKey$L(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$L(t) {
    var i = _toPrimitive$L(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$L(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function selectFinalData(dataDefinedOnItem, dataDefinedOnChart) {
    if (dataDefinedOnItem != null) {
      return dataDefinedOnItem;
    }
    return dataDefinedOnChart;
  }
  var combineTooltipPayload = (tooltipPayloadConfigurations, activeIndex, chartDataState, tooltipAxis, activeLabel, tooltipPayloadSearcher, tooltipEventType) => {
    if (activeIndex == null || tooltipPayloadSearcher == null) {
      return void 0;
    }
    var {
      chartData,
      computedData,
      dataStartIndex,
      dataEndIndex
    } = chartDataState;
    var init = [];
    return tooltipPayloadConfigurations.reduce((agg, _ref2) => {
      var _settings$dataKey;
      var {
        dataDefinedOnItem,
        settings
      } = _ref2;
      var finalData = selectFinalData(dataDefinedOnItem, chartData);
      var sliced = Array.isArray(finalData) ? getSliced(finalData, dataStartIndex, dataEndIndex) : finalData;
      var finalDataKey = (_settings$dataKey = settings === null || settings === void 0 ? void 0 : settings.dataKey) !== null && _settings$dataKey !== void 0 ? _settings$dataKey : tooltipAxis === null || tooltipAxis === void 0 ? void 0 : tooltipAxis.dataKey;
      var finalNameKey = settings === null || settings === void 0 ? void 0 : settings.nameKey;
      var tooltipPayload;
      if (tooltipAxis !== null && tooltipAxis !== void 0 && tooltipAxis.dataKey && Array.isArray(sliced) && /*
       * findEntryInArray won't work for Scatter because Scatter provides an array of arrays
       * as tooltip payloads and findEntryInArray is not prepared to handle that.
       * Sad but also ScatterChart only allows 'item' tooltipEventType
       * and also this is only a problem if there are multiple Scatters and each has its own data array
       * so let's fix that some other time.
       */
      !Array.isArray(sliced[0]) && /*
       * If the tooltipEventType is 'axis', we should search for the dataKey in the sliced data
       * because thanks to allowDuplicatedCategory=false, the order of elements in the array
       * no longer matches the order of elements in the original data
       * and so we need to search by the active dataKey + label rather than by index.
       *
       * The same happens if multiple graphical items are present in the chart
       * and each of them has its own data array. Those arrays get concatenated
       * and again the tooltip index no longer matches the original data.
       *
       * On the other hand the tooltipEventType 'item' should always search by index
       * because we get the index from interacting over the individual elements
       * which is always accurate, irrespective of the allowDuplicatedCategory setting.
       */
      tooltipEventType === "axis") {
        tooltipPayload = findEntryInArray(sliced, tooltipAxis.dataKey, activeLabel);
      } else {
        tooltipPayload = tooltipPayloadSearcher(sliced, activeIndex, computedData, finalNameKey);
      }
      if (Array.isArray(tooltipPayload)) {
        tooltipPayload.forEach((item) => {
          var newSettings = _objectSpread$H(_objectSpread$H({}, settings), {}, {
            name: item.name,
            unit: item.unit,
            // color and fill are erased to keep 100% the identical behaviour to recharts 2.x - but there's nothing stopping us from returning them here. It's technically a breaking change.
            color: void 0,
            // color and fill are erased to keep 100% the identical behaviour to recharts 2.x - but there's nothing stopping us from returning them here. It's technically a breaking change.
            fill: void 0
          });
          agg.push(getTooltipEntry({
            tooltipEntrySettings: newSettings,
            dataKey: item.dataKey,
            payload: item.payload,
            // @ts-expect-error getValueByDataKey does not validate the output type
            value: getValueByDataKey(item.payload, item.dataKey),
            name: item.name
          }));
        });
      } else {
        var _getValueByDataKey;
        agg.push(getTooltipEntry({
          tooltipEntrySettings: settings,
          dataKey: finalDataKey,
          payload: tooltipPayload,
          // @ts-expect-error getValueByDataKey does not validate the output type
          value: getValueByDataKey(tooltipPayload, finalDataKey),
          // @ts-expect-error getValueByDataKey does not validate the output type
          name: (_getValueByDataKey = getValueByDataKey(tooltipPayload, finalNameKey)) !== null && _getValueByDataKey !== void 0 ? _getValueByDataKey : settings === null || settings === void 0 ? void 0 : settings.name
        }));
      }
      return agg;
    }, init);
  };
  var selectTooltipAxisRealScaleType = createSelector([selectTooltipAxis, selectChartLayout, selectHasBar, selectChartName, selectTooltipAxisType], combineRealScaleType);
  var selectAllUnfilteredGraphicalItems = createSelector([(state) => state.graphicalItems.cartesianItems, (state) => state.graphicalItems.polarItems], (cartesianItems, polarItems) => [...cartesianItems, ...polarItems]);
  var selectTooltipAxisPredicate = createSelector([selectTooltipAxisType, selectTooltipAxisId], itemAxisPredicate);
  var selectAllGraphicalItemsSettings = createSelector([selectAllUnfilteredGraphicalItems, selectTooltipAxis, selectTooltipAxisPredicate], combineGraphicalItemsSettings);
  var selectAllStackedGraphicalItemsSettings = createSelector([selectAllGraphicalItemsSettings], (graphicalItems) => graphicalItems.filter(isStacked));
  var selectTooltipGraphicalItemsData = createSelector([selectAllGraphicalItemsSettings], combineGraphicalItemsData);
  var selectTooltipDisplayedData = createSelector([selectTooltipGraphicalItemsData, selectChartDataWithIndexes], combineDisplayedData);
  var selectTooltipStackedData = createSelector([selectAllStackedGraphicalItemsSettings, selectChartDataWithIndexes, selectTooltipAxis], combineDisplayedStackedData);
  var selectAllTooltipAppliedValues = createSelector([selectTooltipDisplayedData, selectTooltipAxis, selectAllGraphicalItemsSettings], combineAppliedValues);
  var selectTooltipAxisDomainDefinition = createSelector([selectTooltipAxis], getDomainDefinition);
  var selectAllStackedGraphicalItems = createSelector([selectAllGraphicalItemsSettings], (graphicalItems) => graphicalItems.filter(isStacked));
  var selectTooltipStackGroups = createSelector([selectTooltipStackedData, selectAllStackedGraphicalItems, selectStackOffsetType], combineStackGroups);
  var selectTooltipDomainOfStackGroups = createSelector([selectTooltipStackGroups, selectChartDataWithIndexes, selectTooltipAxisType], combineDomainOfStackGroups);
  var selectTooltipItemsSettingsExceptStacked = createSelector([selectAllGraphicalItemsSettings], filterGraphicalNotStackedItems);
  var selectTooltipAllAppliedNumericalValuesIncludingErrorValues = createSelector([selectTooltipDisplayedData, selectTooltipAxis, selectTooltipItemsSettingsExceptStacked, selectAllErrorBarSettings, selectTooltipAxisType], combineAppliedNumericalValuesIncludingErrorValues);
  var selectReferenceDotsByTooltipAxis = createSelector([selectReferenceDots, selectTooltipAxisType, selectTooltipAxisId], filterReferenceElements);
  var selectTooltipReferenceDotsDomain = createSelector([selectReferenceDotsByTooltipAxis, selectTooltipAxisType], combineDotsDomain);
  var selectReferenceAreasByTooltipAxis = createSelector([selectReferenceAreas, selectTooltipAxisType, selectTooltipAxisId], filterReferenceElements);
  var selectTooltipReferenceAreasDomain = createSelector([selectReferenceAreasByTooltipAxis, selectTooltipAxisType], combineAreasDomain);
  var selectReferenceLinesByTooltipAxis = createSelector([selectReferenceLines, selectTooltipAxisType, selectTooltipAxisId], filterReferenceElements);
  var selectTooltipReferenceLinesDomain = createSelector([selectReferenceLinesByTooltipAxis, selectTooltipAxisType], combineLinesDomain);
  var selectTooltipReferenceElementsDomain = createSelector([selectTooltipReferenceDotsDomain, selectTooltipReferenceLinesDomain, selectTooltipReferenceAreasDomain], mergeDomains);
  var selectTooltipNumericalDomain = createSelector([selectTooltipAxis, selectTooltipAxisDomainDefinition, selectTooltipDomainOfStackGroups, selectTooltipAllAppliedNumericalValuesIncludingErrorValues, selectTooltipReferenceElementsDomain, selectChartLayout, selectTooltipAxisType], combineNumericalDomain);
  var selectTooltipAxisDomain = createSelector([selectTooltipAxis, selectChartLayout, selectTooltipDisplayedData, selectAllTooltipAppliedValues, selectStackOffsetType, selectTooltipAxisType, selectTooltipNumericalDomain], combineAxisDomain);
  var selectTooltipNiceTicks = createSelector([selectTooltipAxisDomain, selectTooltipAxis, selectTooltipAxisRealScaleType], combineNiceTicks);
  var selectTooltipAxisDomainIncludingNiceTicks = createSelector([selectTooltipAxis, selectTooltipAxisDomain, selectTooltipNiceTicks, selectTooltipAxisType], combineAxisDomainWithNiceTicks);
  var selectTooltipAxisRange = (state) => {
    var axisType = selectTooltipAxisType(state);
    var axisId = selectTooltipAxisId(state);
    var isPanorama = false;
    return selectAxisRange(state, axisType, axisId, isPanorama);
  };
  var selectTooltipAxisRangeWithReverse = createSelector([selectTooltipAxis, selectTooltipAxisRange], combineAxisRangeWithReverse);
  var selectTooltipAxisScale = createSelector([selectTooltipAxis, selectTooltipAxisRealScaleType, selectTooltipAxisDomainIncludingNiceTicks, selectTooltipAxisRangeWithReverse], combineScaleFunction);
  var selectTooltipDuplicateDomain = createSelector([selectChartLayout, selectAllTooltipAppliedValues, selectTooltipAxis, selectTooltipAxisType], combineDuplicateDomain);
  var selectTooltipCategoricalDomain = createSelector([selectChartLayout, selectAllTooltipAppliedValues, selectTooltipAxis, selectTooltipAxisType], combineCategoricalDomain);
  var combineTicksOfTooltipAxis = (layout, axis, realScaleType, scale, range2, duplicateDomain, categoricalDomain, axisType) => {
    if (!axis) {
      return void 0;
    }
    var {
      type
    } = axis;
    var isCategorical = isCategoricalAxis(layout, axisType);
    if (!scale) {
      return void 0;
    }
    var offsetForBand = realScaleType === "scaleBand" && scale.bandwidth ? scale.bandwidth() / 2 : 2;
    var offset = type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
    offset = axisType === "angleAxis" && range2 != null && (range2 === null || range2 === void 0 ? void 0 : range2.length) >= 2 ? mathSign(range2[0] - range2[1]) * 2 * offset : offset;
    if (isCategorical && categoricalDomain) {
      return categoricalDomain.map((entry, index2) => ({
        coordinate: scale(entry) + offset,
        value: entry,
        index: index2,
        offset
      }));
    }
    return scale.domain().map((entry, index2) => ({
      coordinate: scale(entry) + offset,
      value: duplicateDomain ? duplicateDomain[entry] : entry,
      index: index2,
      offset
    }));
  };
  var selectTooltipAxisTicks = createSelector([selectChartLayout, selectTooltipAxis, selectTooltipAxisRealScaleType, selectTooltipAxisScale, selectTooltipAxisRange, selectTooltipDuplicateDomain, selectTooltipCategoricalDomain, selectTooltipAxisType], combineTicksOfTooltipAxis);
  var selectTooltipEventType = createSelector([selectDefaultTooltipEventType, selectValidateTooltipEventTypes, selectTooltipSettings], (defaultTooltipEventType, validateTooltipEventType, settings) => combineTooltipEventType(settings.shared, defaultTooltipEventType, validateTooltipEventType));
  var selectTooltipTrigger = (state) => state.tooltip.settings.trigger;
  var selectDefaultIndex = (state) => state.tooltip.settings.defaultIndex;
  var selectTooltipInteractionState$1 = createSelector([selectTooltipState, selectTooltipEventType, selectTooltipTrigger, selectDefaultIndex], combineTooltipInteractionState);
  var selectActiveTooltipIndex = createSelector([selectTooltipInteractionState$1, selectTooltipDisplayedData], combineActiveTooltipIndex);
  var selectActiveLabel$1 = createSelector([selectTooltipAxisTicks, selectActiveTooltipIndex], combineActiveLabel);
  var selectActiveTooltipDataKey = createSelector([selectTooltipInteractionState$1], (tooltipInteraction) => {
    if (!tooltipInteraction) {
      return void 0;
    }
    return tooltipInteraction.dataKey;
  });
  var selectTooltipPayloadConfigurations$1 = createSelector([selectTooltipState, selectTooltipEventType, selectTooltipTrigger, selectDefaultIndex], combineTooltipPayloadConfigurations);
  var selectTooltipCoordinateForDefaultIndex = createSelector([selectChartWidth, selectChartHeight, selectChartLayout, selectChartOffsetInternal, selectTooltipAxisTicks, selectDefaultIndex, selectTooltipPayloadConfigurations$1, selectTooltipPayloadSearcher], combineCoordinateForDefaultIndex);
  var selectActiveTooltipCoordinate = createSelector([selectTooltipInteractionState$1, selectTooltipCoordinateForDefaultIndex], (tooltipInteractionState, defaultIndexCoordinate) => {
    if (tooltipInteractionState !== null && tooltipInteractionState !== void 0 && tooltipInteractionState.coordinate) {
      return tooltipInteractionState.coordinate;
    }
    return defaultIndexCoordinate;
  });
  var selectIsTooltipActive$1 = createSelector([selectTooltipInteractionState$1], (tooltipInteractionState) => tooltipInteractionState.active);
  var selectActiveTooltipPayload = createSelector([selectTooltipPayloadConfigurations$1, selectActiveTooltipIndex, selectChartDataWithIndexes, selectTooltipAxis, selectActiveLabel$1, selectTooltipPayloadSearcher, selectTooltipEventType], combineTooltipPayload);
  var selectActiveTooltipDataPoints = createSelector([selectActiveTooltipPayload], (payload) => {
    if (payload == null) {
      return void 0;
    }
    var dataPoints = payload.map((p) => p.payload).filter((p) => p != null);
    return Array.from(new Set(dataPoints));
  });
  function ownKeys$G(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$G(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$G(Object(t), true).forEach(function(r3) {
        _defineProperty$K(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$G(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$K(e, r2, t) {
    return (r2 = _toPropertyKey$K(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$K(t) {
    var i = _toPrimitive$K(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$K(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var useTooltipAxis = () => useAppSelector(selectTooltipAxis);
  var useTooltipAxisBandSize = () => {
    var tooltipAxis = useTooltipAxis();
    var tooltipTicks = useAppSelector(selectTooltipAxisTicks);
    var tooltipAxisScale = useAppSelector(selectTooltipAxisScale);
    return getBandSizeOfAxis(_objectSpread$G(_objectSpread$G({}, tooltipAxis), {}, {
      scale: tooltipAxisScale
    }), tooltipTicks);
  };
  var useChartName = () => {
    return useAppSelector(selectChartName);
  };
  var pickTooltipEventType = (_state, tooltipEventType) => tooltipEventType;
  var pickTrigger = (_state, _tooltipEventType, trigger) => trigger;
  var pickDefaultIndex = (_state, _tooltipEventType, _trigger, defaultIndex) => defaultIndex;
  var selectOrderedTooltipTicks = createSelector(selectTooltipAxisTicks, (ticks2) => sortBy$2(ticks2, (o) => o.coordinate));
  var selectTooltipInteractionState = createSelector([selectTooltipState, pickTooltipEventType, pickTrigger, pickDefaultIndex], combineTooltipInteractionState);
  var selectActiveIndex = createSelector([selectTooltipInteractionState, selectTooltipDisplayedData], combineActiveTooltipIndex);
  var selectTooltipDataKey = (state, tooltipEventType, trigger) => {
    if (tooltipEventType == null) {
      return void 0;
    }
    var tooltipState = selectTooltipState(state);
    if (tooltipEventType === "axis") {
      if (trigger === "hover") {
        return tooltipState.axisInteraction.hover.dataKey;
      }
      return tooltipState.axisInteraction.click.dataKey;
    }
    if (trigger === "hover") {
      return tooltipState.itemInteraction.hover.dataKey;
    }
    return tooltipState.itemInteraction.click.dataKey;
  };
  var selectTooltipPayloadConfigurations = createSelector([selectTooltipState, pickTooltipEventType, pickTrigger, pickDefaultIndex], combineTooltipPayloadConfigurations);
  var selectCoordinateForDefaultIndex = createSelector([selectChartWidth, selectChartHeight, selectChartLayout, selectChartOffsetInternal, selectTooltipAxisTicks, pickDefaultIndex, selectTooltipPayloadConfigurations, selectTooltipPayloadSearcher], combineCoordinateForDefaultIndex);
  var selectActiveCoordinate = createSelector([selectTooltipInteractionState, selectCoordinateForDefaultIndex], (tooltipInteractionState, defaultIndexCoordinate) => {
    var _tooltipInteractionSt;
    return (_tooltipInteractionSt = tooltipInteractionState.coordinate) !== null && _tooltipInteractionSt !== void 0 ? _tooltipInteractionSt : defaultIndexCoordinate;
  });
  var selectActiveLabel = createSelector(selectTooltipAxisTicks, selectActiveIndex, combineActiveLabel);
  var selectTooltipPayload = createSelector([selectTooltipPayloadConfigurations, selectActiveIndex, selectChartDataWithIndexes, selectTooltipAxis, selectActiveLabel, selectTooltipPayloadSearcher, pickTooltipEventType], combineTooltipPayload);
  var selectIsTooltipActive = createSelector([selectTooltipInteractionState], (tooltipInteractionState) => {
    return {
      isActive: tooltipInteractionState.active,
      activeIndex: tooltipInteractionState.index
    };
  });
  var combineActiveProps = (chartEvent, layout, polarViewBox, tooltipAxisType, tooltipAxisRange, tooltipTicks, orderedTooltipTicks, offset) => {
    if (!chartEvent || !layout || !tooltipAxisType || !tooltipAxisRange || !tooltipTicks) {
      return void 0;
    }
    var rangeObj = inRange$1(chartEvent.chartX, chartEvent.chartY, layout, polarViewBox, offset);
    if (!rangeObj) {
      return void 0;
    }
    var pos = calculateTooltipPos(rangeObj, layout);
    var activeIndex = calculateActiveTickIndex(pos, orderedTooltipTicks, tooltipTicks, tooltipAxisType, tooltipAxisRange);
    var activeCoordinate = getActiveCoordinate(layout, tooltipTicks, activeIndex, rangeObj);
    return {
      activeIndex: String(activeIndex),
      activeCoordinate
    };
  };
  function _extends$A() {
    return _extends$A = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$A.apply(null, arguments);
  }
  function ownKeys$F(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$F(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$F(Object(t), true).forEach(function(r3) {
        _defineProperty$J(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$F(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$J(e, r2, t) {
    return (r2 = _toPropertyKey$J(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$J(t) {
    var i = _toPrimitive$J(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$J(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function CursorInternal(props) {
    var {
      coordinate,
      payload,
      index: index2,
      offset,
      tooltipAxisBandSize,
      layout,
      cursor,
      tooltipEventType,
      chartName
    } = props;
    var activeCoordinate = coordinate;
    var activePayload = payload;
    var activeTooltipIndex = index2;
    if (!cursor || !activeCoordinate || chartName !== "ScatterChart" && tooltipEventType !== "axis") {
      return null;
    }
    var restProps, cursorComp;
    if (chartName === "ScatterChart") {
      restProps = activeCoordinate;
      cursorComp = Cross;
    } else if (chartName === "BarChart") {
      restProps = getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize);
      cursorComp = Rectangle;
    } else if (layout === "radial") {
      var {
        cx,
        cy,
        radius,
        startAngle,
        endAngle
      } = getRadialCursorPoints(activeCoordinate);
      restProps = {
        cx,
        cy,
        startAngle,
        endAngle,
        innerRadius: radius,
        outerRadius: radius
      };
      cursorComp = Sector;
    } else {
      restProps = {
        points: getCursorPoints(layout, activeCoordinate, offset)
      };
      cursorComp = Curve;
    }
    var extraClassName = typeof cursor === "object" && "className" in cursor ? cursor.className : void 0;
    var cursorProps = _objectSpread$F(_objectSpread$F(_objectSpread$F(_objectSpread$F({
      stroke: "#ccc",
      pointerEvents: "none"
    }, offset), restProps), filterProps(cursor, false)), {}, {
      payload: activePayload,
      payloadIndex: activeTooltipIndex,
      className: clsx("recharts-tooltip-cursor", extraClassName)
    });
    return /* @__PURE__ */ React.isValidElement(cursor) ? /* @__PURE__ */ React.cloneElement(cursor, cursorProps) : /* @__PURE__ */ React.createElement(cursorComp, cursorProps);
  }
  function Cursor(props) {
    var tooltipAxisBandSize = useTooltipAxisBandSize();
    var offset = useOffsetInternal();
    var layout = useChartLayout();
    var chartName = useChartName();
    return /* @__PURE__ */ React__namespace.createElement(CursorInternal, _extends$A({}, props, {
      coordinate: props.coordinate,
      index: props.index,
      payload: props.payload,
      offset,
      layout,
      tooltipAxisBandSize,
      chartName
    }));
  }
  var TooltipPortalContext = /* @__PURE__ */ React.createContext(null);
  var useTooltipPortal = () => React.useContext(TooltipPortalContext);
  var eventemitter3$1 = { exports: {} };
  var eventemitter3 = eventemitter3$1.exports;
  (function(module2) {
    "use strict";
    var has2 = Object.prototype.hasOwnProperty, prefix2 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix2 = false;
    }
    function EE(fn, context, once2) {
      this.fn = fn;
      this.context = context;
      this.once = once2 || false;
    }
    function addListener2(emitter, event, fn, context, once2) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener2 = new EE(fn, context || emitter, once2), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener2, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener2);
      else emitter._events[evt] = [emitter._events[evt], listener2];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has2.call(events, name)) names.push(prefix2 ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length2 = listeners.length, j;
        for (i = 0; i < length2; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener2(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once2(event, fn, context) {
      return addListener2(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener2(event, fn, context, once2) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once2 || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length2 = listeners.length; i < length2; i++) {
          if (listeners[i].fn !== fn || once2 && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix2;
    EventEmitter2.EventEmitter = EventEmitter2;
    if (true) {
      module2.exports = EventEmitter2;
    }
  })(eventemitter3$1);
  var eventemitter3Exports = eventemitter3$1.exports;
  const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
  var eventCenter = new EventEmitter();
  var TOOLTIP_SYNC_EVENT = "recharts.syncEvent.tooltip";
  var BRUSH_SYNC_EVENT = "recharts.syncEvent.brush";
  function arrayTooltipSearcher(data, strIndex) {
    if (!strIndex) return void 0;
    var numIndex = Number.parseInt(strIndex, 10);
    if (isNan(numIndex)) {
      return void 0;
    }
    return data === null || data === void 0 ? void 0 : data[numIndex];
  }
  var initialState$7 = {
    chartName: "",
    tooltipPayloadSearcher: void 0,
    eventEmitter: void 0,
    defaultTooltipEventType: "axis"
  };
  var optionsSlice = createSlice({
    name: "options",
    initialState: initialState$7,
    reducers: {
      createEventEmitter: (state) => {
        if (state.eventEmitter == null) {
          state.eventEmitter = Symbol("rechartsEventEmitter");
        }
      }
    }
  });
  var optionsReducer = optionsSlice.reducer;
  var {
    createEventEmitter
  } = optionsSlice.actions;
  function selectSynchronisedTooltipState(state) {
    return state.tooltip.syncInteraction;
  }
  var initialChartDataState = {
    chartData: void 0,
    computedData: void 0,
    dataStartIndex: 0,
    dataEndIndex: 0
  };
  var chartDataSlice = createSlice({
    name: "chartData",
    initialState: initialChartDataState,
    reducers: {
      setChartData(state, action) {
        state.chartData = action.payload;
        if (action.payload == null) {
          state.dataStartIndex = 0;
          state.dataEndIndex = 0;
          return;
        }
        if (action.payload.length > 0 && state.dataEndIndex !== action.payload.length - 1) {
          state.dataEndIndex = action.payload.length - 1;
        }
      },
      setComputedData(state, action) {
        state.computedData = action.payload;
      },
      setDataStartEndIndexes(state, action) {
        var {
          startIndex,
          endIndex
        } = action.payload;
        if (startIndex != null) {
          state.dataStartIndex = startIndex;
        }
        if (endIndex != null) {
          state.dataEndIndex = endIndex;
        }
      }
    }
  });
  var {
    setChartData,
    setDataStartEndIndexes,
    setComputedData
  } = chartDataSlice.actions;
  var chartDataReducer = chartDataSlice.reducer;
  var noop$3 = () => {
  };
  function useTooltipSyncEventsListener() {
    var mySyncId = useAppSelector(selectSyncId);
    var myEventEmitter = useAppSelector(selectEventEmitter);
    var dispatch = useAppDispatch();
    var syncMethod = useAppSelector(selectSyncMethod);
    var tooltipTicks = useAppSelector(selectTooltipAxisTicks);
    var layout = useChartLayout();
    var viewBox = useViewBox();
    var className = useAppSelector((state) => state.rootProps.className);
    React.useEffect(() => {
      if (mySyncId == null) {
        return noop$3;
      }
      var listener2 = (incomingSyncId, action, emitter) => {
        if (myEventEmitter === emitter) {
          return;
        }
        if (mySyncId !== incomingSyncId) {
          return;
        }
        if (syncMethod === "index") {
          dispatch(action);
          return;
        }
        if (tooltipTicks == null) {
          return;
        }
        var activeTick;
        if (typeof syncMethod === "function") {
          var syncMethodParam = {
            activeTooltipIndex: action.payload.index == null ? void 0 : Number(action.payload.index),
            isTooltipActive: action.payload.active,
            activeIndex: action.payload.index == null ? void 0 : Number(action.payload.index),
            activeLabel: action.payload.label,
            activeDataKey: action.payload.dataKey,
            activeCoordinate: action.payload.coordinate
          };
          var activeTooltipIndex = syncMethod(tooltipTicks, syncMethodParam);
          activeTick = tooltipTicks[activeTooltipIndex];
        } else if (syncMethod === "value") {
          activeTick = tooltipTicks.find((tick) => String(tick.value) === action.payload.label);
        }
        var {
          coordinate
        } = action.payload;
        if (activeTick == null || action.payload.active === false || coordinate == null || viewBox == null) {
          dispatch(setSyncInteraction({
            active: false,
            coordinate: void 0,
            dataKey: void 0,
            index: null,
            label: void 0
          }));
          return;
        }
        var {
          x: x2,
          y: y2
        } = coordinate;
        var validateChartX = Math.min(x2, viewBox.x + viewBox.width);
        var validateChartY = Math.min(y2, viewBox.y + viewBox.height);
        var activeCoordinate = {
          x: layout === "horizontal" ? activeTick.coordinate : validateChartX,
          y: layout === "horizontal" ? validateChartY : activeTick.coordinate
        };
        var syncAction = setSyncInteraction({
          active: action.payload.active,
          coordinate: activeCoordinate,
          dataKey: action.payload.dataKey,
          index: String(activeTick.index),
          label: action.payload.label
        });
        dispatch(syncAction);
      };
      eventCenter.on(TOOLTIP_SYNC_EVENT, listener2);
      return () => {
        eventCenter.off(TOOLTIP_SYNC_EVENT, listener2);
      };
    }, [className, dispatch, myEventEmitter, mySyncId, syncMethod, tooltipTicks, layout, viewBox]);
  }
  function useBrushSyncEventsListener() {
    var mySyncId = useAppSelector(selectSyncId);
    var myEventEmitter = useAppSelector(selectEventEmitter);
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      if (mySyncId == null) {
        return noop$3;
      }
      var listener2 = (incomingSyncId, action, emitter) => {
        if (myEventEmitter === emitter) {
          return;
        }
        if (mySyncId === incomingSyncId) {
          dispatch(setDataStartEndIndexes(action));
        }
      };
      eventCenter.on(BRUSH_SYNC_EVENT, listener2);
      return () => {
        eventCenter.off(BRUSH_SYNC_EVENT, listener2);
      };
    }, [dispatch, myEventEmitter, mySyncId]);
  }
  function useSynchronisedEventsFromOtherCharts() {
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(createEventEmitter());
    }, [dispatch]);
    useTooltipSyncEventsListener();
    useBrushSyncEventsListener();
  }
  function useTooltipChartSynchronisation(tooltipEventType, trigger, activeCoordinate, activeLabel, activeIndex, isTooltipActive) {
    var activeDataKey = useAppSelector((state) => selectTooltipDataKey(state, tooltipEventType, trigger));
    var eventEmitterSymbol = useAppSelector(selectEventEmitter);
    var syncId = useAppSelector(selectSyncId);
    var syncMethod = useAppSelector(selectSyncMethod);
    var tooltipState = useAppSelector(selectSynchronisedTooltipState);
    var isReceivingSynchronisation = tooltipState === null || tooltipState === void 0 ? void 0 : tooltipState.active;
    React.useEffect(() => {
      if (isReceivingSynchronisation) {
        return;
      }
      if (syncId == null) {
        return;
      }
      if (eventEmitterSymbol == null) {
        return;
      }
      var syncAction = setSyncInteraction({
        active: isTooltipActive,
        coordinate: activeCoordinate,
        dataKey: activeDataKey,
        index: activeIndex,
        label: typeof activeLabel === "number" ? String(activeLabel) : activeLabel
      });
      eventCenter.emit(TOOLTIP_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);
    }, [isReceivingSynchronisation, activeCoordinate, activeDataKey, activeIndex, activeLabel, eventEmitterSymbol, syncId, syncMethod, isTooltipActive]);
  }
  function useBrushChartSynchronisation() {
    var syncId = useAppSelector(selectSyncId);
    var eventEmitterSymbol = useAppSelector(selectEventEmitter);
    var brushStartIndex = useAppSelector((state) => state.chartData.dataStartIndex);
    var brushEndIndex = useAppSelector((state) => state.chartData.dataEndIndex);
    React.useEffect(() => {
      if (syncId == null || brushStartIndex == null || brushEndIndex == null || eventEmitterSymbol == null) {
        return;
      }
      var syncAction = {
        startIndex: brushStartIndex,
        endIndex: brushEndIndex
      };
      eventCenter.emit(BRUSH_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);
    }, [brushEndIndex, brushStartIndex, eventEmitterSymbol, syncId]);
  }
  function ownKeys$E(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$E(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$E(Object(t), true).forEach(function(r3) {
        _defineProperty$I(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$E(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$I(e, r2, t) {
    return (r2 = _toPropertyKey$I(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$I(t) {
    var i = _toPrimitive$I(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$I(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function defaultUniqBy(entry) {
    return entry.dataKey;
  }
  function renderContent(content, props) {
    if (/* @__PURE__ */ React__namespace.isValidElement(content)) {
      return /* @__PURE__ */ React__namespace.cloneElement(content, props);
    }
    if (typeof content === "function") {
      return /* @__PURE__ */ React__namespace.createElement(content, props);
    }
    return /* @__PURE__ */ React__namespace.createElement(DefaultTooltipContent, props);
  }
  var emptyPayload = [];
  var defaultTooltipProps = {
    allowEscapeViewBox: {
      x: false,
      y: false
    },
    animationDuration: 400,
    animationEasing: "ease",
    axisId: 0,
    contentStyle: {},
    cursor: true,
    filterNull: true,
    isAnimationActive: !Global.isSsr,
    itemSorter: "name",
    itemStyle: {},
    labelStyle: {},
    offset: 10,
    reverseDirection: {
      x: false,
      y: false
    },
    separator: " : ",
    trigger: "hover",
    useTranslate3d: false,
    wrapperStyle: {}
  };
  function Tooltip(outsideProps) {
    var props = resolveDefaultProps(outsideProps, defaultTooltipProps);
    var {
      active: activeFromProps,
      allowEscapeViewBox,
      animationDuration,
      animationEasing,
      content,
      filterNull,
      isAnimationActive,
      offset,
      payloadUniqBy,
      position: position2,
      reverseDirection,
      useTranslate3d,
      wrapperStyle,
      cursor,
      shared,
      trigger,
      defaultIndex,
      portal: portalFromProps,
      axisId
    } = props;
    var dispatch = useAppDispatch();
    var defaultIndexAsString = typeof defaultIndex === "number" ? String(defaultIndex) : defaultIndex;
    React.useEffect(() => {
      dispatch(setTooltipSettingsState({
        shared,
        trigger,
        axisId,
        active: activeFromProps,
        defaultIndex: defaultIndexAsString
      }));
    }, [dispatch, shared, trigger, axisId, activeFromProps, defaultIndexAsString]);
    var viewBox = useViewBox();
    var accessibilityLayer = useAccessibilityLayer();
    var tooltipEventType = useTooltipEventType(shared);
    var {
      activeIndex,
      isActive
    } = useAppSelector((state) => selectIsTooltipActive(state, tooltipEventType, trigger, defaultIndexAsString));
    var payloadFromRedux = useAppSelector((state) => selectTooltipPayload(state, tooltipEventType, trigger, defaultIndexAsString));
    var labelFromRedux = useAppSelector((state) => selectActiveLabel(state, tooltipEventType, trigger, defaultIndexAsString));
    var coordinate = useAppSelector((state) => selectActiveCoordinate(state, tooltipEventType, trigger, defaultIndexAsString));
    var payload = payloadFromRedux;
    var tooltipPortalFromContext = useTooltipPortal();
    var finalIsActive = activeFromProps !== null && activeFromProps !== void 0 ? activeFromProps : isActive;
    var [lastBoundingBox, updateBoundingBox] = useElementOffset([payload, finalIsActive]);
    var finalLabel = tooltipEventType === "axis" ? labelFromRedux : void 0;
    useTooltipChartSynchronisation(tooltipEventType, trigger, coordinate, finalLabel, activeIndex, finalIsActive);
    var tooltipPortal = portalFromProps !== null && portalFromProps !== void 0 ? portalFromProps : tooltipPortalFromContext;
    if (tooltipPortal == null) {
      return null;
    }
    var finalPayload = payload !== null && payload !== void 0 ? payload : emptyPayload;
    if (!finalIsActive) {
      finalPayload = emptyPayload;
    }
    if (filterNull && finalPayload.length) {
      finalPayload = getUniqPayload(payload.filter((entry) => entry.value != null && (entry.hide !== true || props.includeHidden)), payloadUniqBy, defaultUniqBy);
    }
    var hasPayload = finalPayload.length > 0;
    var tooltipElement = /* @__PURE__ */ React__namespace.createElement(TooltipBoundingBox, {
      allowEscapeViewBox,
      animationDuration,
      animationEasing,
      isAnimationActive,
      active: finalIsActive,
      coordinate,
      hasPayload,
      offset,
      position: position2,
      reverseDirection,
      useTranslate3d,
      viewBox,
      wrapperStyle,
      lastBoundingBox,
      innerRef: updateBoundingBox,
      hasPortalFromProps: Boolean(portalFromProps)
    }, renderContent(content, _objectSpread$E(_objectSpread$E({}, props), {}, {
      // @ts-expect-error renderContent method expects the payload to be mutable, TODO make it immutable
      payload: finalPayload,
      label: finalLabel,
      active: finalIsActive,
      coordinate,
      accessibilityLayer
    })));
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ reactDom.createPortal(tooltipElement, tooltipPortal), finalIsActive && /* @__PURE__ */ React__namespace.createElement(Cursor, {
      cursor,
      tooltipEventType,
      coordinate,
      payload,
      index: activeIndex
    }));
  }
  var throttle$4 = {};
  var debounce$4 = {};
  var debounce$3 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function debounce2(func, debounceMs, { signal, edges } = {}) {
      let pendingThis = void 0;
      let pendingArgs = null;
      const leading = edges != null && edges.includes("leading");
      const trailing = edges == null || edges.includes("trailing");
      const invoke = () => {
        if (pendingArgs !== null) {
          func.apply(pendingThis, pendingArgs);
          pendingThis = void 0;
          pendingArgs = null;
        }
      };
      const onTimerEnd = () => {
        if (trailing) {
          invoke();
        }
        cancel();
      };
      let timeoutId = null;
      const schedule = () => {
        if (timeoutId != null) {
          clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
          timeoutId = null;
          onTimerEnd();
        }, debounceMs);
      };
      const cancelTimer = () => {
        if (timeoutId !== null) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
      };
      const cancel = () => {
        cancelTimer();
        pendingThis = void 0;
        pendingArgs = null;
      };
      const flush = () => {
        invoke();
      };
      const debounced = function(...args) {
        if (signal == null ? void 0 : signal.aborted) {
          return;
        }
        pendingThis = this;
        pendingArgs = args;
        const isFirstCall = timeoutId == null;
        schedule();
        if (leading && isFirstCall) {
          invoke();
        }
      };
      debounced.schedule = schedule;
      debounced.cancel = cancel;
      debounced.flush = flush;
      signal == null ? void 0 : signal.addEventListener("abort", cancel, { once: true });
      return debounced;
    }
    exports3.debounce = debounce2;
  })(debounce$3);
  const debounce$2 = /* @__PURE__ */ getDefaultExportFromCjs(debounce$3);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const debounce$12 = debounce$3;
    function debounce2(func, debounceMs = 0, options2 = {}) {
      if (typeof options2 !== "object") {
        options2 = {};
      }
      const { leading = false, trailing = true, maxWait } = options2;
      const edges = Array(2);
      if (leading) {
        edges[0] = "leading";
      }
      if (trailing) {
        edges[1] = "trailing";
      }
      let result = void 0;
      let pendingAt = null;
      const _debounced = debounce$12.debounce(function(...args) {
        result = func.apply(this, args);
        pendingAt = null;
      }, debounceMs, { edges });
      const debounced = function(...args) {
        if (maxWait != null) {
          if (pendingAt === null) {
            pendingAt = Date.now();
          }
          if (Date.now() - pendingAt >= maxWait) {
            result = func.apply(this, args);
            pendingAt = Date.now();
            _debounced.cancel();
            _debounced.schedule();
            return result;
          }
        }
        _debounced.apply(this, args);
        return result;
      };
      const flush = () => {
        _debounced.flush();
        return result;
      };
      debounced.cancel = _debounced.cancel;
      debounced.flush = flush;
      return debounced;
    }
    exports3.debounce = debounce2;
  })(debounce$4);
  const debounce$1 = /* @__PURE__ */ getDefaultExportFromCjs(debounce$4);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const debounce2 = debounce$4;
    function throttle2(func, throttleMs = 0, options2 = {}) {
      const { leading = true, trailing = true } = options2;
      return debounce2.debounce(func, throttleMs, {
        leading,
        maxWait: throttleMs,
        trailing
      });
    }
    exports3.throttle = throttle2;
  })(throttle$4);
  const throttle$3 = /* @__PURE__ */ getDefaultExportFromCjs(throttle$4);
  var throttle$1 = throttle$4.throttle;
  const throttle$2 = /* @__PURE__ */ getDefaultExportFromCjs(throttle$1);
  var isDev = true;
  var warn = function warn2(condition, format2) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    if (isDev && typeof console !== "undefined" && console.warn) {
      if (format2 === void 0) {
        console.warn("LogUtils requires an error message argument");
      }
      if (!condition) {
        if (format2 === void 0) {
          console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
        } else {
          var argIndex = 0;
          console.warn(format2.replace(/%s/g, () => args[argIndex++]));
        }
      }
    }
  };
  function ownKeys$D(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$D(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$D(Object(t), true).forEach(function(r3) {
        _defineProperty$H(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$D(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$H(e, r2, t) {
    return (r2 = _toPropertyKey$H(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$H(t) {
    var i = _toPrimitive$H(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$H(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var ResponsiveContainer = /* @__PURE__ */ React.forwardRef((_ref2, ref) => {
    var {
      aspect,
      initialDimension = {
        width: -1,
        height: -1
      },
      width = "100%",
      height = "100%",
      /*
       * default min-width to 0 if not specified - 'auto' causes issues with flexbox
       * https://github.com/recharts/recharts/issues/172
       */
      minWidth = 0,
      minHeight,
      maxHeight,
      children,
      debounce: debounce2 = 0,
      id,
      className,
      onResize,
      style = {}
    } = _ref2;
    var containerRef = React.useRef(null);
    var onResizeRef = React.useRef();
    onResizeRef.current = onResize;
    React.useImperativeHandle(ref, () => containerRef.current);
    var [sizes, setSizes] = React.useState({
      containerWidth: initialDimension.width,
      containerHeight: initialDimension.height
    });
    var setContainerSize = React.useCallback((newWidth, newHeight) => {
      setSizes((prevState) => {
        var roundedWidth = Math.round(newWidth);
        var roundedHeight = Math.round(newHeight);
        if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) {
          return prevState;
        }
        return {
          containerWidth: roundedWidth,
          containerHeight: roundedHeight
        };
      });
    }, []);
    React.useEffect(() => {
      var callback = (entries) => {
        var _onResizeRef$current;
        var {
          width: containerWidth2,
          height: containerHeight2
        } = entries[0].contentRect;
        setContainerSize(containerWidth2, containerHeight2);
        (_onResizeRef$current = onResizeRef.current) === null || _onResizeRef$current === void 0 || _onResizeRef$current.call(onResizeRef, containerWidth2, containerHeight2);
      };
      if (debounce2 > 0) {
        callback = throttle$2(callback, debounce2, {
          trailing: true,
          leading: false
        });
      }
      var observer = new ResizeObserver(callback);
      var {
        width: containerWidth,
        height: containerHeight
      } = containerRef.current.getBoundingClientRect();
      setContainerSize(containerWidth, containerHeight);
      observer.observe(containerRef.current);
      return () => {
        observer.disconnect();
      };
    }, [setContainerSize, debounce2]);
    var chartContent = React.useMemo(() => {
      var {
        containerWidth,
        containerHeight
      } = sizes;
      if (containerWidth < 0 || containerHeight < 0) {
        return null;
      }
      warn(isPercent(width) || isPercent(height), "The width(%s) and height(%s) are both fixed numbers,\n       maybe you don't need to use a ResponsiveContainer.", width, height);
      warn(!aspect || aspect > 0, "The aspect(%s) must be greater than zero.", aspect);
      var calculatedWidth = isPercent(width) ? containerWidth : width;
      var calculatedHeight = isPercent(height) ? containerHeight : height;
      if (aspect && aspect > 0) {
        if (calculatedWidth) {
          calculatedHeight = calculatedWidth / aspect;
        } else if (calculatedHeight) {
          calculatedWidth = calculatedHeight * aspect;
        }
        if (maxHeight && calculatedHeight > maxHeight) {
          calculatedHeight = maxHeight;
        }
      }
      warn(calculatedWidth > 0 || calculatedHeight > 0, "The width(%s) and height(%s) of chart should be greater than 0,\n       please check the style of container, or the props width(%s) and height(%s),\n       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the\n       height and width.", calculatedWidth, calculatedHeight, width, height, minWidth, minHeight, aspect);
      return React__namespace.Children.map(children, (child) => {
        return /* @__PURE__ */ React.cloneElement(child, {
          width: calculatedWidth,
          height: calculatedHeight,
          // calculate the actual size and override it.
          style: _objectSpread$D({
            width: calculatedWidth,
            height: calculatedHeight
          }, child.props.style)
        });
      });
    }, [aspect, children, height, maxHeight, minHeight, minWidth, sizes, width]);
    return /* @__PURE__ */ React__namespace.createElement("div", {
      id: id ? "".concat(id) : void 0,
      className: clsx("recharts-responsive-container", className),
      style: _objectSpread$D(_objectSpread$D({}, style), {}, {
        width,
        height,
        minWidth,
        minHeight,
        maxHeight
      }),
      ref: containerRef
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      style: {
        width: 0,
        height: 0,
        overflow: "visible"
      }
    }, chartContent));
  });
  var Cell = (_props) => null;
  Cell.displayName = "Cell";
  function _defineProperty$G(e, r2, t) {
    return (r2 = _toPropertyKey$G(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$G(t) {
    var i = _toPrimitive$G(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$G(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  class LRUCache {
    constructor(maxSize) {
      _defineProperty$G(this, "cache", /* @__PURE__ */ new Map());
      this.maxSize = maxSize;
    }
    get(key) {
      var value = this.cache.get(key);
      if (value !== void 0) {
        this.cache.delete(key);
        this.cache.set(key, value);
      }
      return value;
    }
    set(key, value) {
      if (this.cache.has(key)) {
        this.cache.delete(key);
      } else if (this.cache.size >= this.maxSize) {
        var firstKey = this.cache.keys().next().value;
        this.cache.delete(firstKey);
      }
      this.cache.set(key, value);
    }
    clear() {
      this.cache.clear();
    }
    size() {
      return this.cache.size;
    }
  }
  function ownKeys$C(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$C(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$C(Object(t), true).forEach(function(r3) {
        _defineProperty$F(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$C(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$F(e, r2, t) {
    return (r2 = _toPropertyKey$F(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$F(t) {
    var i = _toPrimitive$F(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$F(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var defaultConfig = {
    cacheSize: 2e3,
    enableCache: true
  };
  var currentConfig = _objectSpread$C({}, defaultConfig);
  var stringCache = new LRUCache(currentConfig.cacheSize);
  var SPAN_STYLE = {
    position: "absolute",
    top: "-20000px",
    left: 0,
    padding: 0,
    margin: 0,
    border: "none",
    whiteSpace: "pre"
  };
  var MEASUREMENT_SPAN_ID = "recharts_measurement_span";
  function createCacheKey(text, style) {
    var fontSize = style.fontSize || "";
    var fontFamily = style.fontFamily || "";
    var fontWeight = style.fontWeight || "";
    var fontStyle = style.fontStyle || "";
    var letterSpacing = style.letterSpacing || "";
    var textTransform = style.textTransform || "";
    return "".concat(text, "|").concat(fontSize, "|").concat(fontFamily, "|").concat(fontWeight, "|").concat(fontStyle, "|").concat(letterSpacing, "|").concat(textTransform);
  }
  var measureTextWithDOM = (text, style) => {
    try {
      var measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
      if (!measurementSpan) {
        measurementSpan = document.createElement("span");
        measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
        measurementSpan.setAttribute("aria-hidden", "true");
        document.body.appendChild(measurementSpan);
      }
      Object.assign(measurementSpan.style, SPAN_STYLE, style);
      measurementSpan.textContent = "".concat(text);
      var rect = measurementSpan.getBoundingClientRect();
      return {
        width: rect.width,
        height: rect.height
      };
    } catch (_unused) {
      return {
        width: 0,
        height: 0
      };
    }
  };
  var getStringSize = function getStringSize2(text) {
    var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (text === void 0 || text === null || Global.isSsr) {
      return {
        width: 0,
        height: 0
      };
    }
    if (!currentConfig.enableCache) {
      return measureTextWithDOM(text, style);
    }
    var cacheKey = createCacheKey(text, style);
    var cachedResult = stringCache.get(cacheKey);
    if (cachedResult) {
      return cachedResult;
    }
    var result = measureTextWithDOM(text, style);
    stringCache.set(cacheKey, result);
    return result;
  };
  var configureTextMeasurement = (config2) => {
    var newConfig = _objectSpread$C(_objectSpread$C({}, currentConfig), config2);
    if (newConfig.cacheSize !== currentConfig.cacheSize) {
      stringCache = new LRUCache(newConfig.cacheSize);
    }
    currentConfig = newConfig;
  };
  var getTextMeasurementConfig = () => _objectSpread$C({}, currentConfig);
  var clearStringCache = () => {
    stringCache.clear();
  };
  var getStringCacheStats = () => ({
    size: stringCache.size(),
    maxSize: currentConfig.cacheSize
  });
  var MULTIPLY_OR_DIVIDE_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
  var ADD_OR_SUBTRACT_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
  var CSS_LENGTH_UNIT_REGEX = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/;
  var NUM_SPLIT_REGEX = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/;
  var CONVERSION_RATES = {
    cm: 96 / 2.54,
    mm: 96 / 25.4,
    pt: 96 / 72,
    pc: 96 / 6,
    in: 96,
    Q: 96 / (2.54 * 40),
    px: 1
  };
  var FIXED_CSS_LENGTH_UNITS = Object.keys(CONVERSION_RATES);
  var STR_NAN = "NaN";
  function convertToPx(value, unit2) {
    return value * CONVERSION_RATES[unit2];
  }
  class DecimalCSS {
    static parse(str) {
      var _NUM_SPLIT_REGEX$exec;
      var [, numStr, unit2] = (_NUM_SPLIT_REGEX$exec = NUM_SPLIT_REGEX.exec(str)) !== null && _NUM_SPLIT_REGEX$exec !== void 0 ? _NUM_SPLIT_REGEX$exec : [];
      return new DecimalCSS(parseFloat(numStr), unit2 !== null && unit2 !== void 0 ? unit2 : "");
    }
    constructor(num, unit2) {
      this.num = num;
      this.unit = unit2;
      this.num = num;
      this.unit = unit2;
      if (isNan(num)) {
        this.unit = "";
      }
      if (unit2 !== "" && !CSS_LENGTH_UNIT_REGEX.test(unit2)) {
        this.num = NaN;
        this.unit = "";
      }
      if (FIXED_CSS_LENGTH_UNITS.includes(unit2)) {
        this.num = convertToPx(num, unit2);
        this.unit = "px";
      }
    }
    add(other) {
      if (this.unit !== other.unit) {
        return new DecimalCSS(NaN, "");
      }
      return new DecimalCSS(this.num + other.num, this.unit);
    }
    subtract(other) {
      if (this.unit !== other.unit) {
        return new DecimalCSS(NaN, "");
      }
      return new DecimalCSS(this.num - other.num, this.unit);
    }
    multiply(other) {
      if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) {
        return new DecimalCSS(NaN, "");
      }
      return new DecimalCSS(this.num * other.num, this.unit || other.unit);
    }
    divide(other) {
      if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) {
        return new DecimalCSS(NaN, "");
      }
      return new DecimalCSS(this.num / other.num, this.unit || other.unit);
    }
    toString() {
      return "".concat(this.num).concat(this.unit);
    }
    isNaN() {
      return isNan(this.num);
    }
  }
  function calculateArithmetic(expr) {
    if (expr.includes(STR_NAN)) {
      return STR_NAN;
    }
    var newExpr = expr;
    while (newExpr.includes("*") || newExpr.includes("/")) {
      var _MULTIPLY_OR_DIVIDE_R;
      var [, leftOperand, operator, rightOperand] = (_MULTIPLY_OR_DIVIDE_R = MULTIPLY_OR_DIVIDE_REGEX.exec(newExpr)) !== null && _MULTIPLY_OR_DIVIDE_R !== void 0 ? _MULTIPLY_OR_DIVIDE_R : [];
      var lTs = DecimalCSS.parse(leftOperand !== null && leftOperand !== void 0 ? leftOperand : "");
      var rTs = DecimalCSS.parse(rightOperand !== null && rightOperand !== void 0 ? rightOperand : "");
      var result = operator === "*" ? lTs.multiply(rTs) : lTs.divide(rTs);
      if (result.isNaN()) {
        return STR_NAN;
      }
      newExpr = newExpr.replace(MULTIPLY_OR_DIVIDE_REGEX, result.toString());
    }
    while (newExpr.includes("+") || /.-\d+(?:\.\d+)?/.test(newExpr)) {
      var _ADD_OR_SUBTRACT_REGE;
      var [, _leftOperand, _operator, _rightOperand] = (_ADD_OR_SUBTRACT_REGE = ADD_OR_SUBTRACT_REGEX.exec(newExpr)) !== null && _ADD_OR_SUBTRACT_REGE !== void 0 ? _ADD_OR_SUBTRACT_REGE : [];
      var _lTs = DecimalCSS.parse(_leftOperand !== null && _leftOperand !== void 0 ? _leftOperand : "");
      var _rTs = DecimalCSS.parse(_rightOperand !== null && _rightOperand !== void 0 ? _rightOperand : "");
      var _result = _operator === "+" ? _lTs.add(_rTs) : _lTs.subtract(_rTs);
      if (_result.isNaN()) {
        return STR_NAN;
      }
      newExpr = newExpr.replace(ADD_OR_SUBTRACT_REGEX, _result.toString());
    }
    return newExpr;
  }
  var PARENTHESES_REGEX = /\(([^()]*)\)/;
  function calculateParentheses(expr) {
    var newExpr = expr;
    var match;
    while ((match = PARENTHESES_REGEX.exec(newExpr)) != null) {
      var [, parentheticalExpression] = match;
      newExpr = newExpr.replace(PARENTHESES_REGEX, calculateArithmetic(parentheticalExpression));
    }
    return newExpr;
  }
  function evaluateExpression(expression) {
    var newExpr = expression.replace(/\s+/g, "");
    newExpr = calculateParentheses(newExpr);
    newExpr = calculateArithmetic(newExpr);
    return newExpr;
  }
  function safeEvaluateExpression(expression) {
    try {
      return evaluateExpression(expression);
    } catch (_unused) {
      return STR_NAN;
    }
  }
  function reduceCSSCalc(expression) {
    var result = safeEvaluateExpression(expression.slice(5, -1));
    if (result === STR_NAN) {
      return "";
    }
    return result;
  }
  var _excluded$u = ["x", "y", "lineHeight", "capHeight", "scaleToFit", "textAnchor", "verticalAnchor", "fill"], _excluded2$e = ["dx", "dy", "angle", "className", "breakAll"];
  function _extends$z() {
    return _extends$z = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$z.apply(null, arguments);
  }
  function _objectWithoutProperties$u(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$u(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$u(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var BREAKING_SPACES = /[ \f\n\r\t\v\u2028\u2029]+/;
  var calculateWordWidths = (_ref2) => {
    var {
      children,
      breakAll,
      style
    } = _ref2;
    try {
      var words2 = [];
      if (!isNullish(children)) {
        if (breakAll) {
          words2 = children.toString().split("");
        } else {
          words2 = children.toString().split(BREAKING_SPACES);
        }
      }
      var wordsWithComputedWidth = words2.map((word) => ({
        word,
        width: getStringSize(word, style).width
      }));
      var spaceWidth = breakAll ? 0 : getStringSize(" ", style).width;
      return {
        wordsWithComputedWidth,
        spaceWidth
      };
    } catch (_unused) {
      return null;
    }
  };
  var calculateWordsByLines = (_ref2, initialWordsWithComputedWith, spaceWidth, lineWidth, scaleToFit) => {
    var {
      maxLines,
      children,
      style,
      breakAll
    } = _ref2;
    var shouldLimitLines = isNumber(maxLines);
    var text = children;
    var calculate = function calculate2() {
      var words2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return words2.reduce((result2, _ref3) => {
        var {
          word,
          width
        } = _ref3;
        var currentLine = result2[result2.length - 1];
        if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < Number(lineWidth))) {
          currentLine.words.push(word);
          currentLine.width += width + spaceWidth;
        } else {
          var newLine = {
            words: [word],
            width
          };
          result2.push(newLine);
        }
        return result2;
      }, []);
    };
    var originalResult = calculate(initialWordsWithComputedWith);
    var findLongestLine = (words2) => words2.reduce((a2, b) => a2.width > b.width ? a2 : b);
    if (!shouldLimitLines || scaleToFit) {
      return originalResult;
    }
    var overflows = originalResult.length > maxLines || findLongestLine(originalResult).width > Number(lineWidth);
    if (!overflows) {
      return originalResult;
    }
    var suffix = "…";
    var checkOverflow = (index2) => {
      var tempText = text.slice(0, index2);
      var words2 = calculateWordWidths({
        breakAll,
        style,
        children: tempText + suffix
      }).wordsWithComputedWidth;
      var result2 = calculate(words2);
      var doesOverflow = result2.length > maxLines || findLongestLine(result2).width > Number(lineWidth);
      return [doesOverflow, result2];
    };
    var start = 0;
    var end = text.length - 1;
    var iterations = 0;
    var trimmedResult;
    while (start <= end && iterations <= text.length - 1) {
      var middle = Math.floor((start + end) / 2);
      var prev = middle - 1;
      var [doesPrevOverflow, result] = checkOverflow(prev);
      var [doesMiddleOverflow] = checkOverflow(middle);
      if (!doesPrevOverflow && !doesMiddleOverflow) {
        start = middle + 1;
      }
      if (doesPrevOverflow && doesMiddleOverflow) {
        end = middle - 1;
      }
      if (!doesPrevOverflow && doesMiddleOverflow) {
        trimmedResult = result;
        break;
      }
      iterations++;
    }
    return trimmedResult || originalResult;
  };
  var getWordsWithoutCalculate = (children) => {
    var words2 = !isNullish(children) ? children.toString().split(BREAKING_SPACES) : [];
    return [{
      words: words2
    }];
  };
  var getWordsByLines = (_ref4) => {
    var {
      width,
      scaleToFit,
      children,
      style,
      breakAll,
      maxLines
    } = _ref4;
    if ((width || scaleToFit) && !Global.isSsr) {
      var wordsWithComputedWidth, spaceWidth;
      var wordWidths = calculateWordWidths({
        breakAll,
        children,
        style
      });
      if (wordWidths) {
        var {
          wordsWithComputedWidth: wcw,
          spaceWidth: sw
        } = wordWidths;
        wordsWithComputedWidth = wcw;
        spaceWidth = sw;
      } else {
        return getWordsWithoutCalculate(children);
      }
      return calculateWordsByLines({
        breakAll,
        children,
        maxLines,
        style
      }, wordsWithComputedWidth, spaceWidth, width, scaleToFit);
    }
    return getWordsWithoutCalculate(children);
  };
  var DEFAULT_FILL = "#808080";
  var Text = /* @__PURE__ */ React.forwardRef((_ref5, ref) => {
    var {
      x: propsX = 0,
      y: propsY = 0,
      lineHeight = "1em",
      // Magic number from d3
      capHeight = "0.71em",
      scaleToFit = false,
      textAnchor = "start",
      // Maintain compat with existing charts / default SVG behavior
      verticalAnchor = "end",
      fill: fill2 = DEFAULT_FILL
    } = _ref5, props = _objectWithoutProperties$u(_ref5, _excluded$u);
    var wordsByLines = React.useMemo(() => {
      return getWordsByLines({
        breakAll: props.breakAll,
        children: props.children,
        maxLines: props.maxLines,
        scaleToFit,
        style: props.style,
        width: props.width
      });
    }, [props.breakAll, props.children, props.maxLines, scaleToFit, props.style, props.width]);
    var {
      dx,
      dy,
      angle,
      className,
      breakAll
    } = props, textProps = _objectWithoutProperties$u(props, _excluded2$e);
    if (!isNumOrStr(propsX) || !isNumOrStr(propsY)) {
      return null;
    }
    var x2 = propsX + (isNumber(dx) ? dx : 0);
    var y2 = propsY + (isNumber(dy) ? dy : 0);
    var startDy;
    switch (verticalAnchor) {
      case "start":
        startDy = reduceCSSCalc("calc(".concat(capHeight, ")"));
        break;
      case "middle":
        startDy = reduceCSSCalc("calc(".concat((wordsByLines.length - 1) / 2, " * -").concat(lineHeight, " + (").concat(capHeight, " / 2))"));
        break;
      default:
        startDy = reduceCSSCalc("calc(".concat(wordsByLines.length - 1, " * -").concat(lineHeight, ")"));
        break;
    }
    var transforms = [];
    if (scaleToFit) {
      var lineWidth = wordsByLines[0].width;
      var {
        width
      } = props;
      transforms.push("scale(".concat(isNumber(width) ? width / lineWidth : 1, ")"));
    }
    if (angle) {
      transforms.push("rotate(".concat(angle, ", ").concat(x2, ", ").concat(y2, ")"));
    }
    if (transforms.length) {
      textProps.transform = transforms.join(" ");
    }
    return /* @__PURE__ */ React__namespace.createElement("text", _extends$z({}, filterProps(textProps, true), {
      ref,
      x: x2,
      y: y2,
      className: clsx("recharts-text", className),
      textAnchor,
      fill: fill2.includes("url") ? DEFAULT_FILL : fill2
    }), wordsByLines.map((line, index2) => {
      var words2 = line.words.join(breakAll ? "" : " ");
      return (
        // duplicate words will cause duplicate keys
        // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */ React__namespace.createElement("tspan", {
          x: x2,
          dy: index2 === 0 ? startDy : lineHeight,
          key: "".concat(words2, "-").concat(index2)
        }, words2)
      );
    }));
  });
  Text.displayName = "Text";
  var _excluded$t = ["offset"], _excluded2$d = ["labelRef"];
  function _objectWithoutProperties$t(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$t(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$t(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function ownKeys$B(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$B(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$B(Object(t), true).forEach(function(r3) {
        _defineProperty$E(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$B(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$E(e, r2, t) {
    return (r2 = _toPropertyKey$E(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$E(t) {
    var i = _toPrimitive$E(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$E(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _extends$y() {
    return _extends$y = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$y.apply(null, arguments);
  }
  var getLabel = (props) => {
    var {
      value,
      formatter
    } = props;
    var label = isNullish(props.children) ? value : props.children;
    if (typeof formatter === "function") {
      return formatter(label);
    }
    return label;
  };
  var isLabelContentAFunction = (content) => {
    return content != null && typeof content === "function";
  };
  var getDeltaAngle = (startAngle, endAngle) => {
    var sign2 = mathSign(endAngle - startAngle);
    var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
    return sign2 * deltaAngle;
  };
  var renderRadialLabel = (labelProps, label, attrs, viewBox) => {
    var {
      position: position2,
      offset,
      className
    } = labelProps;
    var {
      cx,
      cy,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle,
      clockWise
    } = viewBox;
    var radius = (innerRadius + outerRadius) / 2;
    var deltaAngle = getDeltaAngle(startAngle, endAngle);
    var sign2 = deltaAngle >= 0 ? 1 : -1;
    var labelAngle, direction;
    if (position2 === "insideStart") {
      labelAngle = startAngle + sign2 * offset;
      direction = clockWise;
    } else if (position2 === "insideEnd") {
      labelAngle = endAngle - sign2 * offset;
      direction = !clockWise;
    } else if (position2 === "end") {
      labelAngle = endAngle + sign2 * offset;
      direction = clockWise;
    }
    direction = deltaAngle <= 0 ? direction : !direction;
    var startPoint = polarToCartesian(cx, cy, radius, labelAngle);
    var endPoint = polarToCartesian(cx, cy, radius, labelAngle + (direction ? 1 : -1) * 359);
    var path2 = "M".concat(startPoint.x, ",").concat(startPoint.y, "\n    A").concat(radius, ",").concat(radius, ",0,1,").concat(direction ? 0 : 1, ",\n    ").concat(endPoint.x, ",").concat(endPoint.y);
    var id = isNullish(labelProps.id) ? uniqueId("recharts-radial-line-") : labelProps.id;
    return /* @__PURE__ */ React__namespace.createElement("text", _extends$y({}, attrs, {
      dominantBaseline: "central",
      className: clsx("recharts-radial-bar-label", className)
    }), /* @__PURE__ */ React__namespace.createElement("defs", null, /* @__PURE__ */ React__namespace.createElement("path", {
      id,
      d: path2
    })), /* @__PURE__ */ React__namespace.createElement("textPath", {
      xlinkHref: "#".concat(id)
    }, label));
  };
  var getAttrsOfPolarLabel = (viewBox, offset, position2) => {
    var {
      cx,
      cy,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    } = viewBox;
    var midAngle = (startAngle + endAngle) / 2;
    if (position2 === "outside") {
      var {
        x: _x,
        y: _y
      } = polarToCartesian(cx, cy, outerRadius + offset, midAngle);
      return {
        x: _x,
        y: _y,
        textAnchor: _x >= cx ? "start" : "end",
        verticalAnchor: "middle"
      };
    }
    if (position2 === "center") {
      return {
        x: cx,
        y: cy,
        textAnchor: "middle",
        verticalAnchor: "middle"
      };
    }
    if (position2 === "centerTop") {
      return {
        x: cx,
        y: cy,
        textAnchor: "middle",
        verticalAnchor: "start"
      };
    }
    if (position2 === "centerBottom") {
      return {
        x: cx,
        y: cy,
        textAnchor: "middle",
        verticalAnchor: "end"
      };
    }
    var r2 = (innerRadius + outerRadius) / 2;
    var {
      x: x2,
      y: y2
    } = polarToCartesian(cx, cy, r2, midAngle);
    return {
      x: x2,
      y: y2,
      textAnchor: "middle",
      verticalAnchor: "middle"
    };
  };
  var getAttrsOfCartesianLabel = (props, viewBox) => {
    var {
      parentViewBox,
      offset,
      position: position2
    } = props;
    var {
      x: x2,
      y: y2,
      width,
      height
    } = viewBox;
    var verticalSign = height >= 0 ? 1 : -1;
    var verticalOffset = verticalSign * offset;
    var verticalEnd = verticalSign > 0 ? "end" : "start";
    var verticalStart = verticalSign > 0 ? "start" : "end";
    var horizontalSign = width >= 0 ? 1 : -1;
    var horizontalOffset = horizontalSign * offset;
    var horizontalEnd = horizontalSign > 0 ? "end" : "start";
    var horizontalStart = horizontalSign > 0 ? "start" : "end";
    if (position2 === "top") {
      var attrs = {
        x: x2 + width / 2,
        y: y2 - verticalSign * offset,
        textAnchor: "middle",
        verticalAnchor: verticalEnd
      };
      return _objectSpread$B(_objectSpread$B({}, attrs), parentViewBox ? {
        height: Math.max(y2 - parentViewBox.y, 0),
        width
      } : {});
    }
    if (position2 === "bottom") {
      var _attrs = {
        x: x2 + width / 2,
        y: y2 + height + verticalOffset,
        textAnchor: "middle",
        verticalAnchor: verticalStart
      };
      return _objectSpread$B(_objectSpread$B({}, _attrs), parentViewBox ? {
        height: Math.max(parentViewBox.y + parentViewBox.height - (y2 + height), 0),
        width
      } : {});
    }
    if (position2 === "left") {
      var _attrs2 = {
        x: x2 - horizontalOffset,
        y: y2 + height / 2,
        textAnchor: horizontalEnd,
        verticalAnchor: "middle"
      };
      return _objectSpread$B(_objectSpread$B({}, _attrs2), parentViewBox ? {
        width: Math.max(_attrs2.x - parentViewBox.x, 0),
        height
      } : {});
    }
    if (position2 === "right") {
      var _attrs3 = {
        x: x2 + width + horizontalOffset,
        y: y2 + height / 2,
        textAnchor: horizontalStart,
        verticalAnchor: "middle"
      };
      return _objectSpread$B(_objectSpread$B({}, _attrs3), parentViewBox ? {
        width: Math.max(parentViewBox.x + parentViewBox.width - _attrs3.x, 0),
        height
      } : {});
    }
    var sizeAttrs = parentViewBox ? {
      width,
      height
    } : {};
    if (position2 === "insideLeft") {
      return _objectSpread$B({
        x: x2 + horizontalOffset,
        y: y2 + height / 2,
        textAnchor: horizontalStart,
        verticalAnchor: "middle"
      }, sizeAttrs);
    }
    if (position2 === "insideRight") {
      return _objectSpread$B({
        x: x2 + width - horizontalOffset,
        y: y2 + height / 2,
        textAnchor: horizontalEnd,
        verticalAnchor: "middle"
      }, sizeAttrs);
    }
    if (position2 === "insideTop") {
      return _objectSpread$B({
        x: x2 + width / 2,
        y: y2 + verticalOffset,
        textAnchor: "middle",
        verticalAnchor: verticalStart
      }, sizeAttrs);
    }
    if (position2 === "insideBottom") {
      return _objectSpread$B({
        x: x2 + width / 2,
        y: y2 + height - verticalOffset,
        textAnchor: "middle",
        verticalAnchor: verticalEnd
      }, sizeAttrs);
    }
    if (position2 === "insideTopLeft") {
      return _objectSpread$B({
        x: x2 + horizontalOffset,
        y: y2 + verticalOffset,
        textAnchor: horizontalStart,
        verticalAnchor: verticalStart
      }, sizeAttrs);
    }
    if (position2 === "insideTopRight") {
      return _objectSpread$B({
        x: x2 + width - horizontalOffset,
        y: y2 + verticalOffset,
        textAnchor: horizontalEnd,
        verticalAnchor: verticalStart
      }, sizeAttrs);
    }
    if (position2 === "insideBottomLeft") {
      return _objectSpread$B({
        x: x2 + horizontalOffset,
        y: y2 + height - verticalOffset,
        textAnchor: horizontalStart,
        verticalAnchor: verticalEnd
      }, sizeAttrs);
    }
    if (position2 === "insideBottomRight") {
      return _objectSpread$B({
        x: x2 + width - horizontalOffset,
        y: y2 + height - verticalOffset,
        textAnchor: horizontalEnd,
        verticalAnchor: verticalEnd
      }, sizeAttrs);
    }
    if (!!position2 && typeof position2 === "object" && (isNumber(position2.x) || isPercent(position2.x)) && (isNumber(position2.y) || isPercent(position2.y))) {
      return _objectSpread$B({
        x: x2 + getPercentValue(position2.x, width),
        y: y2 + getPercentValue(position2.y, height),
        textAnchor: "end",
        verticalAnchor: "end"
      }, sizeAttrs);
    }
    return _objectSpread$B({
      x: x2 + width / 2,
      y: y2 + height / 2,
      textAnchor: "middle",
      verticalAnchor: "middle"
    }, sizeAttrs);
  };
  var isPolar = (viewBox) => "cx" in viewBox && isNumber(viewBox.cx);
  function Label(_ref2) {
    var {
      offset = 5
    } = _ref2, restProps = _objectWithoutProperties$t(_ref2, _excluded$t);
    var props = _objectSpread$B({
      offset
    }, restProps);
    var {
      viewBox: viewBoxFromProps,
      position: position2,
      value,
      children,
      content,
      className = "",
      textBreakAll,
      labelRef
    } = props;
    var polarViewBox = useAppSelector(selectPolarViewBox);
    var cartesianViewBox = useViewBox();
    var resolvedViewBox = position2 === "center" ? cartesianViewBox : polarViewBox !== null && polarViewBox !== void 0 ? polarViewBox : cartesianViewBox;
    var viewBox = viewBoxFromProps || resolvedViewBox;
    if (!viewBox || isNullish(value) && isNullish(children) && !/* @__PURE__ */ React.isValidElement(content) && typeof content !== "function") {
      return null;
    }
    var propsWithViewBox = _objectSpread$B(_objectSpread$B({}, props), {}, {
      viewBox
    });
    if (/* @__PURE__ */ React.isValidElement(content)) {
      var {
        labelRef: _
      } = propsWithViewBox, propsWithoutLabelRef = _objectWithoutProperties$t(propsWithViewBox, _excluded2$d);
      return /* @__PURE__ */ React.cloneElement(content, propsWithoutLabelRef);
    }
    var label;
    if (typeof content === "function") {
      label = /* @__PURE__ */ React.createElement(content, propsWithViewBox);
      if (/* @__PURE__ */ React.isValidElement(label)) {
        return label;
      }
    } else {
      label = getLabel(props);
    }
    var isPolarLabel = isPolar(viewBox);
    var attrs = filterProps(props, true);
    if (isPolarLabel && (position2 === "insideStart" || position2 === "insideEnd" || position2 === "end")) {
      return renderRadialLabel(props, label, attrs, viewBox);
    }
    var positionAttrs = isPolarLabel ? getAttrsOfPolarLabel(viewBox, props.offset, props.position) : getAttrsOfCartesianLabel(props, viewBox);
    return /* @__PURE__ */ React__namespace.createElement(Text, _extends$y({
      ref: labelRef,
      className: clsx("recharts-label", className)
    }, attrs, positionAttrs, {
      breakAll: textBreakAll
    }), label);
  }
  Label.displayName = "Label";
  var parseViewBox = (props) => {
    var {
      cx,
      cy,
      angle,
      startAngle,
      endAngle,
      r: r2,
      radius,
      innerRadius,
      outerRadius,
      x: x2,
      y: y2,
      top,
      left,
      width,
      height,
      clockWise,
      labelViewBox
    } = props;
    if (labelViewBox) {
      return labelViewBox;
    }
    if (isNumber(width) && isNumber(height)) {
      if (isNumber(x2) && isNumber(y2)) {
        return {
          x: x2,
          y: y2,
          width,
          height
        };
      }
      if (isNumber(top) && isNumber(left)) {
        return {
          x: top,
          y: left,
          width,
          height
        };
      }
    }
    if (isNumber(x2) && isNumber(y2)) {
      return {
        x: x2,
        y: y2,
        width: 0,
        height: 0
      };
    }
    if (isNumber(cx) && isNumber(cy)) {
      return {
        cx,
        cy,
        startAngle: startAngle || angle || 0,
        endAngle: endAngle || angle || 0,
        innerRadius: innerRadius || 0,
        outerRadius: outerRadius || radius || r2 || 0,
        clockWise
      };
    }
    if (props.viewBox) {
      return props.viewBox;
    }
    return void 0;
  };
  var parseLabel = (label, viewBox, labelRef) => {
    if (!label) {
      return null;
    }
    var commonProps = {
      viewBox,
      labelRef
    };
    if (label === true) {
      return /* @__PURE__ */ React__namespace.createElement(Label, _extends$y({
        key: "label-implicit"
      }, commonProps));
    }
    if (isNumOrStr(label)) {
      return /* @__PURE__ */ React__namespace.createElement(Label, _extends$y({
        key: "label-implicit",
        value: label
      }, commonProps));
    }
    if (/* @__PURE__ */ React.isValidElement(label)) {
      if (label.type === Label) {
        return /* @__PURE__ */ React.cloneElement(label, _objectSpread$B({
          key: "label-implicit"
        }, commonProps));
      }
      return /* @__PURE__ */ React__namespace.createElement(Label, _extends$y({
        key: "label-implicit",
        content: label
      }, commonProps));
    }
    if (isLabelContentAFunction(label)) {
      return /* @__PURE__ */ React__namespace.createElement(Label, _extends$y({
        key: "label-implicit",
        content: label
      }, commonProps));
    }
    if (label && typeof label === "object") {
      return /* @__PURE__ */ React__namespace.createElement(Label, _extends$y({}, label, {
        key: "label-implicit"
      }, commonProps));
    }
    return null;
  };
  var renderCallByParent$1 = function renderCallByParent2(parentProps, viewBox) {
    var checkPropsLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) {
      return null;
    }
    var {
      children,
      labelRef
    } = parentProps;
    var parentViewBox = parseViewBox(parentProps);
    var explicitChildren = findAllByType(children, Label).map((child, index2) => {
      return /* @__PURE__ */ React.cloneElement(child, {
        viewBox: viewBox || parentViewBox,
        // eslint-disable-next-line react/no-array-index-key
        key: "label-".concat(index2)
      });
    });
    if (!checkPropsLabel) {
      return explicitChildren;
    }
    var implicitLabel = parseLabel(parentProps.label, viewBox || parentViewBox, labelRef);
    return [implicitLabel, ...explicitChildren];
  };
  Label.parseViewBox = parseViewBox;
  Label.renderCallByParent = renderCallByParent$1;
  var last$6 = {};
  var last$5 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function last2(arr) {
      return arr[arr.length - 1];
    }
    exports3.last = last2;
  })(last$5);
  const last$4 = /* @__PURE__ */ getDefaultExportFromCjs(last$5);
  var toArray$1 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function toArray2(value) {
      return Array.isArray(value) ? value : Array.from(value);
    }
    exports3.toArray = toArray2;
  })(toArray$1);
  const toArray = /* @__PURE__ */ getDefaultExportFromCjs(toArray$1);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const last$12 = last$5;
    const toArray2 = toArray$1;
    const isArrayLike2 = isArrayLike$1;
    function last2(array2) {
      if (!isArrayLike2.isArrayLike(array2)) {
        return void 0;
      }
      return last$12.last(toArray2.toArray(array2));
    }
    exports3.last = last2;
  })(last$6);
  const last$3 = /* @__PURE__ */ getDefaultExportFromCjs(last$6);
  var last$1 = last$6.last;
  const last$2 = /* @__PURE__ */ getDefaultExportFromCjs(last$1);
  var _excluded$s = ["valueAccessor"], _excluded2$c = ["data", "dataKey", "clockWise", "id", "textBreakAll"];
  function _extends$x() {
    return _extends$x = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$x.apply(null, arguments);
  }
  function ownKeys$A(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$A(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$A(Object(t), true).forEach(function(r3) {
        _defineProperty$D(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$A(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$D(e, r2, t) {
    return (r2 = _toPropertyKey$D(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$D(t) {
    var i = _toPrimitive$D(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$D(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _objectWithoutProperties$s(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$s(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$s(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var defaultAccessor = (entry) => Array.isArray(entry.value) ? last$2(entry.value) : entry.value;
  function LabelList(_ref2) {
    var {
      valueAccessor = defaultAccessor
    } = _ref2, restProps = _objectWithoutProperties$s(_ref2, _excluded$s);
    var {
      data,
      dataKey,
      clockWise,
      id,
      textBreakAll
    } = restProps, others = _objectWithoutProperties$s(restProps, _excluded2$c);
    if (!data || !data.length) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: "recharts-label-list"
    }, data.map((entry, index2) => {
      var value = isNullish(dataKey) ? valueAccessor(entry, index2) : getValueByDataKey(entry && entry.payload, dataKey);
      var idProps = isNullish(id) ? {} : {
        id: "".concat(id, "-").concat(index2)
      };
      return /* @__PURE__ */ React__namespace.createElement(Label, _extends$x({}, filterProps(entry, true), others, idProps, {
        parentViewBox: entry.parentViewBox,
        value,
        textBreakAll,
        viewBox: Label.parseViewBox(isNullish(clockWise) ? entry : _objectSpread$A(_objectSpread$A({}, entry), {}, {
          clockWise
        })),
        key: "label-".concat(index2),
        index: index2
      }));
    }));
  }
  LabelList.displayName = "LabelList";
  function parseLabelList(label, data) {
    if (!label) {
      return null;
    }
    if (label === true) {
      return /* @__PURE__ */ React__namespace.createElement(LabelList, {
        key: "labelList-implicit",
        data
      });
    }
    if (/* @__PURE__ */ React__namespace.isValidElement(label) || isLabelContentAFunction(label)) {
      return /* @__PURE__ */ React__namespace.createElement(LabelList, {
        key: "labelList-implicit",
        data,
        content: label
      });
    }
    if (typeof label === "object") {
      return /* @__PURE__ */ React__namespace.createElement(LabelList, _extends$x({
        data
      }, label, {
        key: "labelList-implicit"
      }));
    }
    return null;
  }
  function renderCallByParent(parentProps, data) {
    var checkPropsLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) {
      return null;
    }
    var {
      children
    } = parentProps;
    var explicitChildren = findAllByType(children, LabelList).map((child, index2) => /* @__PURE__ */ React.cloneElement(child, {
      data,
      // eslint-disable-next-line react/no-array-index-key
      key: "labelList-".concat(index2)
    }));
    if (!checkPropsLabel) {
      return explicitChildren;
    }
    var implicitLabelList = parseLabelList(parentProps.label, data);
    return [implicitLabelList, ...explicitChildren];
  }
  LabelList.renderCallByParent = renderCallByParent;
  var _excluded$r = ["component"];
  function _objectWithoutProperties$r(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$r(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$r(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function Customized(_ref2) {
    var {
      component
    } = _ref2, props = _objectWithoutProperties$r(_ref2, _excluded$r);
    var child;
    if (/* @__PURE__ */ React.isValidElement(component)) {
      child = /* @__PURE__ */ React.cloneElement(component, props);
    } else if (typeof component === "function") {
      child = /* @__PURE__ */ React.createElement(component, props);
    } else {
      warn(false, "Customized's props `component` must be React.element or Function, but got %s.", typeof component);
    }
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: "recharts-customized-wrapper"
    }, child);
  }
  Customized.displayName = "Customized";
  var _excluded$q = ["points", "className", "baseLinePoints", "connectNulls"];
  function _extends$w() {
    return _extends$w = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$w.apply(null, arguments);
  }
  function _objectWithoutProperties$q(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$q(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$q(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var isValidatePoint = (point2) => {
    return point2 && point2.x === +point2.x && point2.y === +point2.y;
  };
  var getParsedPoints = function getParsedPoints2() {
    var points = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var segmentPoints = [[]];
    points.forEach((entry) => {
      if (isValidatePoint(entry)) {
        segmentPoints[segmentPoints.length - 1].push(entry);
      } else if (segmentPoints[segmentPoints.length - 1].length > 0) {
        segmentPoints.push([]);
      }
    });
    if (isValidatePoint(points[0])) {
      segmentPoints[segmentPoints.length - 1].push(points[0]);
    }
    if (segmentPoints[segmentPoints.length - 1].length <= 0) {
      segmentPoints = segmentPoints.slice(0, -1);
    }
    return segmentPoints;
  };
  var getSinglePolygonPath = (points, connectNulls) => {
    var segmentPoints = getParsedPoints(points);
    if (connectNulls) {
      segmentPoints = [segmentPoints.reduce((res, segPoints) => {
        return [...res, ...segPoints];
      }, [])];
    }
    var polygonPath = segmentPoints.map((segPoints) => {
      return segPoints.reduce((path2, point2, index2) => {
        return "".concat(path2).concat(index2 === 0 ? "M" : "L").concat(point2.x, ",").concat(point2.y);
      }, "");
    }).join("");
    return segmentPoints.length === 1 ? "".concat(polygonPath, "Z") : polygonPath;
  };
  var getRanglePath = (points, baseLinePoints, connectNulls) => {
    var outerPath = getSinglePolygonPath(points, connectNulls);
    return "".concat(outerPath.slice(-1) === "Z" ? outerPath.slice(0, -1) : outerPath, "L").concat(getSinglePolygonPath(baseLinePoints.reverse(), connectNulls).slice(1));
  };
  var Polygon = (props) => {
    var {
      points,
      className,
      baseLinePoints,
      connectNulls
    } = props, others = _objectWithoutProperties$q(props, _excluded$q);
    if (!points || !points.length) {
      return null;
    }
    var layerClass = clsx("recharts-polygon", className);
    if (baseLinePoints && baseLinePoints.length) {
      var hasStroke = others.stroke && others.stroke !== "none";
      var rangePath = getRanglePath(points, baseLinePoints, connectNulls);
      return /* @__PURE__ */ React__namespace.createElement("g", {
        className: layerClass
      }, /* @__PURE__ */ React__namespace.createElement("path", _extends$w({}, filterProps(others, true), {
        fill: rangePath.slice(-1) === "Z" ? others.fill : "none",
        stroke: "none",
        d: rangePath
      })), hasStroke ? /* @__PURE__ */ React__namespace.createElement("path", _extends$w({}, filterProps(others, true), {
        fill: "none",
        d: getSinglePolygonPath(points, connectNulls)
      })) : null, hasStroke ? /* @__PURE__ */ React__namespace.createElement("path", _extends$w({}, filterProps(others, true), {
        fill: "none",
        d: getSinglePolygonPath(baseLinePoints, connectNulls)
      })) : null);
    }
    var singlePath = getSinglePolygonPath(points, connectNulls);
    return /* @__PURE__ */ React__namespace.createElement("path", _extends$w({}, filterProps(others, true), {
      fill: singlePath.slice(-1) === "Z" ? others.fill : "none",
      className: layerClass,
      d: singlePath
    }));
  };
  function _extends$v() {
    return _extends$v = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$v.apply(null, arguments);
  }
  var Dot = (props) => {
    var {
      cx,
      cy,
      r: r2,
      className
    } = props;
    var layerClass = clsx("recharts-dot", className);
    if (cx === +cx && cy === +cy && r2 === +r2) {
      return /* @__PURE__ */ React__namespace.createElement("circle", _extends$v({}, svgPropertiesNoEvents(props), adaptEventHandlers(props), {
        className: layerClass,
        cx,
        cy,
        r: r2
      }));
    }
    return null;
  };
  var selectUnfilteredPolarItems = (state) => state.graphicalItems.polarItems;
  var selectAxisPredicate = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);
  var selectPolarItemsSettings = createSelector([selectUnfilteredPolarItems, selectBaseAxis, selectAxisPredicate], combineGraphicalItemsSettings);
  var selectPolarGraphicalItemsData = createSelector([selectPolarItemsSettings], combineGraphicalItemsData);
  var selectPolarDisplayedData = createSelector([selectPolarGraphicalItemsData, selectChartDataAndAlwaysIgnoreIndexes], combineDisplayedData);
  var selectPolarAppliedValues = createSelector([selectPolarDisplayedData, selectBaseAxis, selectPolarItemsSettings], combineAppliedValues);
  var selectAllPolarAppliedNumericalValues = createSelector([selectPolarDisplayedData, selectBaseAxis, selectPolarItemsSettings], (data, axisSettings, items) => {
    if (items.length > 0) {
      return data.flatMap((entry) => {
        return items.flatMap((item) => {
          var _axisSettings$dataKey;
          var valueByDataKey = getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey);
          return {
            value: valueByDataKey,
            errorDomain: []
            // polar charts do not have error bars
          };
        });
      }).filter(Boolean);
    }
    if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {
      return data.map((item) => ({
        value: getValueByDataKey(item, axisSettings.dataKey),
        errorDomain: []
      }));
    }
    return data.map((entry) => ({
      value: entry,
      errorDomain: []
    }));
  });
  var unsupportedInPolarChart = () => void 0;
  var selectPolarNumericalDomain = createSelector([selectBaseAxis, selectDomainDefinition, unsupportedInPolarChart, selectAllPolarAppliedNumericalValues, unsupportedInPolarChart, selectChartLayout, pickAxisType], combineNumericalDomain);
  var selectPolarAxisDomain = createSelector([selectBaseAxis, selectChartLayout, selectPolarDisplayedData, selectPolarAppliedValues, selectStackOffsetType, pickAxisType, selectPolarNumericalDomain], combineAxisDomain);
  var selectPolarNiceTicks = createSelector([selectPolarAxisDomain, selectBaseAxis, selectRealScaleType], combineNiceTicks);
  var selectPolarAxisDomainIncludingNiceTicks = createSelector([selectBaseAxis, selectPolarAxisDomain, selectPolarNiceTicks, pickAxisType], combineAxisDomainWithNiceTicks);
  var selectPolarAxis = (state, axisType, axisId) => {
    switch (axisType) {
      case "angleAxis": {
        return selectAngleAxis(state, axisId);
      }
      case "radiusAxis": {
        return selectRadiusAxis(state, axisId);
      }
      default: {
        throw new Error("Unexpected axis type: ".concat(axisType));
      }
    }
  };
  var selectPolarAxisRangeWithReversed = (state, axisType, axisId) => {
    switch (axisType) {
      case "angleAxis": {
        return selectAngleAxisRangeWithReversed(state, axisId);
      }
      case "radiusAxis": {
        return selectRadiusAxisRangeWithReversed(state, axisId);
      }
      default: {
        throw new Error("Unexpected axis type: ".concat(axisType));
      }
    }
  };
  var selectPolarAxisScale = createSelector([selectPolarAxis, selectRealScaleType, selectPolarAxisDomainIncludingNiceTicks, selectPolarAxisRangeWithReversed], combineScaleFunction);
  var selectPolarCategoricalDomain = createSelector([selectChartLayout, selectPolarAppliedValues, selectAxisSettings, pickAxisType], combineCategoricalDomain);
  var selectPolarAxisTicks = createSelector([selectChartLayout, selectPolarAxis, selectRealScaleType, selectPolarAxisScale, selectPolarNiceTicks, selectPolarAxisRangeWithReversed, selectDuplicateDomain, selectPolarCategoricalDomain, pickAxisType], combineAxisTicks);
  var selectPolarGraphicalItemAxisTicks = createSelector([selectChartLayout, selectPolarAxis, selectPolarAxisScale, selectPolarAxisRangeWithReversed, selectDuplicateDomain, selectPolarCategoricalDomain, pickAxisType], combineGraphicalItemTicks);
  var selectAngleAxisTicks$2 = (state, anglexisId) => selectPolarAxisTicks(state, "angleAxis", anglexisId, false);
  var selectPolarGridAngles = createSelector([selectAngleAxisTicks$2], (ticks2) => {
    if (!ticks2) {
      return void 0;
    }
    return ticks2.map((tick) => tick.coordinate);
  });
  var selectRadiusAxisTicks$2 = (state, radiusAxisId) => selectPolarAxisTicks(state, "radiusAxis", radiusAxisId, false);
  var selectPolarGridRadii = createSelector([selectRadiusAxisTicks$2], (ticks2) => {
    if (!ticks2) {
      return void 0;
    }
    return ticks2.map((tick) => tick.coordinate);
  });
  var _excluded$p = ["gridType", "radialLines", "angleAxisId", "radiusAxisId", "cx", "cy", "innerRadius", "outerRadius"];
  function _objectWithoutProperties$p(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$p(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$p(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function _extends$u() {
    return _extends$u = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$u.apply(null, arguments);
  }
  function ownKeys$z(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$z(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$z(Object(t), true).forEach(function(r3) {
        _defineProperty$C(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$z(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$C(e, r2, t) {
    return (r2 = _toPropertyKey$C(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$C(t) {
    var i = _toPrimitive$C(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$C(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var getPolygonPath = (radius, cx, cy, polarAngles) => {
    var path2 = "";
    polarAngles.forEach((angle, i) => {
      var point2 = polarToCartesian(cx, cy, radius, angle);
      if (i) {
        path2 += "L ".concat(point2.x, ",").concat(point2.y);
      } else {
        path2 += "M ".concat(point2.x, ",").concat(point2.y);
      }
    });
    path2 += "Z";
    return path2;
  };
  var PolarAngles = (props) => {
    var {
      cx,
      cy,
      innerRadius,
      outerRadius,
      polarAngles,
      radialLines
    } = props;
    if (!polarAngles || !polarAngles.length || !radialLines) {
      return null;
    }
    var polarAnglesProps = _objectSpread$z({
      stroke: "#ccc"
    }, svgPropertiesNoEvents(props));
    return /* @__PURE__ */ React__namespace.createElement("g", {
      className: "recharts-polar-grid-angle"
    }, polarAngles.map((entry) => {
      var start = polarToCartesian(cx, cy, innerRadius, entry);
      var end = polarToCartesian(cx, cy, outerRadius, entry);
      return /* @__PURE__ */ React__namespace.createElement("line", _extends$u({}, polarAnglesProps, {
        key: "line-".concat(entry),
        x1: start.x,
        y1: start.y,
        x2: end.x,
        y2: end.y
      }));
    }));
  };
  var ConcentricCircle = (props) => {
    var {
      cx,
      cy,
      radius,
      index: index2
    } = props;
    var concentricCircleProps = _objectSpread$z(_objectSpread$z({
      stroke: "#ccc"
    }, svgPropertiesNoEvents(props)), {}, {
      fill: "none"
    });
    return (
      // @ts-expect-error wrong SVG element type
      /* @__PURE__ */ React__namespace.createElement("circle", _extends$u({}, concentricCircleProps, {
        className: clsx("recharts-polar-grid-concentric-circle", props.className),
        key: "circle-".concat(index2),
        cx,
        cy,
        r: radius
      }))
    );
  };
  var ConcentricPolygon = (props) => {
    var {
      radius,
      index: index2
    } = props;
    var concentricPolygonProps = _objectSpread$z(_objectSpread$z({
      stroke: "#ccc"
    }, svgPropertiesNoEvents(props)), {}, {
      fill: "none"
    });
    return /* @__PURE__ */ React__namespace.createElement("path", _extends$u({}, concentricPolygonProps, {
      className: clsx("recharts-polar-grid-concentric-polygon", props.className),
      key: "path-".concat(index2),
      d: getPolygonPath(radius, props.cx, props.cy, props.polarAngles)
    }));
  };
  var ConcentricGridPath = (props) => {
    var {
      polarRadius,
      gridType
    } = props;
    if (!polarRadius || !polarRadius.length) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement("g", {
      className: "recharts-polar-grid-concentric"
    }, polarRadius.map((entry, i) => {
      var key = i;
      if (gridType === "circle") return /* @__PURE__ */ React__namespace.createElement(ConcentricCircle, _extends$u({
        key
      }, props, {
        radius: entry,
        index: i
      }));
      return /* @__PURE__ */ React__namespace.createElement(ConcentricPolygon, _extends$u({
        key
      }, props, {
        radius: entry,
        index: i
      }));
    }));
  };
  var PolarGrid = (_ref2) => {
    var _ref22, _polarViewBox$cx, _ref3, _polarViewBox$cy, _ref4, _polarViewBox$innerRa, _ref5, _polarViewBox$outerRa;
    var {
      gridType = "polygon",
      radialLines = true,
      angleAxisId = 0,
      radiusAxisId = 0,
      cx: cxFromOutside,
      cy: cyFromOutside,
      innerRadius: innerRadiusFromOutside,
      outerRadius: outerRadiusFromOutside
    } = _ref2, inputs = _objectWithoutProperties$p(_ref2, _excluded$p);
    var polarViewBox = useAppSelector(selectPolarViewBox);
    var props = _objectSpread$z({
      cx: (_ref22 = (_polarViewBox$cx = polarViewBox === null || polarViewBox === void 0 ? void 0 : polarViewBox.cx) !== null && _polarViewBox$cx !== void 0 ? _polarViewBox$cx : cxFromOutside) !== null && _ref22 !== void 0 ? _ref22 : 0,
      cy: (_ref3 = (_polarViewBox$cy = polarViewBox === null || polarViewBox === void 0 ? void 0 : polarViewBox.cy) !== null && _polarViewBox$cy !== void 0 ? _polarViewBox$cy : cyFromOutside) !== null && _ref3 !== void 0 ? _ref3 : 0,
      innerRadius: (_ref4 = (_polarViewBox$innerRa = polarViewBox === null || polarViewBox === void 0 ? void 0 : polarViewBox.innerRadius) !== null && _polarViewBox$innerRa !== void 0 ? _polarViewBox$innerRa : innerRadiusFromOutside) !== null && _ref4 !== void 0 ? _ref4 : 0,
      outerRadius: (_ref5 = (_polarViewBox$outerRa = polarViewBox === null || polarViewBox === void 0 ? void 0 : polarViewBox.outerRadius) !== null && _polarViewBox$outerRa !== void 0 ? _polarViewBox$outerRa : outerRadiusFromOutside) !== null && _ref5 !== void 0 ? _ref5 : 0
    }, inputs);
    var {
      polarAngles: polarAnglesInput,
      polarRadius: polarRadiusInput,
      cx,
      cy,
      innerRadius,
      outerRadius
    } = props;
    var polarAnglesFromRedux = useAppSelector((state) => selectPolarGridAngles(state, angleAxisId));
    var polarRadiiFromRedux = useAppSelector((state) => selectPolarGridRadii(state, radiusAxisId));
    var polarAngles = Array.isArray(polarAnglesInput) ? polarAnglesInput : polarAnglesFromRedux;
    var polarRadius = Array.isArray(polarRadiusInput) ? polarRadiusInput : polarRadiiFromRedux;
    if (outerRadius <= 0 || polarAngles == null || polarRadius == null) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement("g", {
      className: "recharts-polar-grid"
    }, /* @__PURE__ */ React__namespace.createElement(PolarAngles, _extends$u({
      cx,
      cy,
      innerRadius,
      outerRadius,
      gridType,
      radialLines
    }, props, {
      polarAngles,
      polarRadius
    })), /* @__PURE__ */ React__namespace.createElement(ConcentricGridPath, _extends$u({
      cx,
      cy,
      innerRadius,
      outerRadius,
      gridType,
      radialLines
    }, props, {
      polarAngles,
      polarRadius
    })));
  };
  PolarGrid.displayName = "PolarGrid";
  var maxBy$6 = {};
  var maxBy$5 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function maxBy2(items, getValue2) {
      if (items.length === 0) {
        return void 0;
      }
      let maxElement = items[0];
      let max2 = getValue2(maxElement);
      for (let i = 1; i < items.length; i++) {
        const element = items[i];
        const value = getValue2(element);
        if (value > max2) {
          max2 = value;
          maxElement = element;
        }
      }
      return maxElement;
    }
    exports3.maxBy = maxBy2;
  })(maxBy$5);
  const maxBy$4 = /* @__PURE__ */ getDefaultExportFromCjs(maxBy$5);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const maxBy$12 = maxBy$5;
    const identity2 = identity$8;
    const iteratee2 = iteratee$1;
    function maxBy2(items, iteratee$12) {
      if (items == null) {
        return void 0;
      }
      return maxBy$12.maxBy(Array.from(items), iteratee2.iteratee(iteratee$12 ?? identity2.identity));
    }
    exports3.maxBy = maxBy2;
  })(maxBy$6);
  const maxBy$3 = /* @__PURE__ */ getDefaultExportFromCjs(maxBy$6);
  var maxBy$1 = maxBy$6.maxBy;
  const maxBy$2 = /* @__PURE__ */ getDefaultExportFromCjs(maxBy$1);
  var minBy$6 = {};
  var minBy$5 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function minBy2(items, getValue2) {
      if (items.length === 0) {
        return void 0;
      }
      let minElement = items[0];
      let min2 = getValue2(minElement);
      for (let i = 1; i < items.length; i++) {
        const element = items[i];
        const value = getValue2(element);
        if (value < min2) {
          min2 = value;
          minElement = element;
        }
      }
      return minElement;
    }
    exports3.minBy = minBy2;
  })(minBy$5);
  const minBy$4 = /* @__PURE__ */ getDefaultExportFromCjs(minBy$5);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const minBy$12 = minBy$5;
    const identity2 = identity$8;
    const iteratee2 = iteratee$1;
    function minBy2(items, iteratee$12) {
      if (items == null) {
        return void 0;
      }
      return minBy$12.minBy(Array.from(items), iteratee2.iteratee(iteratee$12 ?? identity2.identity));
    }
    exports3.minBy = minBy2;
  })(minBy$6);
  const minBy$3 = /* @__PURE__ */ getDefaultExportFromCjs(minBy$6);
  var minBy$1 = minBy$6.minBy;
  const minBy$2 = /* @__PURE__ */ getDefaultExportFromCjs(minBy$1);
  var initialState$6 = {
    radiusAxis: {},
    angleAxis: {}
  };
  var polarAxisSlice = createSlice({
    name: "polarAxis",
    initialState: initialState$6,
    reducers: {
      addRadiusAxis(state, action) {
        state.radiusAxis[action.payload.id] = castDraft(action.payload);
      },
      removeRadiusAxis(state, action) {
        delete state.radiusAxis[action.payload.id];
      },
      addAngleAxis(state, action) {
        state.angleAxis[action.payload.id] = castDraft(action.payload);
      },
      removeAngleAxis(state, action) {
        delete state.angleAxis[action.payload.id];
      }
    }
  });
  var {
    addRadiusAxis,
    removeRadiusAxis,
    addAngleAxis,
    removeAngleAxis
  } = polarAxisSlice.actions;
  var polarAxisReducer = polarAxisSlice.reducer;
  var _excluded$o = ["cx", "cy", "angle", "axisLine"], _excluded2$b = ["angle", "tickFormatter", "stroke", "tick"];
  function _extends$t() {
    return _extends$t = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$t.apply(null, arguments);
  }
  function ownKeys$y(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$y(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$y(Object(t), true).forEach(function(r3) {
        _defineProperty$B(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$y(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$B(e, r2, t) {
    return (r2 = _toPropertyKey$B(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$B(t) {
    var i = _toPrimitive$B(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$B(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _objectWithoutProperties$o(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$o(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$o(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var AXIS_TYPE$1 = "radiusAxis";
  function SetRadiusAxisSettings(settings) {
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(addRadiusAxis(settings));
      return () => {
        dispatch(removeRadiusAxis(settings));
      };
    });
    return null;
  }
  var getTickValueCoord = (_ref2, angle, cx, cy) => {
    var {
      coordinate
    } = _ref2;
    return polarToCartesian(cx, cy, coordinate, angle);
  };
  var getTickTextAnchor$1 = (orientation) => {
    var textAnchor;
    switch (orientation) {
      case "left":
        textAnchor = "end";
        break;
      case "right":
        textAnchor = "start";
        break;
      default:
        textAnchor = "middle";
        break;
    }
    return textAnchor;
  };
  var getViewBox = (angle, cx, cy, ticks2) => {
    var maxRadiusTick = maxBy$2(ticks2, (entry) => entry.coordinate || 0);
    var minRadiusTick = minBy$2(ticks2, (entry) => entry.coordinate || 0);
    return {
      cx,
      cy,
      startAngle: angle,
      endAngle: angle,
      innerRadius: minRadiusTick.coordinate || 0,
      outerRadius: maxRadiusTick.coordinate || 0
    };
  };
  var renderAxisLine = (props, ticks2) => {
    var {
      cx,
      cy,
      angle,
      axisLine
    } = props, others = _objectWithoutProperties$o(props, _excluded$o);
    var extent2 = ticks2.reduce((result, entry) => [Math.min(result[0], entry.coordinate), Math.max(result[1], entry.coordinate)], [Infinity, -Infinity]);
    var point0 = polarToCartesian(cx, cy, extent2[0], angle);
    var point1 = polarToCartesian(cx, cy, extent2[1], angle);
    var axisLineProps = _objectSpread$y(_objectSpread$y(_objectSpread$y({}, svgPropertiesNoEvents(others)), {}, {
      fill: "none"
    }, filterProps(axisLine, false)), {}, {
      x1: point0.x,
      y1: point0.y,
      x2: point1.x,
      y2: point1.y
    });
    return /* @__PURE__ */ React__namespace.createElement("line", _extends$t({
      className: "recharts-polar-radius-axis-line"
    }, axisLineProps));
  };
  var renderTickItem = (option, tickProps, value) => {
    var tickItem;
    if (/* @__PURE__ */ React__namespace.isValidElement(option)) {
      tickItem = /* @__PURE__ */ React__namespace.cloneElement(option, tickProps);
    } else if (typeof option === "function") {
      tickItem = option(tickProps);
    } else {
      tickItem = /* @__PURE__ */ React__namespace.createElement(Text, _extends$t({}, tickProps, {
        className: "recharts-polar-radius-axis-tick-value"
      }), value);
    }
    return tickItem;
  };
  var renderTicks = (props, ticks2) => {
    var {
      angle,
      tickFormatter,
      stroke,
      tick
    } = props, others = _objectWithoutProperties$o(props, _excluded2$b);
    var textAnchor = getTickTextAnchor$1(props.orientation);
    var axisProps = svgPropertiesNoEvents(others);
    var customTickProps = filterProps(tick, false);
    var items = ticks2.map((entry, i) => {
      var coord = getTickValueCoord(entry, props.angle, props.cx, props.cy);
      var tickProps = _objectSpread$y(_objectSpread$y(_objectSpread$y(_objectSpread$y({
        textAnchor,
        transform: "rotate(".concat(90 - angle, ", ").concat(coord.x, ", ").concat(coord.y, ")")
      }, axisProps), {}, {
        stroke: "none",
        fill: stroke
      }, customTickProps), {}, {
        index: i
      }, coord), {}, {
        payload: entry
      });
      return /* @__PURE__ */ React__namespace.createElement(Layer, _extends$t({
        className: clsx("recharts-polar-radius-axis-tick", getTickClassName(tick)),
        key: "tick-".concat(entry.coordinate)
      }, adaptEventsOfChild(props, entry, i)), renderTickItem(tick, tickProps, tickFormatter ? tickFormatter(entry.value, i) : entry.value));
    });
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: "recharts-polar-radius-axis-ticks"
    }, items);
  };
  var PolarRadiusAxisWrapper = (defaultsAndInputs) => {
    var {
      radiusAxisId
    } = defaultsAndInputs;
    var viewBox = useAppSelector(selectPolarViewBox);
    var scale = useAppSelector((state) => selectPolarAxisScale(state, "radiusAxis", radiusAxisId));
    var ticks2 = useAppSelector((state) => selectPolarAxisTicks(state, "radiusAxis", radiusAxisId, false));
    if (viewBox == null || !ticks2 || !ticks2.length) {
      return null;
    }
    var props = _objectSpread$y(_objectSpread$y(_objectSpread$y({}, defaultsAndInputs), {}, {
      scale
    }, viewBox), {}, {
      radius: viewBox.outerRadius
    });
    var {
      tick,
      axisLine
    } = props;
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: clsx("recharts-polar-radius-axis", AXIS_TYPE$1, props.className)
    }, axisLine && renderAxisLine(props, ticks2), tick && renderTicks(props, ticks2), Label.renderCallByParent(props, getViewBox(props.angle, props.cx, props.cy, ticks2)));
  };
  class PolarRadiusAxis extends React.PureComponent {
    render() {
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(SetRadiusAxisSettings, {
        domain: this.props.domain,
        id: this.props.radiusAxisId,
        scale: this.props.scale,
        type: this.props.type,
        dataKey: this.props.dataKey,
        unit: void 0,
        name: this.props.name,
        allowDuplicatedCategory: this.props.allowDuplicatedCategory,
        allowDataOverflow: this.props.allowDataOverflow,
        reversed: this.props.reversed,
        includeHidden: this.props.includeHidden,
        allowDecimals: this.props.allowDecimals,
        tickCount: this.props.tickCount,
        ticks: this.props.ticks,
        tick: this.props.tick
      }), /* @__PURE__ */ React__namespace.createElement(PolarRadiusAxisWrapper, this.props));
    }
  }
  _defineProperty$B(PolarRadiusAxis, "displayName", "PolarRadiusAxis");
  _defineProperty$B(PolarRadiusAxis, "axisType", AXIS_TYPE$1);
  _defineProperty$B(PolarRadiusAxis, "defaultProps", defaultPolarRadiusAxisProps);
  var _excluded$n = ["children"];
  function _extends$s() {
    return _extends$s = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$s.apply(null, arguments);
  }
  function ownKeys$x(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$x(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$x(Object(t), true).forEach(function(r3) {
        _defineProperty$A(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$x(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$A(e, r2, t) {
    return (r2 = _toPropertyKey$A(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$A(t) {
    var i = _toPrimitive$A(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$A(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _objectWithoutProperties$n(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$n(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$n(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var RADIAN = Math.PI / 180;
  var eps = 1e-5;
  var AXIS_TYPE = "angleAxis";
  function SetAngleAxisSettings(props) {
    var dispatch = useAppDispatch();
    var settings = React.useMemo(() => {
      var {
        children
      } = props, rest2 = _objectWithoutProperties$n(props, _excluded$n);
      return rest2;
    }, [props]);
    var synchronizedSettings = useAppSelector((state) => selectAngleAxis(state, settings.id));
    var settingsAreSynchronized = settings === synchronizedSettings;
    React.useEffect(() => {
      dispatch(addAngleAxis(settings));
      return () => {
        dispatch(removeAngleAxis(settings));
      };
    }, [dispatch, settings]);
    if (settingsAreSynchronized) {
      return props.children;
    }
    return null;
  }
  var getTickLineCoord = (data, props) => {
    var {
      cx,
      cy,
      radius,
      orientation,
      tickSize
    } = props;
    var tickLineSize = tickSize || 8;
    var p1 = polarToCartesian(cx, cy, radius, data.coordinate);
    var p2 = polarToCartesian(cx, cy, radius + (orientation === "inner" ? -1 : 1) * tickLineSize, data.coordinate);
    return {
      x1: p1.x,
      y1: p1.y,
      x2: p2.x,
      y2: p2.y
    };
  };
  var getTickTextAnchor = (data, orientation) => {
    var cos2 = Math.cos(-data.coordinate * RADIAN);
    if (cos2 > eps) {
      return orientation === "outer" ? "start" : "end";
    }
    if (cos2 < -eps) {
      return orientation === "outer" ? "end" : "start";
    }
    return "middle";
  };
  var AxisLine = (props) => {
    var {
      cx,
      cy,
      radius,
      axisLineType,
      axisLine,
      ticks: ticks2
    } = props;
    if (!axisLine) {
      return null;
    }
    var axisLineProps = _objectSpread$x(_objectSpread$x({}, svgPropertiesNoEvents(props)), {}, {
      fill: "none"
    }, filterProps(axisLine, false));
    if (axisLineType === "circle") {
      return /* @__PURE__ */ React__namespace.createElement(Dot, _extends$s({
        className: "recharts-polar-angle-axis-line"
      }, axisLineProps, {
        cx,
        cy,
        r: radius
      }));
    }
    var points = ticks2.map((entry) => polarToCartesian(cx, cy, radius, entry.coordinate));
    return /* @__PURE__ */ React__namespace.createElement(Polygon, _extends$s({
      className: "recharts-polar-angle-axis-line"
    }, axisLineProps, {
      points
    }));
  };
  var TickItemText = (_ref2) => {
    var {
      tick,
      tickProps,
      value
    } = _ref2;
    if (!tick) {
      return null;
    }
    if (/* @__PURE__ */ React__namespace.isValidElement(tick)) {
      return /* @__PURE__ */ React__namespace.cloneElement(tick, tickProps);
    }
    if (typeof tick === "function") {
      return tick(tickProps);
    }
    return /* @__PURE__ */ React__namespace.createElement(Text, _extends$s({}, tickProps, {
      className: "recharts-polar-angle-axis-tick-value"
    }), value);
  };
  var Ticks = (props) => {
    var {
      tick,
      tickLine,
      tickFormatter,
      stroke,
      ticks: ticks2
    } = props;
    var axisProps = svgPropertiesNoEvents(props);
    var customTickProps = filterProps(tick, false);
    var tickLineProps = _objectSpread$x(_objectSpread$x({}, axisProps), {}, {
      fill: "none"
    }, filterProps(tickLine, false));
    var items = ticks2.map((entry, i) => {
      var lineCoord = getTickLineCoord(entry, props);
      var textAnchor = getTickTextAnchor(entry, props.orientation);
      var tickProps = _objectSpread$x(_objectSpread$x(_objectSpread$x({}, axisProps), {}, {
        textAnchor,
        stroke: "none",
        fill: stroke
      }, customTickProps), {}, {
        index: i,
        payload: entry,
        x: lineCoord.x2,
        y: lineCoord.y2
      });
      return /* @__PURE__ */ React__namespace.createElement(Layer, _extends$s({
        className: clsx("recharts-polar-angle-axis-tick", getTickClassName(tick)),
        key: "tick-".concat(entry.coordinate)
      }, adaptEventsOfChild(props, entry, i)), tickLine && /* @__PURE__ */ React__namespace.createElement("line", _extends$s({
        className: "recharts-polar-angle-axis-tick-line"
      }, tickLineProps, lineCoord)), /* @__PURE__ */ React__namespace.createElement(TickItemText, {
        tick,
        tickProps,
        value: tickFormatter ? tickFormatter(entry.value, i) : entry.value
      }));
    });
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: "recharts-polar-angle-axis-ticks"
    }, items);
  };
  var PolarAngleAxisWrapper = (defaultsAndInputs) => {
    var {
      angleAxisId
    } = defaultsAndInputs;
    var viewBox = useAppSelector(selectPolarViewBox);
    var scale = useAppSelector((state) => selectPolarAxisScale(state, "angleAxis", angleAxisId));
    var isPanorama = useIsPanorama();
    var ticks2 = useAppSelector((state) => selectPolarAxisTicks(state, "angleAxis", angleAxisId, isPanorama));
    if (viewBox == null || !ticks2 || !ticks2.length) {
      return null;
    }
    var props = _objectSpread$x(_objectSpread$x(_objectSpread$x({}, defaultsAndInputs), {}, {
      scale
    }, viewBox), {}, {
      radius: viewBox.outerRadius
    });
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: clsx("recharts-polar-angle-axis", AXIS_TYPE, props.className)
    }, /* @__PURE__ */ React__namespace.createElement(AxisLine, _extends$s({}, props, {
      ticks: ticks2
    })), /* @__PURE__ */ React__namespace.createElement(Ticks, _extends$s({}, props, {
      ticks: ticks2
    })));
  };
  class PolarAngleAxis extends React.PureComponent {
    render() {
      if (this.props.radius <= 0) return null;
      return /* @__PURE__ */ React__namespace.createElement(SetAngleAxisSettings, {
        id: this.props.angleAxisId,
        scale: this.props.scale,
        type: this.props.type,
        dataKey: this.props.dataKey,
        unit: void 0,
        name: this.props.name,
        allowDuplicatedCategory: false,
        allowDataOverflow: false,
        reversed: this.props.reversed,
        includeHidden: false,
        allowDecimals: this.props.allowDecimals,
        tickCount: this.props.tickCount,
        ticks: this.props.ticks,
        tick: this.props.tick,
        domain: this.props.domain
      }, /* @__PURE__ */ React__namespace.createElement(PolarAngleAxisWrapper, this.props));
    }
  }
  _defineProperty$A(PolarAngleAxis, "displayName", "PolarAngleAxis");
  _defineProperty$A(PolarAngleAxis, "axisType", AXIS_TYPE);
  _defineProperty$A(PolarAngleAxis, "defaultProps", defaultPolarAngleAxisProps);
  function ownKeys$w(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$w(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$w(Object(t), true).forEach(function(r3) {
        _defineProperty$z(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$w(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$z(e, r2, t) {
    return (r2 = _toPropertyKey$z(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$z(t) {
    var i = _toPrimitive$z(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$z(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var pickId = (_state, id) => id;
  var selectSynchronisedPieSettings = createSelector([selectUnfilteredPolarItems, pickId], (graphicalItems, id) => graphicalItems.filter((item) => item.type === "pie").find((item) => item.id === id));
  var emptyArray = [];
  var pickCells$3 = (_state, _id, cells) => {
    if ((cells === null || cells === void 0 ? void 0 : cells.length) === 0) {
      return emptyArray;
    }
    return cells;
  };
  var selectDisplayedData = createSelector([selectChartDataAndAlwaysIgnoreIndexes, selectSynchronisedPieSettings, pickCells$3], (_ref2, pieSettings, cells) => {
    var {
      chartData
    } = _ref2;
    if (pieSettings == null) {
      return void 0;
    }
    var displayedData;
    if ((pieSettings === null || pieSettings === void 0 ? void 0 : pieSettings.data) != null && pieSettings.data.length > 0) {
      displayedData = pieSettings.data;
    } else {
      displayedData = chartData;
    }
    if ((!displayedData || !displayedData.length) && cells != null) {
      displayedData = cells.map((cell) => _objectSpread$w(_objectSpread$w({}, pieSettings.presentationProps), cell.props));
    }
    if (displayedData == null) {
      return void 0;
    }
    return displayedData;
  });
  var selectPieLegend = createSelector([selectDisplayedData, selectSynchronisedPieSettings, pickCells$3], (displayedData, pieSettings, cells) => {
    if (displayedData == null || pieSettings == null) {
      return void 0;
    }
    return displayedData.map((entry, i) => {
      var _cells$i;
      var name = getValueByDataKey(entry, pieSettings.nameKey, pieSettings.name);
      var color2;
      if (cells !== null && cells !== void 0 && (_cells$i = cells[i]) !== null && _cells$i !== void 0 && (_cells$i = _cells$i.props) !== null && _cells$i !== void 0 && _cells$i.fill) {
        color2 = cells[i].props.fill;
      } else if (typeof entry === "object" && entry != null && "fill" in entry) {
        color2 = entry.fill;
      } else {
        color2 = pieSettings.fill;
      }
      return {
        value: getTooltipNameProp(name, pieSettings.dataKey),
        color: color2,
        payload: entry,
        type: pieSettings.legendType
      };
    });
  });
  var selectPieSectors = createSelector([selectDisplayedData, selectSynchronisedPieSettings, pickCells$3, selectChartOffsetInternal], (displayedData, pieSettings, cells, offset) => {
    if (pieSettings == null || displayedData == null) {
      return void 0;
    }
    return computePieSectors({
      offset,
      pieSettings,
      displayedData,
      cells
    });
  });
  var isPlainObject$6 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    function isPlainObject2(object2) {
      var _a;
      if (typeof object2 !== "object") {
        return false;
      }
      if (object2 == null) {
        return false;
      }
      if (Object.getPrototypeOf(object2) === null) {
        return true;
      }
      if (Object.prototype.toString.call(object2) !== "[object Object]") {
        const tag = object2[Symbol.toStringTag];
        if (tag == null) {
          return false;
        }
        const isTagReadonly = !((_a = Object.getOwnPropertyDescriptor(object2, Symbol.toStringTag)) == null ? void 0 : _a.writable);
        if (isTagReadonly) {
          return false;
        }
        return object2.toString() === `[object ${tag}]`;
      }
      let proto2 = object2;
      while (Object.getPrototypeOf(proto2) !== null) {
        proto2 = Object.getPrototypeOf(proto2);
      }
      return Object.getPrototypeOf(object2) === proto2;
    }
    exports3.isPlainObject = isPlainObject2;
  })(isPlainObject$6);
  const isPlainObject$5 = /* @__PURE__ */ getDefaultExportFromCjs(isPlainObject$6);
  var isPlainObject$3 = isPlainObject$6.isPlainObject;
  const isPlainObject$4 = /* @__PURE__ */ getDefaultExportFromCjs(isPlainObject$3);
  function _extends$r() {
    return _extends$r = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$r.apply(null, arguments);
  }
  var getTrapezoidPath = (x2, y2, upperWidth, lowerWidth, height) => {
    var widthGap = upperWidth - lowerWidth;
    var path2;
    path2 = "M ".concat(x2, ",").concat(y2);
    path2 += "L ".concat(x2 + upperWidth, ",").concat(y2);
    path2 += "L ".concat(x2 + upperWidth - widthGap / 2, ",").concat(y2 + height);
    path2 += "L ".concat(x2 + upperWidth - widthGap / 2 - lowerWidth, ",").concat(y2 + height);
    path2 += "L ".concat(x2, ",").concat(y2, " Z");
    return path2;
  };
  var defaultProps$7 = {
    x: 0,
    y: 0,
    upperWidth: 0,
    lowerWidth: 0,
    height: 0,
    isUpdateAnimationActive: false,
    animationBegin: 0,
    animationDuration: 1500,
    animationEasing: "ease"
  };
  var Trapezoid = (props) => {
    var trapezoidProps = resolveDefaultProps(props, defaultProps$7);
    var pathRef = React.useRef();
    var [totalLength, setTotalLength] = React.useState(-1);
    React.useEffect(() => {
      if (pathRef.current && pathRef.current.getTotalLength) {
        try {
          var pathTotalLength = pathRef.current.getTotalLength();
          if (pathTotalLength) {
            setTotalLength(pathTotalLength);
          }
        } catch (_unused) {
        }
      }
    }, []);
    var {
      x: x2,
      y: y2,
      upperWidth,
      lowerWidth,
      height,
      className
    } = trapezoidProps;
    var {
      animationEasing,
      animationDuration,
      animationBegin,
      isUpdateAnimationActive
    } = trapezoidProps;
    if (x2 !== +x2 || y2 !== +y2 || upperWidth !== +upperWidth || lowerWidth !== +lowerWidth || height !== +height || upperWidth === 0 && lowerWidth === 0 || height === 0) {
      return null;
    }
    var layerClass = clsx("recharts-trapezoid", className);
    if (!isUpdateAnimationActive) {
      return /* @__PURE__ */ React__namespace.createElement("g", null, /* @__PURE__ */ React__namespace.createElement("path", _extends$r({}, filterProps(trapezoidProps, true), {
        className: layerClass,
        d: getTrapezoidPath(x2, y2, upperWidth, lowerWidth, height)
      })));
    }
    return /* @__PURE__ */ React__namespace.createElement(Animate, {
      canBegin: totalLength > 0,
      from: {
        upperWidth: 0,
        lowerWidth: 0,
        height,
        x: x2,
        y: y2
      },
      to: {
        upperWidth,
        lowerWidth,
        height,
        x: x2,
        y: y2
      },
      duration: animationDuration,
      animationEasing,
      isActive: isUpdateAnimationActive
    }, (_ref2) => {
      var {
        upperWidth: currUpperWidth,
        lowerWidth: currLowerWidth,
        height: currHeight,
        x: currX,
        y: currY
      } = _ref2;
      return /* @__PURE__ */ React__namespace.createElement(Animate, {
        canBegin: totalLength > 0,
        from: "0px ".concat(totalLength === -1 ? 1 : totalLength, "px"),
        to: "".concat(totalLength, "px 0px"),
        attributeName: "strokeDasharray",
        begin: animationBegin,
        duration: animationDuration,
        easing: animationEasing
      }, /* @__PURE__ */ React__namespace.createElement("path", _extends$r({}, filterProps(trapezoidProps, true), {
        className: layerClass,
        d: getTrapezoidPath(currX, currY, currUpperWidth, currLowerWidth, currHeight),
        ref: pathRef
      })));
    });
  };
  var _excluded$m = ["option", "shapeType", "propTransformer", "activeClassName", "isActive"];
  function _objectWithoutProperties$m(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$m(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$m(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function ownKeys$v(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$v(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$v(Object(t), true).forEach(function(r3) {
        _defineProperty$y(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$v(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$y(e, r2, t) {
    return (r2 = _toPropertyKey$y(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$y(t) {
    var i = _toPrimitive$y(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$y(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function defaultPropTransformer(option, props) {
    return _objectSpread$v(_objectSpread$v({}, props), option);
  }
  function isSymbolsProps(shapeType, _elementProps) {
    return shapeType === "symbols";
  }
  function ShapeSelector(_ref2) {
    var {
      shapeType,
      elementProps
    } = _ref2;
    switch (shapeType) {
      case "rectangle":
        return /* @__PURE__ */ React__namespace.createElement(Rectangle, elementProps);
      case "trapezoid":
        return /* @__PURE__ */ React__namespace.createElement(Trapezoid, elementProps);
      case "sector":
        return /* @__PURE__ */ React__namespace.createElement(Sector, elementProps);
      case "symbols":
        if (isSymbolsProps(shapeType, elementProps)) {
          return /* @__PURE__ */ React__namespace.createElement(Symbols, elementProps);
        }
        break;
      default:
        return null;
    }
  }
  function getPropsFromShapeOption(option) {
    if (/* @__PURE__ */ React.isValidElement(option)) {
      return option.props;
    }
    return option;
  }
  function Shape(_ref2) {
    var {
      option,
      shapeType,
      propTransformer = defaultPropTransformer,
      activeClassName = "recharts-active-shape",
      isActive
    } = _ref2, props = _objectWithoutProperties$m(_ref2, _excluded$m);
    var shape;
    if (/* @__PURE__ */ React.isValidElement(option)) {
      shape = /* @__PURE__ */ React.cloneElement(option, _objectSpread$v(_objectSpread$v({}, props), getPropsFromShapeOption(option)));
    } else if (typeof option === "function") {
      shape = option(props);
    } else if (isPlainObject$4(option) && typeof option !== "boolean") {
      var nextProps = propTransformer(option, props);
      shape = /* @__PURE__ */ React__namespace.createElement(ShapeSelector, {
        shapeType,
        elementProps: nextProps
      });
    } else {
      var elementProps = props;
      shape = /* @__PURE__ */ React__namespace.createElement(ShapeSelector, {
        shapeType,
        elementProps
      });
    }
    if (isActive) {
      return /* @__PURE__ */ React__namespace.createElement(Layer, {
        className: activeClassName
      }, shape);
    }
    return shape;
  }
  var useMouseEnterItemDispatch = (onMouseEnterFromProps, dataKey) => {
    var dispatch = useAppDispatch();
    return (data, index2) => (event) => {
      onMouseEnterFromProps === null || onMouseEnterFromProps === void 0 || onMouseEnterFromProps(data, index2, event);
      dispatch(setActiveMouseOverItemIndex({
        activeIndex: String(index2),
        activeDataKey: dataKey,
        activeCoordinate: data.tooltipPosition
      }));
    };
  };
  var useMouseLeaveItemDispatch = (onMouseLeaveFromProps) => {
    var dispatch = useAppDispatch();
    return (data, index2) => (event) => {
      onMouseLeaveFromProps === null || onMouseLeaveFromProps === void 0 || onMouseLeaveFromProps(data, index2, event);
      dispatch(mouseLeaveItem());
    };
  };
  var useMouseClickItemDispatch = (onMouseClickFromProps, dataKey) => {
    var dispatch = useAppDispatch();
    return (data, index2) => (event) => {
      onMouseClickFromProps === null || onMouseClickFromProps === void 0 || onMouseClickFromProps(data, index2, event);
      dispatch(setActiveClickItemIndex({
        activeIndex: String(index2),
        activeDataKey: dataKey,
        activeCoordinate: data.tooltipPosition
      }));
    };
  };
  function SetTooltipEntrySettings(_ref2) {
    var {
      fn,
      args
    } = _ref2;
    var dispatch = useAppDispatch();
    var isPanorama = useIsPanorama();
    React.useEffect(() => {
      if (isPanorama) {
        return void 0;
      }
      var tooltipEntrySettings = fn(args);
      dispatch(addTooltipEntrySettings(tooltipEntrySettings));
      return () => {
        dispatch(removeTooltipEntrySettings(tooltipEntrySettings));
      };
    }, [fn, args, dispatch, isPanorama]);
    return null;
  }
  var noop$2 = () => {
  };
  function SetLegendPayload(_ref2) {
    var {
      legendPayload
    } = _ref2;
    var dispatch = useAppDispatch();
    var isPanorama = useIsPanorama();
    React.useEffect(() => {
      if (isPanorama) {
        return noop$2;
      }
      dispatch(addLegendPayload(legendPayload));
      return () => {
        dispatch(removeLegendPayload(legendPayload));
      };
    }, [dispatch, isPanorama, legendPayload]);
    return null;
  }
  function SetPolarLegendPayload(_ref2) {
    var {
      legendPayload
    } = _ref2;
    var dispatch = useAppDispatch();
    var layout = useAppSelector(selectChartLayout);
    React.useEffect(() => {
      if (layout !== "centric" && layout !== "radial") {
        return noop$2;
      }
      dispatch(addLegendPayload(legendPayload));
      return () => {
        dispatch(removeLegendPayload(legendPayload));
      };
    }, [dispatch, layout, legendPayload]);
    return null;
  }
  function useAnimationId$1(input) {
    var prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "animation-";
    var animationId = React.useRef(uniqueId(prefix2));
    var prevProps = React.useRef(input);
    if (prevProps.current !== input) {
      animationId.current = uniqueId(prefix2);
      prevProps.current = input;
    }
    return animationId.current;
  }
  var _ref;
  var useIdFallback = () => {
    var [id] = React__namespace.useState(() => uniqueId("uid-"));
    return id;
  };
  var useId = (_ref = React__namespace["useId".toString()]) !== null && _ref !== void 0 ? _ref : useIdFallback;
  function useUniqueId(prefix2, customId) {
    var generatedId = useId();
    if (customId) {
      return customId;
    }
    return prefix2 ? "".concat(prefix2, "-").concat(generatedId) : generatedId;
  }
  var GraphicalItemIdContext = /* @__PURE__ */ React.createContext(void 0);
  var RegisterGraphicalItemId = (_ref2) => {
    var {
      id,
      type,
      children
    } = _ref2;
    var resolvedId = useUniqueId("recharts-".concat(type), id);
    return /* @__PURE__ */ React__namespace.createElement(GraphicalItemIdContext.Provider, {
      value: resolvedId
    }, children(resolvedId));
  };
  function useGraphicalItemId() {
    return React.useContext(GraphicalItemIdContext);
  }
  var initialState$5 = {
    cartesianItems: [],
    polarItems: []
  };
  var graphicalItemsSlice = createSlice({
    name: "graphicalItems",
    initialState: initialState$5,
    reducers: {
      addCartesianGraphicalItem(state, action) {
        state.cartesianItems.push(castDraft(action.payload));
      },
      replaceCartesianGraphicalItem(state, action) {
        var {
          prev,
          next
        } = action.payload;
        var index2 = current(state).cartesianItems.indexOf(castDraft(prev));
        if (index2 > -1) {
          state.cartesianItems[index2] = castDraft(next);
        }
      },
      removeCartesianGraphicalItem(state, action) {
        var index2 = current(state).cartesianItems.indexOf(castDraft(action.payload));
        if (index2 > -1) {
          state.cartesianItems.splice(index2, 1);
        }
      },
      addPolarGraphicalItem(state, action) {
        state.polarItems.push(castDraft(action.payload));
      },
      removePolarGraphicalItem(state, action) {
        var index2 = current(state).polarItems.indexOf(castDraft(action.payload));
        if (index2 > -1) {
          state.polarItems.splice(index2, 1);
        }
      }
    }
  });
  var {
    addCartesianGraphicalItem,
    replaceCartesianGraphicalItem,
    removeCartesianGraphicalItem,
    addPolarGraphicalItem,
    removePolarGraphicalItem
  } = graphicalItemsSlice.actions;
  var graphicalItemsReducer = graphicalItemsSlice.reducer;
  function SetCartesianGraphicalItem(props) {
    var dispatch = useAppDispatch();
    var prevPropsRef = React.useRef(null);
    React.useEffect(() => {
      if (prevPropsRef.current === null) {
        dispatch(addCartesianGraphicalItem(props));
      } else if (prevPropsRef.current !== props) {
        dispatch(replaceCartesianGraphicalItem({
          prev: prevPropsRef.current,
          next: props
        }));
      }
      prevPropsRef.current = props;
    }, [dispatch, props]);
    React.useEffect(() => {
      return () => {
        if (prevPropsRef.current) {
          dispatch(removeCartesianGraphicalItem(prevPropsRef.current));
          prevPropsRef.current = null;
        }
      };
    }, [dispatch]);
    return null;
  }
  function SetPolarGraphicalItem(props) {
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(addPolarGraphicalItem(props));
      return () => {
        dispatch(removePolarGraphicalItem(props));
      };
    }, [dispatch, props]);
    return null;
  }
  function at(arr, indices) {
    const result = new Array(indices.length);
    const length2 = arr.length;
    for (let i = 0; i < indices.length; i++) {
      let index2 = indices[i];
      index2 = Number.isInteger(index2) ? index2 : Math.trunc(index2) || 0;
      if (index2 < 0) {
        index2 += length2;
      }
      result[i] = arr[index2];
    }
    return result;
  }
  function chunk(arr, size) {
    if (!Number.isInteger(size) || size <= 0) {
      throw new Error("Size must be an integer greater than zero.");
    }
    const chunkLength = Math.ceil(arr.length / size);
    const result = Array(chunkLength);
    for (let index2 = 0; index2 < chunkLength; index2++) {
      const start = index2 * size;
      const end = start + size;
      result[index2] = arr.slice(start, end);
    }
    return result;
  }
  function compact(arr) {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
      const item = arr[i];
      if (item) {
        result.push(item);
      }
    }
    return result;
  }
  function countBy(arr, mapper) {
    const result = {};
    for (let i = 0; i < arr.length; i++) {
      const item = arr[i];
      const key = mapper(item);
      result[key] = (result[key] ?? 0) + 1;
    }
    return result;
  }
  function difference(firstArr, secondArr) {
    const secondSet = new Set(secondArr);
    return firstArr.filter((item) => !secondSet.has(item));
  }
  function differenceBy(firstArr, secondArr, mapper) {
    const mappedSecondSet = new Set(secondArr.map((item) => mapper(item)));
    return firstArr.filter((item) => {
      return !mappedSecondSet.has(mapper(item));
    });
  }
  function differenceWith(firstArr, secondArr, areItemsEqual) {
    return firstArr.filter((firstItem) => {
      return secondArr.every((secondItem) => {
        return !areItemsEqual(firstItem, secondItem);
      });
    });
  }
  function drop(arr, itemsCount) {
    itemsCount = Math.max(itemsCount, 0);
    return arr.slice(itemsCount);
  }
  function dropRight(arr, itemsCount) {
    itemsCount = Math.min(-itemsCount, 0);
    if (itemsCount === 0) {
      return arr.slice();
    }
    return arr.slice(0, itemsCount);
  }
  function dropRightWhile(arr, canContinueDropping) {
    for (let i = arr.length - 1; i >= 0; i--) {
      if (!canContinueDropping(arr[i], i, arr)) {
        return arr.slice(0, i + 1);
      }
    }
    return [];
  }
  function dropWhile(arr, canContinueDropping) {
    const dropEndIndex = arr.findIndex((item, index2, arr2) => !canContinueDropping(item, index2, arr2));
    if (dropEndIndex === -1) {
      return [];
    }
    return arr.slice(dropEndIndex);
  }
  function fill(array2, value, start = 0, end = array2.length) {
    const length2 = array2.length;
    const finalStart = Math.max(start >= 0 ? start : length2 + start, 0);
    const finalEnd = Math.min(end >= 0 ? end : length2 + end, length2);
    for (let i = finalStart; i < finalEnd; i++) {
      array2[i] = value;
    }
    return array2;
  }
  function flatten(arr, depth = 1) {
    const result = [];
    const flooredDepth = Math.floor(depth);
    const recursive = (arr2, currentDepth) => {
      for (let i = 0; i < arr2.length; i++) {
        const item = arr2[i];
        if (Array.isArray(item) && currentDepth < flooredDepth) {
          recursive(item, currentDepth + 1);
        } else {
          result.push(item);
        }
      }
    };
    recursive(arr, 0);
    return result;
  }
  function flatMap(arr, iteratee2, depth = 1) {
    return flatten(arr.map((item) => iteratee2(item)), depth);
  }
  function flattenDeep(arr) {
    return flatten(arr, Infinity);
  }
  function flatMapDeep(arr, iteratee2) {
    return flattenDeep(arr.map((item) => iteratee2(item)));
  }
  function forEachRight(arr, callback) {
    for (let i = arr.length - 1; i >= 0; i--) {
      const element = arr[i];
      callback(element, i, arr);
    }
  }
  function groupBy(arr, getKeyFromItem) {
    const result = {};
    for (let i = 0; i < arr.length; i++) {
      const item = arr[i];
      const key = getKeyFromItem(item);
      if (!Object.hasOwn(result, key)) {
        result[key] = [];
      }
      result[key].push(item);
    }
    return result;
  }
  function head(arr) {
    return arr[0];
  }
  function initial(arr) {
    return arr.slice(0, -1);
  }
  function intersection(firstArr, secondArr) {
    const secondSet = new Set(secondArr);
    return firstArr.filter((item) => {
      return secondSet.has(item);
    });
  }
  function intersectionBy(firstArr, secondArr, mapper) {
    const mappedSecondSet = new Set(secondArr.map(mapper));
    return firstArr.filter((item) => mappedSecondSet.has(mapper(item)));
  }
  function intersectionWith(firstArr, secondArr, areItemsEqual) {
    return firstArr.filter((firstItem) => {
      return secondArr.some((secondItem) => {
        return areItemsEqual(firstItem, secondItem);
      });
    });
  }
  function isSubset(superset2, subset2) {
    return difference(subset2, superset2).length === 0;
  }
  function isSubsetWith(superset2, subset2, areItemsEqual) {
    return differenceWith(subset2, superset2, areItemsEqual).length === 0;
  }
  function keyBy(arr, getKeyFromItem) {
    const result = {};
    for (let i = 0; i < arr.length; i++) {
      const item = arr[i];
      const key = getKeyFromItem(item);
      result[key] = item;
    }
    return result;
  }
  function last(arr) {
    return arr[arr.length - 1];
  }
  function maxBy(items, getValue2) {
    if (items.length === 0) {
      return void 0;
    }
    let maxElement = items[0];
    let max2 = getValue2(maxElement);
    for (let i = 1; i < items.length; i++) {
      const element = items[i];
      const value = getValue2(element);
      if (value > max2) {
        max2 = value;
        maxElement = element;
      }
    }
    return maxElement;
  }
  function minBy(items, getValue2) {
    if (items.length === 0) {
      return void 0;
    }
    let minElement = items[0];
    let min2 = getValue2(minElement);
    for (let i = 1; i < items.length; i++) {
      const element = items[i];
      const value = getValue2(element);
      if (value < min2) {
        min2 = value;
        minElement = element;
      }
    }
    return minElement;
  }
  function compareValues(a2, b, order) {
    if (a2 < b) {
      return order === "asc" ? -1 : 1;
    }
    if (a2 > b) {
      return order === "asc" ? 1 : -1;
    }
    return 0;
  }
  function orderBy(arr, criteria, orders) {
    return arr.slice().sort((a2, b) => {
      const ordersLength = orders.length;
      for (let i = 0; i < criteria.length; i++) {
        const order = ordersLength > i ? orders[i] : orders[ordersLength - 1];
        const criterion = criteria[i];
        const criterionIsFunction = typeof criterion === "function";
        const valueA = criterionIsFunction ? criterion(a2) : a2[criterion];
        const valueB = criterionIsFunction ? criterion(b) : b[criterion];
        const result = compareValues(valueA, valueB, order);
        if (result !== 0) {
          return result;
        }
      }
      return 0;
    });
  }
  function partition(arr, isInTruthy) {
    const truthy = [];
    const falsy = [];
    for (let i = 0; i < arr.length; i++) {
      const item = arr[i];
      if (isInTruthy(item)) {
        truthy.push(item);
      } else {
        falsy.push(item);
      }
    }
    return [truthy, falsy];
  }
  function pull(arr, valuesToRemove) {
    const valuesSet = new Set(valuesToRemove);
    let resultIndex = 0;
    for (let i = 0; i < arr.length; i++) {
      if (valuesSet.has(arr[i])) {
        continue;
      }
      if (!Object.hasOwn(arr, i)) {
        delete arr[resultIndex++];
        continue;
      }
      arr[resultIndex++] = arr[i];
    }
    arr.length = resultIndex;
    return arr;
  }
  function pullAt(arr, indicesToRemove) {
    const removed = at(arr, indicesToRemove);
    const indices = new Set(indicesToRemove.slice().sort((x2, y2) => y2 - x2));
    for (const index2 of indices) {
      arr.splice(index2, 1);
    }
    return removed;
  }
  function remove(arr, shouldRemoveElement) {
    const originalArr = arr.slice();
    const removed = [];
    let resultIndex = 0;
    for (let i = 0; i < arr.length; i++) {
      if (shouldRemoveElement(arr[i], i, originalArr)) {
        removed.push(arr[i]);
        continue;
      }
      if (!Object.hasOwn(arr, i)) {
        delete arr[resultIndex++];
        continue;
      }
      arr[resultIndex++] = arr[i];
    }
    arr.length = resultIndex;
    return removed;
  }
  function sample(arr) {
    const randomIndex = Math.floor(Math.random() * arr.length);
    return arr[randomIndex];
  }
  function random(minimum, maximum) {
    if (maximum == null) {
      maximum = minimum;
      minimum = 0;
    }
    if (minimum >= maximum) {
      throw new Error("Invalid input: The maximum value must be greater than the minimum value.");
    }
    return Math.random() * (maximum - minimum) + minimum;
  }
  function randomInt(minimum, maximum) {
    return Math.floor(random(minimum, maximum));
  }
  function sampleSize(array2, size) {
    if (size > array2.length) {
      throw new Error("Size must be less than or equal to the length of array.");
    }
    const result = new Array(size);
    const selected = /* @__PURE__ */ new Set();
    for (let step = array2.length - size, resultIndex = 0; step < array2.length; step++, resultIndex++) {
      let index2 = randomInt(0, step + 1);
      if (selected.has(index2)) {
        index2 = step;
      }
      selected.add(index2);
      result[resultIndex] = array2[index2];
    }
    return result;
  }
  function shuffle(arr) {
    const result = arr.slice();
    for (let i = result.length - 1; i >= 1; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
  }
  function sortBy(arr, criteria) {
    return orderBy(arr, criteria, ["asc"]);
  }
  function tail(arr) {
    return arr.slice(1);
  }
  function isSymbol$1(value) {
    return typeof value === "symbol" || value instanceof Symbol;
  }
  function toNumber(value) {
    if (isSymbol$1(value)) {
      return NaN;
    }
    return Number(value);
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === Infinity || value === -Infinity) {
      const sign2 = value < 0 ? -1 : 1;
      return sign2 * Number.MAX_VALUE;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    const finite = toFinite(value);
    const remainder = finite % 1;
    return remainder ? finite - remainder : finite;
  }
  function take(arr, count2, guard) {
    count2 = guard || count2 === void 0 ? 1 : toInteger(count2);
    return arr.slice(0, count2);
  }
  function takeRight(arr, count2 = 1, guard) {
    count2 = guard || count2 === void 0 ? 1 : toInteger(count2);
    if (count2 <= 0 || arr == null || arr.length === 0) {
      return [];
    }
    return arr.slice(-count2);
  }
  function takeRightWhile(arr, shouldContinueTaking) {
    for (let i = arr.length - 1; i >= 0; i--) {
      if (!shouldContinueTaking(arr[i])) {
        return arr.slice(i + 1);
      }
    }
    return arr.slice();
  }
  function takeWhile(arr, shouldContinueTaking) {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
      const item = arr[i];
      if (!shouldContinueTaking(item)) {
        break;
      }
      result.push(item);
    }
    return result;
  }
  function toFilled(arr, value, start = 0, end = arr.length) {
    const length2 = arr.length;
    const finalStart = Math.max(start >= 0 ? start : length2 + start, 0);
    const finalEnd = Math.min(end >= 0 ? end : length2 + end, length2);
    const newArr = arr.slice();
    for (let i = finalStart; i < finalEnd; i++) {
      newArr[i] = value;
    }
    return newArr;
  }
  function uniq(arr) {
    return Array.from(new Set(arr));
  }
  function union(arr1, arr2) {
    return uniq(arr1.concat(arr2));
  }
  function uniqBy(arr, mapper) {
    const map2 = /* @__PURE__ */ new Map();
    for (let i = 0; i < arr.length; i++) {
      const item = arr[i];
      const key = mapper(item);
      if (!map2.has(key)) {
        map2.set(key, item);
      }
    }
    return Array.from(map2.values());
  }
  function unionBy(arr1, arr2, mapper) {
    return uniqBy(arr1.concat(arr2), mapper);
  }
  function uniqWith(arr, areItemsEqual) {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
      const item = arr[i];
      const isUniq = result.every((v) => !areItemsEqual(v, item));
      if (isUniq) {
        result.push(item);
      }
    }
    return result;
  }
  function unionWith(arr1, arr2, areItemsEqual) {
    return uniqWith(arr1.concat(arr2), areItemsEqual);
  }
  function unzip(zipped) {
    let maxLen = 0;
    for (let i = 0; i < zipped.length; i++) {
      if (zipped[i].length > maxLen) {
        maxLen = zipped[i].length;
      }
    }
    const result = new Array(maxLen);
    for (let i = 0; i < maxLen; i++) {
      result[i] = new Array(zipped.length);
      for (let j = 0; j < zipped.length; j++) {
        result[i][j] = zipped[j][i];
      }
    }
    return result;
  }
  function unzipWith(target, iteratee2) {
    const maxLength = Math.max(...target.map((innerArray) => innerArray.length));
    const result = new Array(maxLength);
    for (let i = 0; i < maxLength; i++) {
      const group2 = new Array(target.length);
      for (let j = 0; j < target.length; j++) {
        group2[j] = target[j][i];
      }
      result[i] = iteratee2(...group2);
    }
    return result;
  }
  function windowed(arr, size, step = 1, { partialWindows = false } = {}) {
    if (size <= 0 || !Number.isInteger(size)) {
      throw new Error("Size must be a positive integer.");
    }
    if (step <= 0 || !Number.isInteger(step)) {
      throw new Error("Step must be a positive integer.");
    }
    const result = [];
    const end = partialWindows ? arr.length : arr.length - size + 1;
    for (let i = 0; i < end; i += step) {
      result.push(arr.slice(i, i + size));
    }
    return result;
  }
  function without(array2, ...values) {
    return difference(array2, values);
  }
  function xor(arr1, arr2) {
    return difference(union(arr1, arr2), intersection(arr1, arr2));
  }
  function xorBy(arr1, arr2, mapper) {
    const union2 = unionBy(arr1, arr2, mapper);
    const intersection2 = intersectionBy(arr1, arr2, mapper);
    return differenceBy(union2, intersection2, mapper);
  }
  function xorWith(arr1, arr2, areElementsEqual) {
    const union2 = unionWith(arr1, arr2, areElementsEqual);
    const intersection2 = intersectionWith(arr1, arr2, areElementsEqual);
    return differenceWith(union2, intersection2, areElementsEqual);
  }
  function zip(...arrs) {
    let rowCount = 0;
    for (let i = 0; i < arrs.length; i++) {
      if (arrs[i].length > rowCount) {
        rowCount = arrs[i].length;
      }
    }
    const columnCount = arrs.length;
    const result = Array(rowCount);
    for (let i = 0; i < rowCount; ++i) {
      const row = Array(columnCount);
      for (let j = 0; j < columnCount; ++j) {
        row[j] = arrs[j][i];
      }
      result[i] = row;
    }
    return result;
  }
  function zipObject(keys, values) {
    const result = {};
    for (let i = 0; i < keys.length; i++) {
      result[keys[i]] = values[i];
    }
    return result;
  }
  function zipWith(arr1, ...rest2) {
    const arrs = [arr1, ...rest2.slice(0, -1)];
    const combine = rest2[rest2.length - 1];
    const maxIndex2 = Math.max(...arrs.map((arr) => arr.length));
    const result = Array(maxIndex2);
    for (let i = 0; i < maxIndex2; i++) {
      const elements = arrs.map((arr) => arr[i]);
      result[i] = combine(...elements);
    }
    return result;
  }
  class AbortError extends Error {
    constructor(message = "The operation was aborted") {
      super(message);
      this.name = "AbortError";
    }
  }
  class TimeoutError extends Error {
    constructor(message = "The operation was timed out") {
      super(message);
      this.name = "TimeoutError";
    }
  }
  function after(n, func) {
    if (!Number.isInteger(n) || n < 0) {
      throw new Error(`n must be a non-negative integer.`);
    }
    let counter = 0;
    return (...args) => {
      if (++counter >= n) {
        return func(...args);
      }
      return void 0;
    };
  }
  function ary(func, n) {
    return function(...args) {
      return func.apply(this, args.slice(0, n));
    };
  }
  async function asyncNoop() {
  }
  function before(n, func) {
    if (!Number.isInteger(n) || n < 0) {
      throw new Error("n must be a non-negative integer.");
    }
    let counter = 0;
    return (...args) => {
      if (++counter < n) {
        return func(...args);
      }
      return void 0;
    };
  }
  function curry(func) {
    if (func.length === 0 || func.length === 1) {
      return func;
    }
    return function(arg) {
      return makeCurry(func, func.length, [arg]);
    };
  }
  function makeCurry(origin, argsLength, args) {
    if (args.length === argsLength) {
      return origin(...args);
    } else {
      const next = function(arg) {
        return makeCurry(origin, argsLength, [...args, arg]);
      };
      return next;
    }
  }
  function curryRight(func) {
    if (func.length === 0 || func.length === 1) {
      return func;
    }
    return function(arg) {
      return makeCurryRight(func, func.length, [arg]);
    };
  }
  function makeCurryRight(origin, argsLength, args) {
    if (args.length === argsLength) {
      return origin(...args);
    } else {
      const next = function(arg) {
        return makeCurryRight(origin, argsLength, [arg, ...args]);
      };
      return next;
    }
  }
  function debounce(func, debounceMs, { signal, edges } = {}) {
    let pendingThis = void 0;
    let pendingArgs = null;
    const leading = edges != null && edges.includes("leading");
    const trailing = edges == null || edges.includes("trailing");
    const invoke = () => {
      if (pendingArgs !== null) {
        func.apply(pendingThis, pendingArgs);
        pendingThis = void 0;
        pendingArgs = null;
      }
    };
    const onTimerEnd = () => {
      if (trailing) {
        invoke();
      }
      cancel();
    };
    let timeoutId = null;
    const schedule = () => {
      if (timeoutId != null) {
        clearTimeout(timeoutId);
      }
      timeoutId = setTimeout(() => {
        timeoutId = null;
        onTimerEnd();
      }, debounceMs);
    };
    const cancelTimer = () => {
      if (timeoutId !== null) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
    };
    const cancel = () => {
      cancelTimer();
      pendingThis = void 0;
      pendingArgs = null;
    };
    const flush = () => {
      invoke();
    };
    const debounced = function(...args) {
      if (signal == null ? void 0 : signal.aborted) {
        return;
      }
      pendingThis = this;
      pendingArgs = args;
      const isFirstCall = timeoutId == null;
      schedule();
      if (leading && isFirstCall) {
        invoke();
      }
    };
    debounced.schedule = schedule;
    debounced.cancel = cancel;
    debounced.flush = flush;
    signal == null ? void 0 : signal.addEventListener("abort", cancel, { once: true });
    return debounced;
  }
  function flow(...funcs) {
    return function(...args) {
      let result = funcs.length ? funcs[0].apply(this, args) : args[0];
      for (let i = 1; i < funcs.length; i++) {
        result = funcs[i].call(this, result);
      }
      return result;
    };
  }
  function flowRight(...funcs) {
    return flow(...funcs.reverse());
  }
  function identity(x2) {
    return x2;
  }
  function memoize(fn, options2 = {}) {
    const { cache = /* @__PURE__ */ new Map(), getCacheKey } = options2;
    const memoizedFn = function(arg) {
      const key = getCacheKey ? getCacheKey(arg) : arg;
      if (cache.has(key)) {
        return cache.get(key);
      }
      const result = fn.call(this, arg);
      cache.set(key, result);
      return result;
    };
    memoizedFn.cache = cache;
    return memoizedFn;
  }
  function negate(func) {
    return (...args) => !func(...args);
  }
  function noop$1() {
  }
  function once(func) {
    let called = false;
    let cache;
    return function(...args) {
      if (!called) {
        called = true;
        cache = func(...args);
      }
      return cache;
    };
  }
  function partial(func, ...partialArgs) {
    return partialImpl(func, placeholderSymbol$1, ...partialArgs);
  }
  function partialImpl(func, placeholder, ...partialArgs) {
    const partialed = function(...providedArgs) {
      let providedArgsIndex = 0;
      const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
      const remainingArgs = providedArgs.slice(providedArgsIndex);
      return func.apply(this, substitutedArgs.concat(remainingArgs));
    };
    if (func.prototype) {
      partialed.prototype = Object.create(func.prototype);
    }
    return partialed;
  }
  const placeholderSymbol$1 = Symbol("partial.placeholder");
  partial.placeholder = placeholderSymbol$1;
  function partialRight(func, ...partialArgs) {
    return partialRightImpl(func, placeholderSymbol, ...partialArgs);
  }
  function partialRightImpl(func, placeholder, ...partialArgs) {
    const partialedRight = function(...providedArgs) {
      const placeholderLength = partialArgs.filter((arg) => arg === placeholder).length;
      const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
      const remainingArgs = providedArgs.slice(0, rangeLength);
      let providedArgsIndex = rangeLength;
      const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
      return func.apply(this, remainingArgs.concat(substitutedArgs));
    };
    if (func.prototype) {
      partialedRight.prototype = Object.create(func.prototype);
    }
    return partialedRight;
  }
  const placeholderSymbol = Symbol("partialRight.placeholder");
  partialRight.placeholder = placeholderSymbol;
  function rest(func, startIndex = func.length - 1) {
    return function(...args) {
      const rest2 = args.slice(startIndex);
      const params = args.slice(0, startIndex);
      while (params.length < startIndex) {
        params.push(void 0);
      }
      return func.apply(this, [...params, rest2]);
    };
  }
  function delay(ms, { signal } = {}) {
    return new Promise((resolve, reject) => {
      const abortError = () => {
        reject(new AbortError());
      };
      const abortHandler = () => {
        clearTimeout(timeoutId);
        abortError();
      };
      if (signal == null ? void 0 : signal.aborted) {
        return abortError();
      }
      const timeoutId = setTimeout(() => {
        signal == null ? void 0 : signal.removeEventListener("abort", abortHandler);
        resolve();
      }, ms);
      signal == null ? void 0 : signal.addEventListener("abort", abortHandler, { once: true });
    });
  }
  const DEFAULT_DELAY = 0;
  const DEFAULT_RETRIES = Number.POSITIVE_INFINITY;
  async function retry(func, _options) {
    let delay$1;
    let retries;
    let signal;
    if (typeof _options === "number") {
      delay$1 = DEFAULT_DELAY;
      retries = _options;
      signal = void 0;
    } else {
      delay$1 = (_options == null ? void 0 : _options.delay) ?? DEFAULT_DELAY;
      retries = (_options == null ? void 0 : _options.retries) ?? DEFAULT_RETRIES;
      signal = _options == null ? void 0 : _options.signal;
    }
    let error;
    for (let attempts = 0; attempts < retries; attempts++) {
      if (signal == null ? void 0 : signal.aborted) {
        throw error ?? new Error(`The retry operation was aborted due to an abort signal.`);
      }
      try {
        return await func();
      } catch (err) {
        error = err;
        const currentDelay = typeof delay$1 === "function" ? delay$1(attempts) : delay$1;
        await delay(currentDelay);
      }
    }
    throw error;
  }
  function spread(func) {
    return function(argsArr) {
      return func.apply(this, argsArr);
    };
  }
  function throttle(func, throttleMs, { signal, edges = ["leading", "trailing"] } = {}) {
    let pendingAt = null;
    const debounced = debounce(func, throttleMs, { signal, edges });
    const throttled = function(...args) {
      if (pendingAt == null) {
        pendingAt = Date.now();
      } else {
        if (Date.now() - pendingAt >= throttleMs) {
          pendingAt = Date.now();
          debounced.cancel();
        }
      }
      debounced(...args);
    };
    throttled.cancel = debounced.cancel;
    throttled.flush = debounced.flush;
    return throttled;
  }
  function unary(func) {
    return ary(func, 1);
  }
  function clamp(value, bound1, bound2) {
    if (bound2 == null) {
      return Math.min(value, bound1);
    }
    return Math.min(Math.max(value, bound1), bound2);
  }
  function inRange(value, minimum, maximum) {
    if (maximum == null) {
      maximum = minimum;
      minimum = 0;
    }
    if (minimum >= maximum) {
      throw new Error("The maximum value must be greater than the minimum value.");
    }
    return minimum <= value && value < maximum;
  }
  function sum(nums) {
    let result = 0;
    for (let i = 0; i < nums.length; i++) {
      result += nums[i];
    }
    return result;
  }
  function mean(nums) {
    return sum(nums) / nums.length;
  }
  function meanBy(items, getValue2) {
    const nums = items.map((x2) => getValue2(x2));
    return mean(nums);
  }
  function median(nums) {
    if (nums.length === 0) {
      return NaN;
    }
    const sorted = nums.slice().sort((a2, b) => a2 - b);
    const middleIndex = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 0) {
      return (sorted[middleIndex - 1] + sorted[middleIndex]) / 2;
    } else {
      return sorted[middleIndex];
    }
  }
  function medianBy(items, getValue2) {
    const nums = items.map((x2) => getValue2(x2));
    return median(nums);
  }
  function range(start, end, step = 1) {
    if (end == null) {
      end = start;
      start = 0;
    }
    if (!Number.isInteger(step) || step === 0) {
      throw new Error(`The step value must be a non-zero integer.`);
    }
    const length2 = Math.max(Math.ceil((end - start) / step), 0);
    const result = new Array(length2);
    for (let i = 0; i < length2; i++) {
      result[i] = start + i * step;
    }
    return result;
  }
  function rangeRight(start, end, step = 1) {
    if (end == null) {
      end = start;
      start = 0;
    }
    if (!Number.isInteger(step) || step === 0) {
      throw new Error(`The step value must be a non-zero integer.`);
    }
    const length2 = Math.max(Math.ceil((end - start) / step), 0);
    const result = new Array(length2);
    for (let i = 0; i < length2; i++) {
      result[i] = start + (length2 - i - 1) * step;
    }
    return result;
  }
  function round(value, precision = 0) {
    if (!Number.isInteger(precision)) {
      throw new Error("Precision must be an integer.");
    }
    const multiplier = Math.pow(10, precision);
    return Math.round(value * multiplier) / multiplier;
  }
  function sumBy$4(items, getValue2) {
    let result = 0;
    for (let i = 0; i < items.length; i++) {
      result += getValue2(items[i]);
    }
    return result;
  }
  function isPrimitive(value) {
    return value == null || typeof value !== "object" && typeof value !== "function";
  }
  function isTypedArray(x2) {
    return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
  }
  function clone(obj) {
    if (isPrimitive(obj)) {
      return obj;
    }
    if (Array.isArray(obj) || isTypedArray(obj) || obj instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && obj instanceof SharedArrayBuffer) {
      return obj.slice(0);
    }
    const prototype = Object.getPrototypeOf(obj);
    const Constructor = prototype.constructor;
    if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {
      return new Constructor(obj);
    }
    if (obj instanceof RegExp) {
      const newRegExp = new Constructor(obj);
      newRegExp.lastIndex = obj.lastIndex;
      return newRegExp;
    }
    if (obj instanceof DataView) {
      return new Constructor(obj.buffer.slice(0));
    }
    if (obj instanceof Error) {
      const newError = new Constructor(obj.message);
      newError.stack = obj.stack;
      newError.name = obj.name;
      newError.cause = obj.cause;
      return newError;
    }
    if (typeof File !== "undefined" && obj instanceof File) {
      const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });
      return newFile;
    }
    if (typeof obj === "object") {
      const newObject = Object.create(prototype);
      return Object.assign(newObject, obj);
    }
    return obj;
  }
  function getSymbols(object2) {
    return Object.getOwnPropertySymbols(object2).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object2, symbol));
  }
  function getTag(value) {
    if (value == null) {
      return value === void 0 ? "[object Undefined]" : "[object Null]";
    }
    return Object.prototype.toString.call(value);
  }
  const regexpTag = "[object RegExp]";
  const stringTag = "[object String]";
  const numberTag = "[object Number]";
  const booleanTag = "[object Boolean]";
  const argumentsTag = "[object Arguments]";
  const symbolTag = "[object Symbol]";
  const dateTag = "[object Date]";
  const mapTag = "[object Map]";
  const setTag = "[object Set]";
  const arrayTag = "[object Array]";
  const functionTag = "[object Function]";
  const arrayBufferTag = "[object ArrayBuffer]";
  const objectTag = "[object Object]";
  const errorTag = "[object Error]";
  const dataViewTag = "[object DataView]";
  const uint8ArrayTag = "[object Uint8Array]";
  const uint8ClampedArrayTag = "[object Uint8ClampedArray]";
  const uint16ArrayTag = "[object Uint16Array]";
  const uint32ArrayTag = "[object Uint32Array]";
  const bigUint64ArrayTag = "[object BigUint64Array]";
  const int8ArrayTag = "[object Int8Array]";
  const int16ArrayTag = "[object Int16Array]";
  const int32ArrayTag = "[object Int32Array]";
  const bigInt64ArrayTag = "[object BigInt64Array]";
  const float32ArrayTag = "[object Float32Array]";
  const float64ArrayTag = "[object Float64Array]";
  function cloneDeepWith(obj, cloneValue) {
    return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), cloneValue);
  }
  function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
    const cloned = cloneValue == null ? void 0 : cloneValue(valueToClone, keyToClone, objectToClone, stack);
    if (cloned !== void 0) {
      return cloned;
    }
    if (isPrimitive(valueToClone)) {
      return valueToClone;
    }
    if (stack.has(valueToClone)) {
      return stack.get(valueToClone);
    }
    if (Array.isArray(valueToClone)) {
      const result = new Array(valueToClone.length);
      stack.set(valueToClone, result);
      for (let i = 0; i < valueToClone.length; i++) {
        result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
      }
      if (Object.hasOwn(valueToClone, "index")) {
        result.index = valueToClone.index;
      }
      if (Object.hasOwn(valueToClone, "input")) {
        result.input = valueToClone.input;
      }
      return result;
    }
    if (valueToClone instanceof Date) {
      return new Date(valueToClone.getTime());
    }
    if (valueToClone instanceof RegExp) {
      const result = new RegExp(valueToClone.source, valueToClone.flags);
      result.lastIndex = valueToClone.lastIndex;
      return result;
    }
    if (valueToClone instanceof Map) {
      const result = /* @__PURE__ */ new Map();
      stack.set(valueToClone, result);
      for (const [key, value] of valueToClone) {
        result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));
      }
      return result;
    }
    if (valueToClone instanceof Set) {
      const result = /* @__PURE__ */ new Set();
      stack.set(valueToClone, result);
      for (const value of valueToClone) {
        result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack, cloneValue));
      }
      return result;
    }
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
      return valueToClone.subarray();
    }
    if (isTypedArray(valueToClone)) {
      const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
      stack.set(valueToClone, result);
      for (let i = 0; i < valueToClone.length; i++) {
        result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
      }
      return result;
    }
    if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
      return valueToClone.slice(0);
    }
    if (valueToClone instanceof DataView) {
      const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
      stack.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    if (typeof File !== "undefined" && valueToClone instanceof File) {
      const result = new File([valueToClone], valueToClone.name, {
        type: valueToClone.type
      });
      stack.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    if (valueToClone instanceof Blob) {
      const result = new Blob([valueToClone], { type: valueToClone.type });
      stack.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    if (valueToClone instanceof Error) {
      const result = new valueToClone.constructor();
      stack.set(valueToClone, result);
      result.message = valueToClone.message;
      result.name = valueToClone.name;
      result.stack = valueToClone.stack;
      result.cause = valueToClone.cause;
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
      const result = Object.create(Object.getPrototypeOf(valueToClone));
      stack.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    return valueToClone;
  }
  function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
    const keys = [...Object.keys(source), ...getSymbols(source)];
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const descriptor = Object.getOwnPropertyDescriptor(target, key);
      if (descriptor == null || descriptor.writable) {
        target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);
      }
    }
  }
  function isCloneableObject(object2) {
    switch (getTag(object2)) {
      case argumentsTag:
      case arrayTag:
      case arrayBufferTag:
      case dataViewTag:
      case booleanTag:
      case dateTag:
      case float32ArrayTag:
      case float64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case mapTag:
      case numberTag:
      case objectTag:
      case regexpTag:
      case setTag:
      case stringTag:
      case symbolTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag: {
        return true;
      }
      default: {
        return false;
      }
    }
  }
  function cloneDeep(obj) {
    return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
  }
  function findKey(obj, predicate) {
    const keys = Object.keys(obj);
    return keys.find((key) => predicate(obj[key], key, obj));
  }
  function isPlainObject$2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    const proto2 = Object.getPrototypeOf(value);
    const hasObjectPrototype = proto2 === null || proto2 === Object.prototype || Object.getPrototypeOf(proto2) === null;
    if (!hasObjectPrototype) {
      return false;
    }
    return Object.prototype.toString.call(value) === "[object Object]";
  }
  function flattenObject(object2, { delimiter = "." } = {}) {
    return flattenObjectImpl(object2, "", delimiter);
  }
  function flattenObjectImpl(object2, prefix2 = "", delimiter = ".") {
    const result = {};
    const keys = Object.keys(object2);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = object2[key];
      const prefixedKey = prefix2 ? `${prefix2}${delimiter}${key}` : key;
      if (isPlainObject$2(value) && Object.keys(value).length > 0) {
        Object.assign(result, flattenObjectImpl(value, prefixedKey, delimiter));
        continue;
      }
      if (Array.isArray(value)) {
        Object.assign(result, flattenObjectImpl(value, prefixedKey, delimiter));
        continue;
      }
      result[prefixedKey] = value;
    }
    return result;
  }
  function invert(obj) {
    const result = {};
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = obj[key];
      result[value] = key;
    }
    return result;
  }
  function mapKeys(object2, getNewKey) {
    const result = {};
    const keys = Object.keys(object2);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = object2[key];
      result[getNewKey(value, key, object2)] = value;
    }
    return result;
  }
  function mapValues(object2, getNewValue) {
    const result = {};
    const keys = Object.keys(object2);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = object2[key];
      result[key] = getNewValue(value, key, object2);
    }
    return result;
  }
  function isUnsafeProperty(key) {
    return key === "__proto__";
  }
  function merge(target, source) {
    const sourceKeys = Object.keys(source);
    for (let i = 0; i < sourceKeys.length; i++) {
      const key = sourceKeys[i];
      if (isUnsafeProperty(key)) {
        continue;
      }
      const sourceValue = source[key];
      const targetValue = target[key];
      if (Array.isArray(sourceValue)) {
        if (Array.isArray(targetValue)) {
          target[key] = merge(targetValue, sourceValue);
        } else {
          target[key] = merge([], sourceValue);
        }
      } else if (isPlainObject$2(sourceValue)) {
        if (isPlainObject$2(targetValue)) {
          target[key] = merge(targetValue, sourceValue);
        } else {
          target[key] = merge({}, sourceValue);
        }
      } else if (targetValue === void 0 || sourceValue !== void 0) {
        target[key] = sourceValue;
      }
    }
    return target;
  }
  function isObjectLike(value) {
    return typeof value === "object" && value !== null;
  }
  function mergeWith(target, source, merge2) {
    const sourceKeys = Object.keys(source);
    for (let i = 0; i < sourceKeys.length; i++) {
      const key = sourceKeys[i];
      if (isUnsafeProperty(key)) {
        continue;
      }
      const sourceValue = source[key];
      const targetValue = target[key];
      const merged = merge2(targetValue, sourceValue, key, target, source);
      if (merged !== void 0) {
        target[key] = merged;
      } else if (Array.isArray(sourceValue)) {
        target[key] = mergeWith(targetValue ?? [], sourceValue, merge2);
      } else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {
        target[key] = mergeWith(targetValue ?? {}, sourceValue, merge2);
      } else if (targetValue === void 0 || sourceValue !== void 0) {
        target[key] = sourceValue;
      }
    }
    return target;
  }
  function omit$4(obj, keys) {
    const result = { ...obj };
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      delete result[key];
    }
    return result;
  }
  function omitBy(obj, shouldOmit) {
    const result = {};
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = obj[key];
      if (!shouldOmit(value, key)) {
        result[key] = value;
      }
    }
    return result;
  }
  function pick(obj, keys) {
    const result = {};
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (Object.hasOwn(obj, key)) {
        result[key] = obj[key];
      }
    }
    return result;
  }
  function pickBy(obj, shouldPick) {
    const result = {};
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = obj[key];
      if (shouldPick(value, key)) {
        result[key] = value;
      }
    }
    return result;
  }
  function isArray(value) {
    return Array.isArray(value);
  }
  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
  }
  const CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");
  function words(str) {
    return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);
  }
  function camelCase(str) {
    const words$1 = words(str);
    if (words$1.length === 0) {
      return "";
    }
    const [first, ...rest2] = words$1;
    return `${first.toLowerCase()}${rest2.map((word) => capitalize(word)).join("")}`;
  }
  function toCamelCaseKeys(obj) {
    if (isArray(obj)) {
      return obj.map((item) => toCamelCaseKeys(item));
    }
    if (isPlainObject$2(obj)) {
      const result = {};
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const camelKey = camelCase(key);
        const camelCaseKeys = toCamelCaseKeys(obj[key]);
        result[camelKey] = camelCaseKeys;
      }
      return result;
    }
    return obj;
  }
  function toMerged(target, source) {
    return merge(cloneDeep(target), source);
  }
  function isPlainObject$1(object2) {
    var _a;
    if (typeof object2 !== "object") {
      return false;
    }
    if (object2 == null) {
      return false;
    }
    if (Object.getPrototypeOf(object2) === null) {
      return true;
    }
    if (Object.prototype.toString.call(object2) !== "[object Object]") {
      const tag = object2[Symbol.toStringTag];
      if (tag == null) {
        return false;
      }
      const isTagReadonly = !((_a = Object.getOwnPropertyDescriptor(object2, Symbol.toStringTag)) == null ? void 0 : _a.writable);
      if (isTagReadonly) {
        return false;
      }
      return object2.toString() === `[object ${tag}]`;
    }
    let proto2 = object2;
    while (Object.getPrototypeOf(proto2) !== null) {
      proto2 = Object.getPrototypeOf(proto2);
    }
    return Object.getPrototypeOf(object2) === proto2;
  }
  function snakeCase(str) {
    const words$1 = words(str);
    return words$1.map((word) => word.toLowerCase()).join("_");
  }
  function toSnakeCaseKeys(obj) {
    if (isArray(obj)) {
      return obj.map((item) => toSnakeCaseKeys(item));
    }
    if (isPlainObject$1(obj)) {
      const result = {};
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const snakeKey = snakeCase(key);
        const snakeCaseKeys = toSnakeCaseKeys(obj[key]);
        result[snakeKey] = snakeCaseKeys;
      }
      return result;
    }
    return obj;
  }
  function isArrayBuffer(value) {
    return value instanceof ArrayBuffer;
  }
  function isBlob(x2) {
    if (typeof Blob === "undefined") {
      return false;
    }
    return x2 instanceof Blob;
  }
  function isBoolean(x2) {
    return typeof x2 === "boolean";
  }
  function isBrowser() {
    return typeof window !== "undefined" && (window == null ? void 0 : window.document) != null;
  }
  function isBuffer(x2) {
    return typeof Buffer !== "undefined" && Buffer.isBuffer(x2);
  }
  function isDate(value) {
    return value instanceof Date;
  }
  function eq(value, other) {
    return value === other || Number.isNaN(value) && Number.isNaN(other);
  }
  function isEqualWith(a2, b, areValuesEqual) {
    return isEqualWithImpl(a2, b, void 0, void 0, void 0, void 0, areValuesEqual);
  }
  function isEqualWithImpl(a2, b, property2, aParent, bParent, stack, areValuesEqual) {
    const result = areValuesEqual(a2, b, property2, aParent, bParent, stack);
    if (result !== void 0) {
      return result;
    }
    if (typeof a2 === typeof b) {
      switch (typeof a2) {
        case "bigint":
        case "string":
        case "boolean":
        case "symbol":
        case "undefined": {
          return a2 === b;
        }
        case "number": {
          return a2 === b || Object.is(a2, b);
        }
        case "function": {
          return a2 === b;
        }
        case "object": {
          return areObjectsEqual(a2, b, stack, areValuesEqual);
        }
      }
    }
    return areObjectsEqual(a2, b, stack, areValuesEqual);
  }
  function areObjectsEqual(a2, b, stack, areValuesEqual) {
    if (Object.is(a2, b)) {
      return true;
    }
    let aTag = getTag(a2);
    let bTag = getTag(b);
    if (aTag === argumentsTag) {
      aTag = objectTag;
    }
    if (bTag === argumentsTag) {
      bTag = objectTag;
    }
    if (aTag !== bTag) {
      return false;
    }
    switch (aTag) {
      case stringTag:
        return a2.toString() === b.toString();
      case numberTag: {
        const x2 = a2.valueOf();
        const y2 = b.valueOf();
        return eq(x2, y2);
      }
      case booleanTag:
      case dateTag:
      case symbolTag:
        return Object.is(a2.valueOf(), b.valueOf());
      case regexpTag: {
        return a2.source === b.source && a2.flags === b.flags;
      }
      case functionTag: {
        return a2 === b;
      }
    }
    stack = stack ?? /* @__PURE__ */ new Map();
    const aStack = stack.get(a2);
    const bStack = stack.get(b);
    if (aStack != null && bStack != null) {
      return aStack === b;
    }
    stack.set(a2, b);
    stack.set(b, a2);
    try {
      switch (aTag) {
        case mapTag: {
          if (a2.size !== b.size) {
            return false;
          }
          for (const [key, value] of a2.entries()) {
            if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a2, b, stack, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        case setTag: {
          if (a2.size !== b.size) {
            return false;
          }
          const aValues = Array.from(a2.values());
          const bValues = Array.from(b.values());
          for (let i = 0; i < aValues.length; i++) {
            const aValue = aValues[i];
            const index2 = bValues.findIndex((bValue) => {
              return isEqualWithImpl(aValue, bValue, void 0, a2, b, stack, areValuesEqual);
            });
            if (index2 === -1) {
              return false;
            }
            bValues.splice(index2, 1);
          }
          return true;
        }
        case arrayTag:
        case uint8ArrayTag:
        case uint8ClampedArrayTag:
        case uint16ArrayTag:
        case uint32ArrayTag:
        case bigUint64ArrayTag:
        case int8ArrayTag:
        case int16ArrayTag:
        case int32ArrayTag:
        case bigInt64ArrayTag:
        case float32ArrayTag:
        case float64ArrayTag: {
          if (typeof Buffer !== "undefined" && Buffer.isBuffer(a2) !== Buffer.isBuffer(b)) {
            return false;
          }
          if (a2.length !== b.length) {
            return false;
          }
          for (let i = 0; i < a2.length; i++) {
            if (!isEqualWithImpl(a2[i], b[i], i, a2, b, stack, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        case arrayBufferTag: {
          if (a2.byteLength !== b.byteLength) {
            return false;
          }
          return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b), stack, areValuesEqual);
        }
        case dataViewTag: {
          if (a2.byteLength !== b.byteLength || a2.byteOffset !== b.byteOffset) {
            return false;
          }
          return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b), stack, areValuesEqual);
        }
        case errorTag: {
          return a2.name === b.name && a2.message === b.message;
        }
        case objectTag: {
          const areEqualInstances = areObjectsEqual(a2.constructor, b.constructor, stack, areValuesEqual) || isPlainObject$2(a2) && isPlainObject$2(b);
          if (!areEqualInstances) {
            return false;
          }
          const aKeys = [...Object.keys(a2), ...getSymbols(a2)];
          const bKeys = [...Object.keys(b), ...getSymbols(b)];
          if (aKeys.length !== bKeys.length) {
            return false;
          }
          for (let i = 0; i < aKeys.length; i++) {
            const propKey = aKeys[i];
            const aProp = a2[propKey];
            if (!Object.hasOwn(b, propKey)) {
              return false;
            }
            const bProp = b[propKey];
            if (!isEqualWithImpl(aProp, bProp, propKey, a2, b, stack, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        default: {
          return false;
        }
      }
    } finally {
      stack.delete(a2);
      stack.delete(b);
    }
  }
  function isEqual(a2, b) {
    return isEqualWith(a2, b, noop$1);
  }
  function isError(value) {
    return value instanceof Error;
  }
  function isFile(x2) {
    if (typeof File === "undefined") {
      return false;
    }
    return isBlob(x2) && x2 instanceof File;
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function isJSON(value) {
    if (typeof value !== "string") {
      return false;
    }
    try {
      JSON.parse(value);
      return true;
    } catch {
      return false;
    }
  }
  function isJSONValue(value) {
    switch (typeof value) {
      case "object": {
        return value === null || isJSONArray(value) || isJSONObject(value);
      }
      case "string":
      case "number":
      case "boolean": {
        return true;
      }
      default: {
        return false;
      }
    }
  }
  function isJSONArray(value) {
    if (!Array.isArray(value)) {
      return false;
    }
    return value.every((item) => isJSONValue(item));
  }
  function isJSONObject(obj) {
    if (!isPlainObject$2(obj)) {
      return false;
    }
    const keys = Reflect.ownKeys(obj);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = obj[key];
      if (typeof key !== "string") {
        return false;
      }
      if (!isJSONValue(value)) {
        return false;
      }
    }
    return true;
  }
  function isLength(value) {
    return Number.isSafeInteger(value) && value >= 0;
  }
  function isMap(value) {
    return value instanceof Map;
  }
  function isNil(x2) {
    return x2 == null;
  }
  function isNode() {
    var _a;
    return typeof process !== "undefined" && ((_a = process == null ? void 0 : process.versions) == null ? void 0 : _a.node) != null;
  }
  function isNotNil(x2) {
    return x2 != null;
  }
  function isNull(x2) {
    return x2 === null;
  }
  function isPromise(value) {
    return value instanceof Promise;
  }
  function isRegExp(value) {
    return value instanceof RegExp;
  }
  function isSet(value) {
    return value instanceof Set;
  }
  function isString(value) {
    return typeof value === "string";
  }
  function isSymbol(value) {
    return typeof value === "symbol";
  }
  function isUndefined(x2) {
    return x2 === void 0;
  }
  function isWeakMap(value) {
    return value instanceof WeakMap;
  }
  function isWeakSet(value) {
    return value instanceof WeakSet;
  }
  class Semaphore {
    constructor(capacity) {
      __publicField(this, "capacity");
      __publicField(this, "available");
      __publicField(this, "deferredTasks", []);
      this.capacity = capacity;
      this.available = capacity;
    }
    async acquire() {
      if (this.available > 0) {
        this.available--;
        return;
      }
      return new Promise((resolve) => {
        this.deferredTasks.push(resolve);
      });
    }
    release() {
      const deferredTask = this.deferredTasks.shift();
      if (deferredTask != null) {
        deferredTask();
        return;
      }
      if (this.available < this.capacity) {
        this.available++;
      }
    }
  }
  class Mutex {
    constructor() {
      __publicField(this, "semaphore", new Semaphore(1));
    }
    get isLocked() {
      return this.semaphore.available === 0;
    }
    async acquire() {
      return this.semaphore.acquire();
    }
    release() {
      this.semaphore.release();
    }
  }
  async function timeout(ms) {
    await delay(ms);
    throw new TimeoutError();
  }
  async function withTimeout(run, ms) {
    return Promise.race([run(), timeout(ms)]);
  }
  function constantCase(str) {
    const words$1 = words(str);
    return words$1.map((word) => word.toUpperCase()).join("_");
  }
  const deburrMap = new Map(Object.entries({
    Æ: "Ae",
    Ð: "D",
    Ø: "O",
    Þ: "Th",
    ß: "ss",
    æ: "ae",
    ð: "d",
    ø: "o",
    þ: "th",
    Đ: "D",
    đ: "d",
    Ħ: "H",
    ħ: "h",
    ı: "i",
    Ĳ: "IJ",
    ĳ: "ij",
    ĸ: "k",
    Ŀ: "L",
    ŀ: "l",
    Ł: "L",
    ł: "l",
    ŉ: "'n",
    Ŋ: "N",
    ŋ: "n",
    Œ: "Oe",
    œ: "oe",
    Ŧ: "T",
    ŧ: "t",
    ſ: "s"
  }));
  function deburr(str) {
    str = str.normalize("NFD");
    let result = "";
    for (let i = 0; i < str.length; i++) {
      const char = str[i];
      if (char >= "̀" && char <= "ͯ" || char >= "︠" && char <= "︣") {
        continue;
      }
      result += deburrMap.get(char) ?? char;
    }
    return result;
  }
  const htmlEscapes = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  function escape(str) {
    return str.replace(/[&<>"']/g, (match) => htmlEscapes[match]);
  }
  function escapeRegExp(str) {
    return str.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
  }
  function kebabCase(str) {
    const words$1 = words(str);
    return words$1.map((word) => word.toLowerCase()).join("-");
  }
  function lowerCase(str) {
    const words$1 = words(str);
    return words$1.map((word) => word.toLowerCase()).join(" ");
  }
  function lowerFirst(str) {
    return str.substring(0, 1).toLowerCase() + str.substring(1);
  }
  function pad(str, length2, chars = " ") {
    return str.padStart(Math.floor((length2 - str.length) / 2) + str.length, chars).padEnd(length2, chars);
  }
  function pascalCase(str) {
    const words$1 = words(str);
    return words$1.map((word) => capitalize(word)).join("");
  }
  function reverseString(value) {
    return [...value].reverse().join("");
  }
  function startCase(str) {
    const words$1 = words(str.trim());
    let result = "";
    for (let i = 0; i < words$1.length; i++) {
      const word = words$1[i];
      if (result) {
        result += " ";
      }
      result += word[0].toUpperCase() + word.slice(1).toLowerCase();
    }
    return result;
  }
  function trimEnd(str, chars) {
    if (chars === void 0) {
      return str.trimEnd();
    }
    let endIndex = str.length;
    switch (typeof chars) {
      case "string": {
        if (chars.length !== 1) {
          throw new Error(`The 'chars' parameter should be a single character string.`);
        }
        while (endIndex > 0 && str[endIndex - 1] === chars) {
          endIndex--;
        }
        break;
      }
      case "object": {
        while (endIndex > 0 && chars.includes(str[endIndex - 1])) {
          endIndex--;
        }
      }
    }
    return str.substring(0, endIndex);
  }
  function trimStart(str, chars) {
    if (chars === void 0) {
      return str.trimStart();
    }
    let startIndex = 0;
    switch (typeof chars) {
      case "string": {
        while (startIndex < str.length && str[startIndex] === chars) {
          startIndex++;
        }
        break;
      }
      case "object": {
        while (startIndex < str.length && chars.includes(str[startIndex])) {
          startIndex++;
        }
      }
    }
    return str.substring(startIndex);
  }
  function trim(str, chars) {
    if (chars === void 0) {
      return str.trim();
    }
    return trimStart(trimEnd(str, chars), chars);
  }
  const htmlUnescapes = {
    "&amp;": "&",
    "&lt;": "<",
    "&gt;": ">",
    "&quot;": '"',
    "&#39;": "'"
  };
  function unescape(str) {
    return str.replace(/&(?:amp|lt|gt|quot|#(0+)?39);/g, (match) => htmlUnescapes[match] || "'");
  }
  function upperCase(str) {
    const words$1 = words(str);
    let result = "";
    for (let i = 0; i < words$1.length; i++) {
      result += words$1[i].toUpperCase();
      if (i < words$1.length - 1) {
        result += " ";
      }
    }
    return result;
  }
  function upperFirst(str) {
    return str.substring(0, 1).toUpperCase() + str.substring(1);
  }
  function attempt(func) {
    try {
      return [null, func()];
    } catch (error) {
      return [error, null];
    }
  }
  async function attemptAsync(func) {
    try {
      const result = await func();
      return [null, result];
    } catch (error) {
      return [error, null];
    }
  }
  function invariant$1(condition, message) {
    if (condition) {
      return;
    }
    if (typeof message === "string") {
      throw new Error(message);
    }
    throw message;
  }
  var defaultJavascriptAnimateProps = {
    begin: 0,
    duration: 1e3,
    easing: "ease",
    isActive: true,
    canBegin: true,
    onAnimationEnd: () => {
    },
    onAnimationStart: () => {
    }
  };
  var from = {
    t: 0
  };
  var to = {
    t: 1
  };
  function JavascriptAnimate(outsideProps) {
    var props = resolveDefaultProps(outsideProps, defaultJavascriptAnimateProps);
    var {
      isActive,
      canBegin,
      duration,
      easing,
      begin,
      onAnimationEnd,
      onAnimationStart,
      children
    } = props;
    var animationManager = useAnimationManager("JavascriptAnimate", props.animationManager);
    var [style, setStyle] = React.useState(isActive ? from : to);
    var stopJSAnimation = React.useRef(null);
    React.useEffect(() => {
      if (!isActive) {
        setStyle(to);
      }
    }, [isActive]);
    React.useEffect(() => {
      if (!isActive || !canBegin) {
        return noop$1;
      }
      var startAnimation = configUpdate(from, to, configEasing(easing), duration, setStyle, animationManager.getTimeoutController());
      var onAnimationActive = () => {
        stopJSAnimation.current = startAnimation();
      };
      animationManager.start([onAnimationStart, begin, onAnimationActive, duration, onAnimationEnd]);
      return () => {
        animationManager.stop();
        if (stopJSAnimation.current) {
          stopJSAnimation.current();
        }
        onAnimationEnd();
      };
    }, [isActive, canBegin, duration, easing, begin, onAnimationStart, onAnimationEnd, animationManager]);
    return children(style.t);
  }
  var _excluded$l = ["onMouseEnter", "onClick", "onMouseLeave"], _excluded2$a = ["id"], _excluded3$5 = ["id"];
  function _objectWithoutProperties$l(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$l(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$l(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function ownKeys$u(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$u(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$u(Object(t), true).forEach(function(r3) {
        _defineProperty$x(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$u(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$x(e, r2, t) {
    return (r2 = _toPropertyKey$x(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$x(t) {
    var i = _toPrimitive$x(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$x(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _extends$q() {
    return _extends$q = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$q.apply(null, arguments);
  }
  function SetPiePayloadLegend(props) {
    var cells = React.useMemo(() => findAllByType(props.children, Cell), [props.children]);
    var legendPayload = useAppSelector((state) => selectPieLegend(state, props.id, cells));
    if (legendPayload == null) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(SetPolarLegendPayload, {
      legendPayload
    });
  }
  function getTooltipEntrySettings$a(props) {
    var {
      dataKey,
      nameKey,
      sectors,
      stroke,
      strokeWidth,
      fill: fill2,
      name,
      hide,
      tooltipType
    } = props;
    return {
      dataDefinedOnItem: sectors === null || sectors === void 0 ? void 0 : sectors.map((p) => p.tooltipPayload),
      positions: sectors === null || sectors === void 0 ? void 0 : sectors.map((p) => p.tooltipPosition),
      settings: {
        stroke,
        strokeWidth,
        fill: fill2,
        dataKey,
        nameKey,
        name: getTooltipNameProp(name, dataKey),
        hide,
        type: tooltipType,
        color: fill2,
        unit: ""
        // why doesn't Pie support unit?
      }
    };
  }
  var getTextAnchor = (x2, cx) => {
    if (x2 > cx) {
      return "start";
    }
    if (x2 < cx) {
      return "end";
    }
    return "middle";
  };
  var getOuterRadius = (dataPoint, outerRadius, maxPieRadius) => {
    if (typeof outerRadius === "function") {
      return outerRadius(dataPoint);
    }
    return getPercentValue(outerRadius, maxPieRadius, maxPieRadius * 0.8);
  };
  var parseCoordinateOfPie = (item, offset, dataPoint) => {
    var {
      top,
      left,
      width,
      height
    } = offset;
    var maxPieRadius = getMaxRadius(width, height);
    var cx = left + getPercentValue(item.cx, width, width / 2);
    var cy = top + getPercentValue(item.cy, height, height / 2);
    var innerRadius = getPercentValue(item.innerRadius, maxPieRadius, 0);
    var outerRadius = getOuterRadius(dataPoint, item.outerRadius, maxPieRadius);
    var maxRadius = item.maxRadius || Math.sqrt(width * width + height * height) / 2;
    return {
      cx,
      cy,
      innerRadius,
      outerRadius,
      maxRadius
    };
  };
  var parseDeltaAngle = (startAngle, endAngle) => {
    var sign2 = mathSign(endAngle - startAngle);
    var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
    return sign2 * deltaAngle;
  };
  var renderLabelLineItem = (option, props) => {
    if (/* @__PURE__ */ React__namespace.isValidElement(option)) {
      return /* @__PURE__ */ React__namespace.cloneElement(option, props);
    }
    if (typeof option === "function") {
      return option(props);
    }
    var className = clsx("recharts-pie-label-line", typeof option !== "boolean" ? option.className : "");
    return /* @__PURE__ */ React__namespace.createElement(Curve, _extends$q({}, props, {
      type: "linear",
      className
    }));
  };
  var renderLabelItem = (option, props, value) => {
    if (/* @__PURE__ */ React__namespace.isValidElement(option)) {
      return /* @__PURE__ */ React__namespace.cloneElement(option, props);
    }
    var label = value;
    if (typeof option === "function") {
      label = option(props);
      if (/* @__PURE__ */ React__namespace.isValidElement(label)) {
        return label;
      }
    }
    var className = clsx("recharts-pie-label-text", typeof option !== "boolean" && typeof option !== "function" ? option.className : "");
    return /* @__PURE__ */ React__namespace.createElement(Text, _extends$q({}, props, {
      alignmentBaseline: "middle",
      className
    }), label);
  };
  function PieLabels(_ref2) {
    var {
      sectors,
      props,
      showLabels
    } = _ref2;
    var {
      label,
      labelLine,
      dataKey
    } = props;
    if (!showLabels || !label || !sectors) {
      return null;
    }
    var pieProps = svgPropertiesNoEvents(props);
    var customLabelProps = filterProps(label, false);
    var customLabelLineProps = filterProps(labelLine, false);
    var offsetRadius = typeof label === "object" && "offsetRadius" in label && label.offsetRadius || 20;
    var labels = sectors.map((entry, i) => {
      var midAngle = (entry.startAngle + entry.endAngle) / 2;
      var endPoint = polarToCartesian(entry.cx, entry.cy, entry.outerRadius + offsetRadius, midAngle);
      var labelProps = _objectSpread$u(_objectSpread$u(_objectSpread$u(_objectSpread$u({}, pieProps), entry), {}, {
        stroke: "none"
      }, customLabelProps), {}, {
        index: i,
        textAnchor: getTextAnchor(endPoint.x, entry.cx)
      }, endPoint);
      var lineProps = _objectSpread$u(_objectSpread$u(_objectSpread$u(_objectSpread$u({}, pieProps), entry), {}, {
        fill: "none",
        stroke: entry.fill
      }, customLabelLineProps), {}, {
        index: i,
        points: [polarToCartesian(entry.cx, entry.cy, entry.outerRadius, midAngle), endPoint],
        key: "line"
      });
      return (
        // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */ React__namespace.createElement(Layer, {
          key: "label-".concat(entry.startAngle, "-").concat(entry.endAngle, "-").concat(entry.midAngle, "-").concat(i)
        }, labelLine && renderLabelLineItem(labelLine, lineProps), renderLabelItem(label, labelProps, getValueByDataKey(entry, dataKey)))
      );
    });
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: "recharts-pie-labels"
    }, labels);
  }
  function PieSectors(props) {
    var {
      sectors,
      activeShape,
      inactiveShape: inactiveShapeProp,
      allOtherPieProps,
      showLabels
    } = props;
    var activeIndex = useAppSelector(selectActiveTooltipIndex);
    var {
      onMouseEnter: onMouseEnterFromProps,
      onClick: onItemClickFromProps,
      onMouseLeave: onMouseLeaveFromProps
    } = allOtherPieProps, restOfAllOtherProps = _objectWithoutProperties$l(allOtherPieProps, _excluded$l);
    var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, allOtherPieProps.dataKey);
    var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
    var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, allOtherPieProps.dataKey);
    if (sectors == null) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, sectors.map((entry, i) => {
      if ((entry === null || entry === void 0 ? void 0 : entry.startAngle) === 0 && (entry === null || entry === void 0 ? void 0 : entry.endAngle) === 0 && sectors.length !== 1) return null;
      var isSectorActive = activeShape && String(i) === activeIndex;
      var inactiveShape = activeIndex ? inactiveShapeProp : null;
      var sectorOptions = isSectorActive ? activeShape : inactiveShape;
      var sectorProps = _objectSpread$u(_objectSpread$u({}, entry), {}, {
        stroke: entry.stroke,
        tabIndex: -1,
        [DATA_ITEM_INDEX_ATTRIBUTE_NAME]: i,
        [DATA_ITEM_DATAKEY_ATTRIBUTE_NAME]: allOtherPieProps.dataKey
      });
      return /* @__PURE__ */ React__namespace.createElement(Layer, _extends$q({
        tabIndex: -1,
        className: "recharts-pie-sector"
      }, adaptEventsOfChild(restOfAllOtherProps, entry, i), {
        // @ts-expect-error the types need a bit of attention
        onMouseEnter: onMouseEnterFromContext(entry, i),
        onMouseLeave: onMouseLeaveFromContext(entry, i),
        onClick: onClickFromContext(entry, i),
        key: "sector-".concat(entry === null || entry === void 0 ? void 0 : entry.startAngle, "-").concat(entry === null || entry === void 0 ? void 0 : entry.endAngle, "-").concat(entry.midAngle, "-").concat(i)
      }), /* @__PURE__ */ React__namespace.createElement(Shape, _extends$q({
        option: sectorOptions,
        isActive: isSectorActive,
        shapeType: "sector"
      }, sectorProps)));
    }), /* @__PURE__ */ React__namespace.createElement(PieLabels, {
      sectors,
      props: allOtherPieProps,
      showLabels
    }));
  }
  function computePieSectors(_ref2) {
    var _pieSettings$paddingA;
    var {
      pieSettings,
      displayedData,
      cells,
      offset
    } = _ref2;
    var {
      cornerRadius,
      startAngle,
      endAngle,
      dataKey,
      nameKey,
      tooltipType
    } = pieSettings;
    var minAngle = Math.abs(pieSettings.minAngle);
    var deltaAngle = parseDeltaAngle(startAngle, endAngle);
    var absDeltaAngle = Math.abs(deltaAngle);
    var paddingAngle = displayedData.length <= 1 ? 0 : (_pieSettings$paddingA = pieSettings.paddingAngle) !== null && _pieSettings$paddingA !== void 0 ? _pieSettings$paddingA : 0;
    var notZeroItemCount = displayedData.filter((entry) => getValueByDataKey(entry, dataKey, 0) !== 0).length;
    var totalPaddingAngle = (absDeltaAngle >= 360 ? notZeroItemCount : notZeroItemCount - 1) * paddingAngle;
    var realTotalAngle = absDeltaAngle - notZeroItemCount * minAngle - totalPaddingAngle;
    var sum2 = displayedData.reduce((result, entry) => {
      var val = getValueByDataKey(entry, dataKey, 0);
      return result + (isNumber(val) ? val : 0);
    }, 0);
    var sectors;
    if (sum2 > 0) {
      var prev;
      sectors = displayedData.map((entry, i) => {
        var val = getValueByDataKey(entry, dataKey, 0);
        var name = getValueByDataKey(entry, nameKey, i);
        var coordinate = parseCoordinateOfPie(pieSettings, offset, entry);
        var percent = (isNumber(val) ? val : 0) / sum2;
        var tempStartAngle;
        var entryWithCellInfo = _objectSpread$u(_objectSpread$u({}, entry), cells && cells[i] && cells[i].props);
        if (i) {
          tempStartAngle = prev.endAngle + mathSign(deltaAngle) * paddingAngle * (val !== 0 ? 1 : 0);
        } else {
          tempStartAngle = startAngle;
        }
        var tempEndAngle = tempStartAngle + mathSign(deltaAngle) * ((val !== 0 ? minAngle : 0) + percent * realTotalAngle);
        var midAngle = (tempStartAngle + tempEndAngle) / 2;
        var middleRadius = (coordinate.innerRadius + coordinate.outerRadius) / 2;
        var tooltipPayload = [{
          // @ts-expect-error getValueByDataKey does not validate the output type
          name,
          // @ts-expect-error getValueByDataKey does not validate the output type
          value: val,
          payload: entryWithCellInfo,
          dataKey,
          type: tooltipType
        }];
        var tooltipPosition = polarToCartesian(coordinate.cx, coordinate.cy, middleRadius, midAngle);
        prev = _objectSpread$u(_objectSpread$u(_objectSpread$u(_objectSpread$u({}, pieSettings.presentationProps), {}, {
          percent,
          cornerRadius,
          name,
          tooltipPayload,
          midAngle,
          middleRadius,
          tooltipPosition
        }, entryWithCellInfo), coordinate), {}, {
          value: getValueByDataKey(entry, dataKey),
          startAngle: tempStartAngle,
          endAngle: tempEndAngle,
          payload: entryWithCellInfo,
          paddingAngle: mathSign(deltaAngle) * paddingAngle
        });
        return prev;
      });
    }
    return sectors;
  }
  function SectorsWithAnimation$1(_ref3) {
    var {
      props,
      previousSectorsRef
    } = _ref3;
    var {
      sectors,
      isAnimationActive,
      animationBegin,
      animationDuration,
      animationEasing,
      activeShape,
      inactiveShape,
      onAnimationStart,
      onAnimationEnd
    } = props;
    var animationId = useAnimationId$1(props, "recharts-pie-");
    var prevSectors = previousSectorsRef.current;
    var [isAnimating, setIsAnimating] = React.useState(true);
    var handleAnimationEnd = React.useCallback(() => {
      if (typeof onAnimationEnd === "function") {
        onAnimationEnd();
      }
      setIsAnimating(false);
    }, [onAnimationEnd]);
    var handleAnimationStart = React.useCallback(() => {
      if (typeof onAnimationStart === "function") {
        onAnimationStart();
      }
      setIsAnimating(true);
    }, [onAnimationStart]);
    return /* @__PURE__ */ React__namespace.createElement(JavascriptAnimate, {
      begin: animationBegin,
      duration: animationDuration,
      isActive: isAnimationActive,
      easing: animationEasing,
      onAnimationStart: handleAnimationStart,
      onAnimationEnd: handleAnimationEnd,
      key: animationId
    }, (t) => {
      var stepData = [];
      var first = sectors && sectors[0];
      var curAngle = first.startAngle;
      sectors.forEach((entry, index2) => {
        var prev = prevSectors && prevSectors[index2];
        var paddingAngle = index2 > 0 ? get$2(entry, "paddingAngle", 0) : 0;
        if (prev) {
          var angleIp = interpolateNumber$2(prev.endAngle - prev.startAngle, entry.endAngle - entry.startAngle);
          var latest2 = _objectSpread$u(_objectSpread$u({}, entry), {}, {
            startAngle: curAngle + paddingAngle,
            endAngle: curAngle + angleIp(t) + paddingAngle
          });
          stepData.push(latest2);
          curAngle = latest2.endAngle;
        } else {
          var {
            endAngle,
            startAngle
          } = entry;
          var interpolatorAngle = interpolateNumber$2(0, endAngle - startAngle);
          var deltaAngle = interpolatorAngle(t);
          var _latest = _objectSpread$u(_objectSpread$u({}, entry), {}, {
            startAngle: curAngle + paddingAngle,
            endAngle: curAngle + deltaAngle + paddingAngle
          });
          stepData.push(_latest);
          curAngle = _latest.endAngle;
        }
      });
      previousSectorsRef.current = stepData;
      return /* @__PURE__ */ React__namespace.createElement(Layer, null, /* @__PURE__ */ React__namespace.createElement(PieSectors, {
        sectors: stepData,
        activeShape,
        inactiveShape,
        allOtherPieProps: props,
        showLabels: !isAnimating
      }));
    });
  }
  function RenderSectors$1(props) {
    var {
      sectors,
      isAnimationActive,
      activeShape,
      inactiveShape
    } = props;
    var previousSectorsRef = React.useRef(null);
    var prevSectors = previousSectorsRef.current;
    if (isAnimationActive && sectors && sectors.length && (!prevSectors || prevSectors !== sectors)) {
      return /* @__PURE__ */ React__namespace.createElement(SectorsWithAnimation$1, {
        props,
        previousSectorsRef
      });
    }
    return /* @__PURE__ */ React__namespace.createElement(PieSectors, {
      sectors,
      activeShape,
      inactiveShape,
      allOtherPieProps: props,
      showLabels: true
    });
  }
  function PieWithTouchMove(props) {
    var {
      hide,
      className,
      rootTabIndex
    } = props;
    var layerClass = clsx("recharts-pie", className);
    if (hide) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      tabIndex: rootTabIndex,
      className: layerClass
    }, /* @__PURE__ */ React__namespace.createElement(RenderSectors$1, props));
  }
  var defaultPieProps = {
    animationBegin: 400,
    animationDuration: 1500,
    animationEasing: "ease",
    cx: "50%",
    cy: "50%",
    dataKey: "value",
    endAngle: 360,
    fill: "#808080",
    hide: false,
    innerRadius: 0,
    isAnimationActive: !Global.isSsr,
    labelLine: true,
    legendType: "rect",
    minAngle: 0,
    nameKey: "name",
    outerRadius: "80%",
    paddingAngle: 0,
    rootTabIndex: 0,
    startAngle: 0,
    stroke: "#fff"
  };
  function PieImpl(props) {
    var {
      id
    } = props, propsWithoutId = _objectWithoutProperties$l(props, _excluded2$a);
    var cells = React.useMemo(() => findAllByType(props.children, Cell), [props.children]);
    var sectors = useAppSelector((state) => selectPieSectors(state, id, cells));
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(SetTooltipEntrySettings, {
      fn: getTooltipEntrySettings$a,
      args: _objectSpread$u(_objectSpread$u({}, props), {}, {
        sectors
      })
    }), /* @__PURE__ */ React__namespace.createElement(PieWithTouchMove, _extends$q({}, propsWithoutId, {
      sectors
    })));
  }
  function Pie(outsideProps) {
    var _resolveDefaultProps = resolveDefaultProps(outsideProps, defaultPieProps), {
      id: externalId
    } = _resolveDefaultProps, propsWithoutId = _objectWithoutProperties$l(_resolveDefaultProps, _excluded3$5);
    var presentationProps = svgPropertiesNoEvents(propsWithoutId);
    return /* @__PURE__ */ React__namespace.createElement(RegisterGraphicalItemId, {
      id: externalId,
      type: "pie"
    }, (id) => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(SetPolarGraphicalItem, {
      type: "pie",
      id,
      data: propsWithoutId.data,
      dataKey: propsWithoutId.dataKey,
      hide: propsWithoutId.hide,
      angleAxisId: 0,
      radiusAxisId: 0,
      name: propsWithoutId.name,
      nameKey: propsWithoutId.nameKey,
      tooltipType: propsWithoutId.tooltipType,
      legendType: propsWithoutId.legendType,
      fill: propsWithoutId.fill,
      cx: propsWithoutId.cx,
      cy: propsWithoutId.cy,
      startAngle: propsWithoutId.startAngle,
      endAngle: propsWithoutId.endAngle,
      paddingAngle: propsWithoutId.paddingAngle,
      minAngle: propsWithoutId.minAngle,
      innerRadius: propsWithoutId.innerRadius,
      outerRadius: propsWithoutId.outerRadius,
      cornerRadius: propsWithoutId.cornerRadius,
      presentationProps
    }), /* @__PURE__ */ React__namespace.createElement(SetPiePayloadLegend, _extends$q({}, propsWithoutId, {
      id
    })), /* @__PURE__ */ React__namespace.createElement(PieImpl, _extends$q({}, propsWithoutId, {
      id
    })), propsWithoutId.children));
  }
  Pie.displayName = "Pie";
  var selectChartOffset = createSelector([selectChartOffsetInternal], (offsetInternal) => {
    if (!offsetInternal) {
      return void 0;
    }
    return {
      top: offsetInternal.top,
      bottom: offsetInternal.bottom,
      left: offsetInternal.left,
      right: offsetInternal.right
    };
  });
  var selectPlotArea = createSelector([selectChartOffset, selectChartWidth, selectChartHeight], (offset, chartWidth, chartHeight) => {
    if (!offset || chartWidth == null || chartHeight == null) {
      return void 0;
    }
    return {
      x: offset.left,
      y: offset.top,
      width: Math.max(0, chartWidth - offset.left - offset.right),
      height: Math.max(0, chartHeight - offset.top - offset.bottom)
    };
  });
  var useXAxis = (xAxisId) => {
    var isPanorama = useIsPanorama();
    return useAppSelector((state) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama));
  };
  var useYAxis = (yAxisId) => {
    var isPanorama = useIsPanorama();
    return useAppSelector((state) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama));
  };
  var useActiveTooltipLabel = () => {
    return useAppSelector(selectActiveLabel$1);
  };
  var useOffset = () => {
    return useAppSelector(selectChartOffset);
  };
  var usePlotArea = () => {
    return useAppSelector(selectPlotArea);
  };
  var useActiveTooltipDataPoints = () => {
    return useAppSelector(selectActiveTooltipDataPoints);
  };
  function ownKeys$t(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$t(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$t(Object(t), true).forEach(function(r3) {
        _defineProperty$w(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$t(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$w(e, r2, t) {
    return (r2 = _toPropertyKey$w(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$w(t) {
    var i = _toPrimitive$w(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$w(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var renderActivePoint = (_ref2) => {
    var {
      point: point2,
      childIndex,
      mainColor,
      activeDot,
      dataKey
    } = _ref2;
    if (activeDot === false || point2.x == null || point2.y == null) {
      return null;
    }
    var dotProps = _objectSpread$t(_objectSpread$t({
      index: childIndex,
      dataKey,
      cx: point2.x,
      cy: point2.y,
      r: 4,
      fill: mainColor !== null && mainColor !== void 0 ? mainColor : "none",
      strokeWidth: 2,
      stroke: "#fff",
      payload: point2.payload,
      value: point2.value
    }, filterProps(activeDot, false)), adaptEventHandlers(activeDot));
    var dot;
    if (/* @__PURE__ */ React.isValidElement(activeDot)) {
      dot = /* @__PURE__ */ React.cloneElement(activeDot, dotProps);
    } else if (typeof activeDot === "function") {
      dot = activeDot(dotProps);
    } else {
      dot = /* @__PURE__ */ React__namespace.createElement(Dot, dotProps);
    }
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: "recharts-active-dot"
    }, dot);
  };
  function ActivePoints(_ref2) {
    var {
      points,
      mainColor,
      activeDot,
      itemDataKey
    } = _ref2;
    var activeTooltipIndex = useAppSelector(selectActiveTooltipIndex);
    var activeDataPoints = useActiveTooltipDataPoints();
    if (points == null || activeDataPoints == null) {
      return null;
    }
    var activePoint = points.find((p) => activeDataPoints.includes(p.payload));
    if (isNullish(activePoint)) {
      return null;
    }
    return renderActivePoint({
      point: activePoint,
      childIndex: Number(activeTooltipIndex),
      mainColor,
      dataKey: itemDataKey,
      activeDot
    });
  }
  function ownKeys$s(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$s(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$s(Object(t), true).forEach(function(r3) {
        _defineProperty$v(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$s(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$v(e, r2, t) {
    return (r2 = _toPropertyKey$v(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$v(t) {
    var i = _toPrimitive$v(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$v(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var selectRadiusAxisScale = (state, radiusAxisId) => selectPolarAxisScale(state, "radiusAxis", radiusAxisId);
  var selectRadiusAxisForRadar = createSelector([selectRadiusAxisScale], (scale) => {
    if (scale == null) {
      return void 0;
    }
    return {
      scale
    };
  });
  var selectRadiusAxisForBandSize = createSelector([selectRadiusAxis, selectRadiusAxisScale], (axisSettings, scale) => {
    if (axisSettings == null || scale == null) {
      return void 0;
    }
    return _objectSpread$s(_objectSpread$s({}, axisSettings), {}, {
      scale
    });
  });
  var selectRadiusAxisTicks$1 = (state, radiusAxisId, _angleAxisId, isPanorama) => {
    return selectPolarAxisTicks(state, "radiusAxis", radiusAxisId, isPanorama);
  };
  var selectAngleAxisForRadar = (state, _radiusAxisId, angleAxisId) => selectAngleAxis(state, angleAxisId);
  var selectPolarAxisScaleForRadar = (state, _radiusAxisId, angleAxisId) => selectPolarAxisScale(state, "angleAxis", angleAxisId);
  var selectAngleAxisForBandSize = createSelector([selectAngleAxisForRadar, selectPolarAxisScaleForRadar], (axisSettings, scale) => {
    if (axisSettings == null || scale == null) {
      return void 0;
    }
    return _objectSpread$s(_objectSpread$s({}, axisSettings), {}, {
      scale
    });
  });
  var selectAngleAxisTicks$1 = (state, _radiusAxisId, angleAxisId, isPanorama) => {
    return selectPolarAxisTicks(state, "angleAxis", angleAxisId, isPanorama);
  };
  var selectAngleAxisWithScaleAndViewport = createSelector([selectAngleAxisForRadar, selectPolarAxisScaleForRadar, selectPolarViewBox], (axisOptions, scale, polarViewBox) => {
    if (polarViewBox == null || scale == null) {
      return void 0;
    }
    return {
      scale,
      type: axisOptions.type,
      dataKey: axisOptions.dataKey,
      cx: polarViewBox.cx,
      cy: polarViewBox.cy
    };
  });
  var pickDataKey = (_state, _radiusAxisId, _angleAxisId, _isPanorama, radarDataKey) => radarDataKey;
  var selectBandSizeOfAxis = createSelector([selectChartLayout, selectRadiusAxisForBandSize, selectRadiusAxisTicks$1, selectAngleAxisForBandSize, selectAngleAxisTicks$1], (layout, radiusAxis, radiusAxisTicks, angleAxis, angleAxisTicks) => {
    if (isCategoricalAxis(layout, "radiusAxis")) {
      return getBandSizeOfAxis(radiusAxis, radiusAxisTicks, false);
    }
    return getBandSizeOfAxis(angleAxis, angleAxisTicks, false);
  });
  var selectSynchronisedRadarDataKey = createSelector([selectUnfilteredPolarItems, pickDataKey], (graphicalItems, radarDataKey) => {
    if (graphicalItems.some((pgis) => pgis.type === "radar" && radarDataKey === pgis.dataKey)) {
      return radarDataKey;
    }
    return void 0;
  });
  var selectRadarPoints = createSelector([selectRadiusAxisForRadar, selectAngleAxisWithScaleAndViewport, selectChartDataAndAlwaysIgnoreIndexes, selectSynchronisedRadarDataKey, selectBandSizeOfAxis], (radiusAxis, angleAxis, _ref2, dataKey, bandSize) => {
    var {
      chartData,
      dataStartIndex,
      dataEndIndex
    } = _ref2;
    if (radiusAxis == null || angleAxis == null || chartData == null || bandSize == null || dataKey == null) {
      return void 0;
    }
    var displayedData = chartData.slice(dataStartIndex, dataEndIndex + 1);
    return computeRadarPoints({
      radiusAxis,
      angleAxis,
      displayedData,
      dataKey,
      bandSize
    });
  });
  var _excluded$k = ["id"];
  function _objectWithoutProperties$k(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$k(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$k(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function ownKeys$r(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$r(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$r(Object(t), true).forEach(function(r3) {
        _defineProperty$u(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$r(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$u(e, r2, t) {
    return (r2 = _toPropertyKey$u(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$u(t) {
    var i = _toPrimitive$u(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$u(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _extends$p() {
    return _extends$p = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$p.apply(null, arguments);
  }
  function getLegendItemColor$1(stroke, fill2) {
    return stroke && stroke !== "none" ? stroke : fill2;
  }
  var computeLegendPayloadFromRadarSectors = (props) => {
    var {
      dataKey,
      name,
      stroke,
      fill: fill2,
      legendType,
      hide
    } = props;
    return [{
      inactive: hide,
      dataKey,
      type: legendType,
      color: getLegendItemColor$1(stroke, fill2),
      value: getTooltipNameProp(name, dataKey),
      payload: props
    }];
  };
  function getTooltipEntrySettings$9(props) {
    var {
      dataKey,
      stroke,
      strokeWidth,
      fill: fill2,
      name,
      hide,
      tooltipType
    } = props;
    return {
      /*
       * I suppose this here _could_ return props.points
       * because while Radar does not support item tooltip mode, it _could_ support it.
       * But when I actually do return the points here, a defaultIndex test starts failing.
       * So, undefined it is.
       */
      dataDefinedOnItem: void 0,
      positions: void 0,
      settings: {
        stroke,
        strokeWidth,
        fill: fill2,
        nameKey: void 0,
        // RadarChart does not have nameKey unfortunately
        dataKey,
        name: getTooltipNameProp(name, dataKey),
        hide,
        type: tooltipType,
        color: getLegendItemColor$1(stroke, fill2),
        unit: ""
        // why doesn't Radar support unit?
      }
    };
  }
  function renderDotItem$2(option, props) {
    var dotItem;
    if (/* @__PURE__ */ React__namespace.isValidElement(option)) {
      dotItem = /* @__PURE__ */ React__namespace.cloneElement(option, props);
    } else if (typeof option === "function") {
      dotItem = option(props);
    } else {
      dotItem = /* @__PURE__ */ React__namespace.createElement(Dot, _extends$p({}, props, {
        className: clsx("recharts-radar-dot", typeof option !== "boolean" ? option.className : "")
      }));
    }
    return dotItem;
  }
  function computeRadarPoints(_ref2) {
    var {
      radiusAxis,
      angleAxis,
      displayedData,
      dataKey,
      bandSize
    } = _ref2;
    var {
      cx,
      cy
    } = angleAxis;
    var isRange = false;
    var points = [];
    var angleBandSize = angleAxis.type !== "number" ? bandSize !== null && bandSize !== void 0 ? bandSize : 0 : 0;
    displayedData.forEach((entry, i) => {
      var name = getValueByDataKey(entry, angleAxis.dataKey, i);
      var value = getValueByDataKey(entry, dataKey);
      var angle = angleAxis.scale(name) + angleBandSize;
      var pointValue = Array.isArray(value) ? last$2(value) : value;
      var radius = isNullish(pointValue) ? void 0 : radiusAxis.scale(pointValue);
      if (Array.isArray(value) && value.length >= 2) {
        isRange = true;
      }
      points.push(_objectSpread$r(_objectSpread$r({}, polarToCartesian(cx, cy, radius, angle)), {}, {
        // @ts-expect-error getValueByDataKey does not validate the output type
        name,
        // @ts-expect-error getValueByDataKey does not validate the output type
        value,
        cx,
        cy,
        radius,
        angle,
        payload: entry
      }));
    });
    var baseLinePoints = [];
    if (isRange) {
      points.forEach((point2) => {
        if (Array.isArray(point2.value)) {
          var baseValue = point2.value[0];
          var radius = isNullish(baseValue) ? void 0 : radiusAxis.scale(baseValue);
          baseLinePoints.push(_objectSpread$r(_objectSpread$r({}, point2), {}, {
            radius
          }, polarToCartesian(cx, cy, radius, point2.angle)));
        } else {
          baseLinePoints.push(point2);
        }
      });
    }
    return {
      points,
      isRange,
      baseLinePoints
    };
  }
  function Dots$2(_ref2) {
    var {
      points,
      props
    } = _ref2;
    var {
      dot,
      dataKey
    } = props;
    if (!dot) {
      return null;
    }
    var {
      id
    } = props, propsWithoutId = _objectWithoutProperties$k(props, _excluded$k);
    var baseProps = svgPropertiesNoEvents(propsWithoutId);
    var customDotProps = filterProps(dot, true);
    var dots = points.map((entry, i) => {
      var dotProps = _objectSpread$r(_objectSpread$r(_objectSpread$r({
        key: "dot-".concat(i),
        r: 3
      }, baseProps), customDotProps), {}, {
        dataKey,
        cx: entry.x,
        cy: entry.y,
        index: i,
        payload: entry
      });
      return renderDotItem$2(dot, dotProps);
    });
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: "recharts-radar-dots"
    }, dots);
  }
  function StaticPolygon(_ref3) {
    var {
      points,
      props,
      showLabels
    } = _ref3;
    if (points == null) {
      return null;
    }
    var {
      shape,
      isRange,
      baseLinePoints,
      connectNulls
    } = props;
    var handleMouseEnter = (e) => {
      var {
        onMouseEnter
      } = props;
      if (onMouseEnter) {
        onMouseEnter(props, e);
      }
    };
    var handleMouseLeave = (e) => {
      var {
        onMouseLeave
      } = props;
      if (onMouseLeave) {
        onMouseLeave(props, e);
      }
    };
    var radar;
    if (/* @__PURE__ */ React__namespace.isValidElement(shape)) {
      radar = /* @__PURE__ */ React__namespace.cloneElement(shape, _objectSpread$r(_objectSpread$r({}, props), {}, {
        points
      }));
    } else if (typeof shape === "function") {
      radar = shape(_objectSpread$r(_objectSpread$r({}, props), {}, {
        points
      }));
    } else {
      radar = /* @__PURE__ */ React__namespace.createElement(Polygon, _extends$p({}, filterProps(props, true), {
        onMouseEnter: handleMouseEnter,
        onMouseLeave: handleMouseLeave,
        points,
        baseLinePoints: isRange ? baseLinePoints : null,
        connectNulls
      }));
    }
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: "recharts-radar-polygon"
    }, radar, /* @__PURE__ */ React__namespace.createElement(Dots$2, {
      props,
      points
    }), showLabels && LabelList.renderCallByParent(props, points));
  }
  function PolygonWithAnimation(_ref4) {
    var {
      props,
      previousPointsRef
    } = _ref4;
    var {
      points,
      isAnimationActive,
      animationBegin,
      animationDuration,
      animationEasing,
      onAnimationEnd,
      onAnimationStart
    } = props;
    var prevPoints = previousPointsRef.current;
    var animationId = useAnimationId$1(props, "recharts-radar-");
    var [isAnimating, setIsAnimating] = React.useState(true);
    var handleAnimationEnd = React.useCallback(() => {
      if (typeof onAnimationEnd === "function") {
        onAnimationEnd();
      }
      setIsAnimating(false);
    }, [onAnimationEnd]);
    var handleAnimationStart = React.useCallback(() => {
      if (typeof onAnimationStart === "function") {
        onAnimationStart();
      }
      setIsAnimating(true);
    }, [onAnimationStart]);
    return /* @__PURE__ */ React__namespace.createElement(JavascriptAnimate, {
      begin: animationBegin,
      duration: animationDuration,
      isActive: isAnimationActive,
      easing: animationEasing,
      key: "radar-".concat(animationId),
      onAnimationEnd: handleAnimationEnd,
      onAnimationStart: handleAnimationStart
    }, (t) => {
      var prevPointsDiffFactor = prevPoints && prevPoints.length / points.length;
      var stepData = t === 1 ? points : points.map((entry, index2) => {
        var prev = prevPoints && prevPoints[Math.floor(index2 * prevPointsDiffFactor)];
        if (prev) {
          var _interpolatorX = interpolateNumber$2(prev.x, entry.x);
          var _interpolatorY = interpolateNumber$2(prev.y, entry.y);
          return _objectSpread$r(_objectSpread$r({}, entry), {}, {
            x: _interpolatorX(t),
            y: _interpolatorY(t)
          });
        }
        var interpolatorX = interpolateNumber$2(entry.cx, entry.x);
        var interpolatorY = interpolateNumber$2(entry.cy, entry.y);
        return _objectSpread$r(_objectSpread$r({}, entry), {}, {
          x: interpolatorX(t),
          y: interpolatorY(t)
        });
      });
      if (t > 0) {
        previousPointsRef.current = stepData;
      }
      return /* @__PURE__ */ React__namespace.createElement(StaticPolygon, {
        points: stepData,
        props,
        showLabels: !isAnimating
      });
    });
  }
  function RenderPolygon(props) {
    var {
      points,
      isAnimationActive,
      isRange
    } = props;
    var previousPointsRef = React.useRef(void 0);
    var prevPoints = previousPointsRef.current;
    if (isAnimationActive && points && points.length && !isRange && (!prevPoints || prevPoints !== points)) {
      return /* @__PURE__ */ React__namespace.createElement(PolygonWithAnimation, {
        props,
        previousPointsRef
      });
    }
    return /* @__PURE__ */ React__namespace.createElement(StaticPolygon, {
      points,
      props,
      showLabels: true
    });
  }
  var defaultRadarProps = {
    angleAxisId: 0,
    radiusAxisId: 0,
    hide: false,
    activeDot: true,
    dot: false,
    legendType: "rect",
    isAnimationActive: !Global.isSsr,
    animationBegin: 0,
    animationDuration: 1500,
    animationEasing: "ease"
  };
  class RadarWithState extends React.PureComponent {
    render() {
      var {
        hide,
        className,
        points
      } = this.props;
      if (hide) {
        return null;
      }
      var layerClass = clsx("recharts-radar", className);
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(Layer, {
        className: layerClass
      }, /* @__PURE__ */ React__namespace.createElement(RenderPolygon, this.props)), /* @__PURE__ */ React__namespace.createElement(ActivePoints, {
        points,
        mainColor: getLegendItemColor$1(this.props.stroke, this.props.fill),
        itemDataKey: this.props.dataKey,
        activeDot: this.props.activeDot
      }));
    }
  }
  function RadarImpl(props) {
    var isPanorama = useIsPanorama();
    var radarPoints = useAppSelector((state) => selectRadarPoints(state, props.radiusAxisId, props.angleAxisId, isPanorama, props.dataKey));
    return /* @__PURE__ */ React__namespace.createElement(RadarWithState, _extends$p({}, props, {
      points: radarPoints === null || radarPoints === void 0 ? void 0 : radarPoints.points,
      baseLinePoints: radarPoints === null || radarPoints === void 0 ? void 0 : radarPoints.baseLinePoints,
      isRange: radarPoints === null || radarPoints === void 0 ? void 0 : radarPoints.isRange
    }));
  }
  class Radar extends React.PureComponent {
    render() {
      return /* @__PURE__ */ React__namespace.createElement(RegisterGraphicalItemId, {
        id: this.props.id,
        type: "radar"
      }, (id) => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(SetPolarGraphicalItem, {
        type: "radar",
        id,
        data: void 0,
        dataKey: this.props.dataKey,
        hide: this.props.hide,
        angleAxisId: this.props.angleAxisId,
        radiusAxisId: this.props.radiusAxisId
      }), /* @__PURE__ */ React__namespace.createElement(SetPolarLegendPayload, {
        legendPayload: computeLegendPayloadFromRadarSectors(this.props)
      }), /* @__PURE__ */ React__namespace.createElement(SetTooltipEntrySettings, {
        fn: getTooltipEntrySettings$9,
        args: this.props
      }), /* @__PURE__ */ React__namespace.createElement(RadarImpl, _extends$p({}, this.props, {
        id
      }))));
    }
  }
  _defineProperty$u(Radar, "displayName", "Radar");
  _defineProperty$u(Radar, "defaultProps", defaultRadarProps);
  function _extends$o() {
    return _extends$o = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$o.apply(null, arguments);
  }
  function ownKeys$q(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$q(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$q(Object(t), true).forEach(function(r3) {
        _defineProperty$t(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$q(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$t(e, r2, t) {
    return (r2 = _toPropertyKey$t(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$t(t) {
    var i = _toPrimitive$t(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$t(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function parseCornerRadius(cornerRadius) {
    if (typeof cornerRadius === "string") {
      return parseInt(cornerRadius, 10);
    }
    return cornerRadius;
  }
  function typeGuardSectorProps(option, props) {
    var cxValue = "".concat(props.cx || option.cx);
    var cx = Number(cxValue);
    var cyValue = "".concat(props.cy || option.cy);
    var cy = Number(cyValue);
    return _objectSpread$q(_objectSpread$q(_objectSpread$q({}, props), option), {}, {
      cx,
      cy
    });
  }
  function RadialBarSector(props) {
    return /* @__PURE__ */ React__namespace.createElement(Shape, _extends$o({
      shapeType: "sector",
      propTransformer: typeGuardSectorProps
    }, props));
  }
  var isProduction = false;
  var prefix = "Invariant failed";
  function invariant(condition, message) {
    if (condition) {
      return;
    }
    if (isProduction) {
      throw new Error(prefix);
    }
    var provided = typeof message === "function" ? message() : message;
    var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
    throw new Error(value);
  }
  var _excluded$j = ["x", "y"];
  function _extends$n() {
    return _extends$n = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$n.apply(null, arguments);
  }
  function ownKeys$p(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r22) {
        return Object.getOwnPropertyDescriptor(e, r22).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$p(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$p(Object(t), true).forEach(function(r22) {
        _defineProperty$s(e, r22, t[r22]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$p(Object(t)).forEach(function(r22) {
        Object.defineProperty(e, r22, Object.getOwnPropertyDescriptor(t, r22));
      });
    }
    return e;
  }
  function _defineProperty$s(e, r2, t) {
    return (r2 = _toPropertyKey$s(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$s(t) {
    var i = _toPrimitive$s(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$s(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _objectWithoutProperties$j(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$j(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$j(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function typeguardBarRectangleProps(_ref2, props) {
    var {
      x: xProp,
      y: yProp
    } = _ref2, option = _objectWithoutProperties$j(_ref2, _excluded$j);
    var xValue = "".concat(xProp);
    var x2 = parseInt(xValue, 10);
    var yValue = "".concat(yProp);
    var y2 = parseInt(yValue, 10);
    var heightValue = "".concat(props.height || option.height);
    var height = parseInt(heightValue, 10);
    var widthValue = "".concat(props.width || option.width);
    var width = parseInt(widthValue, 10);
    return _objectSpread$p(_objectSpread$p(_objectSpread$p(_objectSpread$p(_objectSpread$p({}, props), option), x2 ? {
      x: x2
    } : {}), y2 ? {
      y: y2
    } : {}), {}, {
      height,
      width,
      name: props.name,
      radius: props.radius
    });
  }
  function BarRectangle(props) {
    return /* @__PURE__ */ React__namespace.createElement(Shape, _extends$n({
      shapeType: "rectangle",
      propTransformer: typeguardBarRectangleProps,
      activeClassName: "recharts-active-bar"
    }, props));
  }
  var minPointSizeCallback = function minPointSizeCallback2(minPointSize) {
    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return (value, index2) => {
      if (isNumber(minPointSize)) return minPointSize;
      var isValueNumberOrNil = isNumber(value) || isNullish(value);
      if (isValueNumberOrNil) {
        return minPointSize(value, index2);
      }
      !isValueNumberOrNil ? true ? invariant(false, "minPointSize callback function received a value with type of ".concat(typeof value, ". Currently only numbers or null/undefined are supported.")) : invariant(false) : void 0;
      return defaultValue;
    };
  };
  var initialState$4 = {};
  var errorBarSlice = createSlice({
    name: "errorBars",
    initialState: initialState$4,
    reducers: {
      addErrorBar: (state, action) => {
        var {
          itemId,
          errorBar
        } = action.payload;
        if (!state[itemId]) {
          state[itemId] = [];
        }
        state[itemId].push(errorBar);
      },
      removeErrorBar: (state, action) => {
        var {
          itemId,
          errorBar
        } = action.payload;
        if (state[itemId]) {
          state[itemId] = state[itemId].filter((e) => e.dataKey !== errorBar.dataKey || e.direction !== errorBar.direction);
        }
      }
    }
  });
  var {
    addErrorBar,
    removeErrorBar
  } = errorBarSlice.actions;
  var errorBarReducer = errorBarSlice.reducer;
  var _excluded$i = ["children"];
  function _objectWithoutProperties$i(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$i(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$i(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var noop = () => {
  };
  var initialContextState = {
    data: [],
    xAxisId: "xAxis-0",
    yAxisId: "yAxis-0",
    dataPointFormatter: () => ({
      x: 0,
      y: 0,
      value: 0
    }),
    errorBarOffset: 0
  };
  var ErrorBarContext = /* @__PURE__ */ React.createContext(initialContextState);
  function SetErrorBarContext(props) {
    var {
      children
    } = props, rest2 = _objectWithoutProperties$i(props, _excluded$i);
    return /* @__PURE__ */ React__namespace.createElement(ErrorBarContext.Provider, {
      value: rest2
    }, children);
  }
  var useErrorBarContext = () => React.useContext(ErrorBarContext);
  function ReportErrorBarSettings(props) {
    var dispatch = useAppDispatch();
    var graphicalItemId = useGraphicalItemId();
    React.useEffect(() => {
      if (graphicalItemId == null) {
        return noop;
      }
      var payload = {
        itemId: graphicalItemId,
        errorBar: props
      };
      dispatch(addErrorBar(payload));
      return () => {
        dispatch(removeErrorBar(payload));
      };
    }, [dispatch, graphicalItemId, props]);
    return null;
  }
  function useNeedsClip(xAxisId, yAxisId) {
    var _xAxis$allowDataOverf, _yAxis$allowDataOverf;
    var xAxis = useAppSelector((state) => selectXAxisSettings(state, xAxisId));
    var yAxis = useAppSelector((state) => selectYAxisSettings(state, yAxisId));
    var needClipX = (_xAxis$allowDataOverf = xAxis === null || xAxis === void 0 ? void 0 : xAxis.allowDataOverflow) !== null && _xAxis$allowDataOverf !== void 0 ? _xAxis$allowDataOverf : implicitXAxis.allowDataOverflow;
    var needClipY = (_yAxis$allowDataOverf = yAxis === null || yAxis === void 0 ? void 0 : yAxis.allowDataOverflow) !== null && _yAxis$allowDataOverf !== void 0 ? _yAxis$allowDataOverf : implicitYAxis.allowDataOverflow;
    var needClip = needClipX || needClipY;
    return {
      needClip,
      needClipX,
      needClipY
    };
  }
  function GraphicalItemClipPath(_ref2) {
    var {
      xAxisId,
      yAxisId,
      clipPathId
    } = _ref2;
    var plotArea = usePlotArea();
    var {
      needClipX,
      needClipY,
      needClip
    } = useNeedsClip(xAxisId, yAxisId);
    if (!needClip) {
      return null;
    }
    var {
      x: x2,
      y: y2,
      width,
      height
    } = plotArea;
    return /* @__PURE__ */ React__namespace.createElement("clipPath", {
      id: "clipPath-".concat(clipPathId)
    }, /* @__PURE__ */ React__namespace.createElement("rect", {
      x: needClipX ? x2 : x2 - width / 2,
      y: needClipY ? y2 : y2 - height / 2,
      width: needClipX ? width : width * 2,
      height: needClipY ? height : height * 2
    }));
  }
  var _excluded$h = ["onMouseEnter", "onMouseLeave", "onClick"], _excluded2$9 = ["value", "background", "tooltipPosition"], _excluded3$4 = ["id"], _excluded4$1 = ["onMouseEnter", "onClick", "onMouseLeave"];
  function _extends$m() {
    return _extends$m = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$m.apply(null, arguments);
  }
  function ownKeys$o(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$o(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$o(Object(t), true).forEach(function(r3) {
        _defineProperty$r(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$o(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$r(e, r2, t) {
    return (r2 = _toPropertyKey$r(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$r(t) {
    var i = _toPrimitive$r(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$r(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _objectWithoutProperties$h(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$h(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$h(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var computeLegendPayloadFromBarData = (props) => {
    var {
      dataKey,
      name,
      fill: fill2,
      legendType,
      hide
    } = props;
    return [{
      inactive: hide,
      dataKey,
      type: legendType,
      color: fill2,
      value: getTooltipNameProp(name, dataKey),
      payload: props
    }];
  };
  function getTooltipEntrySettings$8(props) {
    var {
      dataKey,
      stroke,
      strokeWidth,
      fill: fill2,
      name,
      hide,
      unit: unit2
    } = props;
    return {
      dataDefinedOnItem: void 0,
      positions: void 0,
      settings: {
        stroke,
        strokeWidth,
        fill: fill2,
        dataKey,
        nameKey: void 0,
        name: getTooltipNameProp(name, dataKey),
        hide,
        type: props.tooltipType,
        color: props.fill,
        unit: unit2
      }
    };
  }
  function BarBackground(props) {
    var activeIndex = useAppSelector(selectActiveTooltipIndex);
    var {
      data,
      dataKey,
      background: backgroundFromProps,
      allOtherBarProps
    } = props;
    var {
      onMouseEnter: onMouseEnterFromProps,
      onMouseLeave: onMouseLeaveFromProps,
      onClick: onItemClickFromProps
    } = allOtherBarProps, restOfAllOtherProps = _objectWithoutProperties$h(allOtherBarProps, _excluded$h);
    var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, dataKey);
    var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
    var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, dataKey);
    if (!backgroundFromProps || data == null) {
      return null;
    }
    var backgroundProps = filterProps(backgroundFromProps, false);
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, data.map((entry, i) => {
      var {
        value,
        background: backgroundFromDataEntry,
        tooltipPosition
      } = entry, rest2 = _objectWithoutProperties$h(entry, _excluded2$9);
      if (!backgroundFromDataEntry) {
        return null;
      }
      var onMouseEnter = onMouseEnterFromContext(entry, i);
      var onMouseLeave = onMouseLeaveFromContext(entry, i);
      var onClick = onClickFromContext(entry, i);
      var barRectangleProps = _objectSpread$o(_objectSpread$o(_objectSpread$o(_objectSpread$o(_objectSpread$o({
        option: backgroundFromProps,
        isActive: String(i) === activeIndex
      }, rest2), {}, {
        // @ts-expect-error BarRectangle props do not accept `fill` property.
        fill: "#eee"
      }, backgroundFromDataEntry), backgroundProps), adaptEventsOfChild(restOfAllOtherProps, entry, i)), {}, {
        onMouseEnter,
        onMouseLeave,
        onClick,
        dataKey,
        index: i,
        className: "recharts-bar-background-rectangle"
      });
      return /* @__PURE__ */ React__namespace.createElement(BarRectangle, _extends$m({
        key: "background-bar-".concat(i)
      }, barRectangleProps));
    }));
  }
  function BarRectangles(_ref2) {
    var {
      data,
      props,
      showLabels
    } = _ref2;
    var _svgPropertiesNoEvent = svgPropertiesNoEvents(props), {
      id
    } = _svgPropertiesNoEvent, baseProps = _objectWithoutProperties$h(_svgPropertiesNoEvent, _excluded3$4);
    var {
      shape,
      dataKey,
      activeBar
    } = props;
    var activeIndex = useAppSelector(selectActiveTooltipIndex);
    var activeDataKey = useAppSelector(selectActiveTooltipDataKey);
    var {
      onMouseEnter: onMouseEnterFromProps,
      onClick: onItemClickFromProps,
      onMouseLeave: onMouseLeaveFromProps
    } = props, restOfAllOtherProps = _objectWithoutProperties$h(props, _excluded4$1);
    var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, dataKey);
    var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
    var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, dataKey);
    if (!data) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, data.map((entry, i) => {
      var isActive = activeBar && String(i) === activeIndex && (activeDataKey == null || dataKey === activeDataKey);
      var option = isActive ? activeBar : shape;
      var barRectangleProps = _objectSpread$o(_objectSpread$o(_objectSpread$o({}, baseProps), entry), {}, {
        isActive,
        option,
        index: i,
        dataKey
      });
      return /* @__PURE__ */ React__namespace.createElement(Layer, _extends$m({
        className: "recharts-bar-rectangle"
      }, adaptEventsOfChild(restOfAllOtherProps, entry, i), {
        // @ts-expect-error BarRectangleItem type definition says it's missing properties, but I can see them present in debugger!
        onMouseEnter: onMouseEnterFromContext(entry, i),
        onMouseLeave: onMouseLeaveFromContext(entry, i),
        onClick: onClickFromContext(entry, i),
        key: "rectangle-".concat(entry === null || entry === void 0 ? void 0 : entry.x, "-").concat(entry === null || entry === void 0 ? void 0 : entry.y, "-").concat(entry === null || entry === void 0 ? void 0 : entry.value, "-").concat(i)
      }), /* @__PURE__ */ React__namespace.createElement(BarRectangle, barRectangleProps));
    }), showLabels && LabelList.renderCallByParent(props, data));
  }
  function RectanglesWithAnimation(_ref2) {
    var {
      props,
      previousRectanglesRef
    } = _ref2;
    var {
      data,
      layout,
      isAnimationActive,
      animationBegin,
      animationDuration,
      animationEasing,
      onAnimationEnd,
      onAnimationStart
    } = props;
    var prevData = previousRectanglesRef.current;
    var animationId = useAnimationId$1(props, "recharts-bar-");
    var [isAnimating, setIsAnimating] = React.useState(false);
    var handleAnimationEnd = React.useCallback(() => {
      if (typeof onAnimationEnd === "function") {
        onAnimationEnd();
      }
      setIsAnimating(false);
    }, [onAnimationEnd]);
    var handleAnimationStart = React.useCallback(() => {
      if (typeof onAnimationStart === "function") {
        onAnimationStart();
      }
      setIsAnimating(true);
    }, [onAnimationStart]);
    return /* @__PURE__ */ React__namespace.createElement(JavascriptAnimate, {
      begin: animationBegin,
      duration: animationDuration,
      isActive: isAnimationActive,
      easing: animationEasing,
      onAnimationEnd: handleAnimationEnd,
      onAnimationStart: handleAnimationStart,
      key: animationId
    }, (t) => {
      var stepData = t === 1 ? data : data === null || data === void 0 ? void 0 : data.map((entry, index2) => {
        var prev = prevData && prevData[index2];
        if (prev) {
          return _objectSpread$o(_objectSpread$o({}, entry), {}, {
            x: interpolate$1(prev.x, entry.x, t),
            y: interpolate$1(prev.y, entry.y, t),
            width: interpolate$1(prev.width, entry.width, t),
            height: interpolate$1(prev.height, entry.height, t)
          });
        }
        if (layout === "horizontal") {
          var h = interpolate$1(0, entry.height, t);
          return _objectSpread$o(_objectSpread$o({}, entry), {}, {
            y: entry.y + entry.height - h,
            height: h
          });
        }
        var w = interpolate$1(0, entry.width, t);
        return _objectSpread$o(_objectSpread$o({}, entry), {}, {
          width: w
        });
      });
      if (t > 0) {
        previousRectanglesRef.current = stepData !== null && stepData !== void 0 ? stepData : null;
      }
      if (stepData == null) {
        return null;
      }
      return /* @__PURE__ */ React__namespace.createElement(Layer, null, /* @__PURE__ */ React__namespace.createElement(BarRectangles, {
        props,
        data: stepData,
        showLabels: !isAnimating
      }));
    });
  }
  function RenderRectangles(props) {
    var {
      data,
      isAnimationActive
    } = props;
    var previousRectanglesRef = React.useRef(null);
    if (isAnimationActive && data && data.length && (previousRectanglesRef.current == null || previousRectanglesRef.current !== data)) {
      return /* @__PURE__ */ React__namespace.createElement(RectanglesWithAnimation, {
        previousRectanglesRef,
        props
      });
    }
    return /* @__PURE__ */ React__namespace.createElement(BarRectangles, {
      props,
      data,
      showLabels: true
    });
  }
  var defaultMinPointSize = 0;
  var errorBarDataPointFormatter$2 = (dataPoint, dataKey) => {
    var value = Array.isArray(dataPoint.value) ? dataPoint.value[1] : dataPoint.value;
    return {
      x: dataPoint.x,
      y: dataPoint.y,
      value,
      // @ts-expect-error getValueByDataKey does not validate the output type
      errorVal: getValueByDataKey(dataPoint, dataKey)
    };
  };
  class BarWithState extends React.PureComponent {
    render() {
      var {
        hide,
        data,
        dataKey,
        className,
        xAxisId,
        yAxisId,
        needClip,
        background,
        id
      } = this.props;
      if (hide) {
        return null;
      }
      var layerClass = clsx("recharts-bar", className);
      var clipPathId = id;
      return /* @__PURE__ */ React__namespace.createElement(Layer, {
        className: layerClass,
        id
      }, needClip && /* @__PURE__ */ React__namespace.createElement("defs", null, /* @__PURE__ */ React__namespace.createElement(GraphicalItemClipPath, {
        clipPathId,
        xAxisId,
        yAxisId
      })), /* @__PURE__ */ React__namespace.createElement(Layer, {
        className: "recharts-bar-rectangles",
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : void 0
      }, /* @__PURE__ */ React__namespace.createElement(BarBackground, {
        data,
        dataKey,
        background,
        allOtherBarProps: this.props
      }), /* @__PURE__ */ React__namespace.createElement(RenderRectangles, this.props)), this.props.children);
    }
  }
  var defaultBarProps = {
    activeBar: false,
    animationBegin: 0,
    animationDuration: 400,
    animationEasing: "ease",
    hide: false,
    isAnimationActive: !Global.isSsr,
    legendType: "rect",
    minPointSize: defaultMinPointSize,
    xAxisId: 0,
    yAxisId: 0
  };
  function BarImpl(props) {
    var {
      xAxisId,
      yAxisId,
      hide,
      legendType,
      minPointSize,
      activeBar,
      animationBegin,
      animationDuration,
      animationEasing,
      isAnimationActive
    } = props;
    var {
      needClip
    } = useNeedsClip(xAxisId, yAxisId);
    var layout = useChartLayout();
    var isPanorama = useIsPanorama();
    var cells = findAllByType(props.children, Cell);
    var rects = useAppSelector((state) => selectBarRectangles(state, xAxisId, yAxisId, isPanorama, props.id, cells));
    if (layout !== "vertical" && layout !== "horizontal") {
      return null;
    }
    var errorBarOffset;
    var firstDataPoint = rects === null || rects === void 0 ? void 0 : rects[0];
    if (firstDataPoint == null || firstDataPoint.height == null || firstDataPoint.width == null) {
      errorBarOffset = 0;
    } else {
      errorBarOffset = layout === "vertical" ? firstDataPoint.height / 2 : firstDataPoint.width / 2;
    }
    return /* @__PURE__ */ React__namespace.createElement(SetErrorBarContext, {
      xAxisId,
      yAxisId,
      data: rects,
      dataPointFormatter: errorBarDataPointFormatter$2,
      errorBarOffset
    }, /* @__PURE__ */ React__namespace.createElement(BarWithState, _extends$m({}, props, {
      layout,
      needClip,
      data: rects,
      xAxisId,
      yAxisId,
      hide,
      legendType,
      minPointSize,
      activeBar,
      animationBegin,
      animationDuration,
      animationEasing,
      isAnimationActive
    })));
  }
  function computeBarRectangles(_ref3) {
    var {
      layout,
      barSettings: {
        dataKey,
        minPointSize: minPointSizeProp
      },
      pos,
      bandSize,
      xAxis,
      yAxis,
      xAxisTicks,
      yAxisTicks,
      stackedData,
      displayedData,
      offset,
      cells
    } = _ref3;
    var numericAxis = layout === "horizontal" ? yAxis : xAxis;
    var stackedDomain = stackedData ? numericAxis.scale.domain() : null;
    var baseValue = getBaseValueOfBar({
      numericAxis
    });
    return displayedData.map((entry, index2) => {
      var value, x2, y2, width, height, background;
      if (stackedData) {
        value = truncateByDomain(stackedData[index2], stackedDomain);
      } else {
        value = getValueByDataKey(entry, dataKey);
        if (!Array.isArray(value)) {
          value = [baseValue, value];
        }
      }
      var minPointSize = minPointSizeCallback(minPointSizeProp, defaultMinPointSize)(value[1], index2);
      if (layout === "horizontal") {
        var _ref4;
        var [baseValueScale, currentValueScale] = [yAxis.scale(value[0]), yAxis.scale(value[1])];
        x2 = getCateCoordinateOfBar({
          axis: xAxis,
          ticks: xAxisTicks,
          bandSize,
          offset: pos.offset,
          entry,
          index: index2
        });
        y2 = (_ref4 = currentValueScale !== null && currentValueScale !== void 0 ? currentValueScale : baseValueScale) !== null && _ref4 !== void 0 ? _ref4 : void 0;
        width = pos.size;
        var computedHeight = baseValueScale - currentValueScale;
        height = isNan(computedHeight) ? 0 : computedHeight;
        background = {
          x: x2,
          y: offset.top,
          width,
          height: offset.height
        };
        if (Math.abs(minPointSize) > 0 && Math.abs(height) < Math.abs(minPointSize)) {
          var delta = mathSign(height || minPointSize) * (Math.abs(minPointSize) - Math.abs(height));
          y2 -= delta;
          height += delta;
        }
      } else {
        var [_baseValueScale, _currentValueScale] = [xAxis.scale(value[0]), xAxis.scale(value[1])];
        x2 = _baseValueScale;
        y2 = getCateCoordinateOfBar({
          axis: yAxis,
          ticks: yAxisTicks,
          bandSize,
          offset: pos.offset,
          entry,
          index: index2
        });
        width = _currentValueScale - _baseValueScale;
        height = pos.size;
        background = {
          x: offset.left,
          y: y2,
          width: offset.width,
          height
        };
        if (Math.abs(minPointSize) > 0 && Math.abs(width) < Math.abs(minPointSize)) {
          var _delta = mathSign(width || minPointSize) * (Math.abs(minPointSize) - Math.abs(width));
          width += _delta;
        }
      }
      if (x2 == null || y2 == null || width == null || height == null) {
        return null;
      }
      var barRectangleItem = _objectSpread$o(_objectSpread$o({}, entry), {}, {
        x: x2,
        y: y2,
        width,
        height,
        value: stackedData ? value : value[1],
        payload: entry,
        background,
        tooltipPosition: {
          x: x2 + width / 2,
          y: y2 + height / 2
        }
      }, cells && cells[index2] && cells[index2].props);
      return barRectangleItem;
    }).filter(Boolean);
  }
  function Bar(outsideProps) {
    var props = resolveDefaultProps(outsideProps, defaultBarProps);
    var isPanorama = useIsPanorama();
    return /* @__PURE__ */ React__namespace.createElement(RegisterGraphicalItemId, {
      id: props.id,
      type: "bar"
    }, (id) => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(SetLegendPayload, {
      legendPayload: computeLegendPayloadFromBarData(props)
    }), /* @__PURE__ */ React__namespace.createElement(SetTooltipEntrySettings, {
      fn: getTooltipEntrySettings$8,
      args: props
    }), /* @__PURE__ */ React__namespace.createElement(SetCartesianGraphicalItem, {
      type: "bar",
      id,
      data: void 0,
      xAxisId: props.xAxisId,
      yAxisId: props.yAxisId,
      zAxisId: 0,
      dataKey: props.dataKey,
      stackId: getNormalizedStackId(props.stackId),
      hide: props.hide,
      barSize: props.barSize,
      minPointSize: props.minPointSize,
      maxBarSize: props.maxBarSize,
      isPanorama
    }), /* @__PURE__ */ React__namespace.createElement(BarImpl, _extends$m({}, props, {
      id
    }))));
  }
  Bar.displayName = "Bar";
  function ownKeys$n(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r22) {
        return Object.getOwnPropertyDescriptor(e, r22).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$n(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$n(Object(t), true).forEach(function(r22) {
        _defineProperty$q(e, r22, t[r22]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$n(Object(t)).forEach(function(r22) {
        Object.defineProperty(e, r22, Object.getOwnPropertyDescriptor(t, r22));
      });
    }
    return e;
  }
  function _defineProperty$q(e, r2, t) {
    return (r2 = _toPropertyKey$q(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$q(t) {
    var i = _toPrimitive$q(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$q(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var pickXAxisId = (_state, xAxisId) => xAxisId;
  var pickYAxisId = (_state, _xAxisId, yAxisId) => yAxisId;
  var pickIsPanorama = (_state, _xAxisId, _yAxisId, isPanorama) => isPanorama;
  var pickBarId = (_state, _xAxisId, _yAxisId, _isPanorama, id) => id;
  var selectSynchronisedBarSettings = createSelector([selectUnfilteredCartesianItems, pickBarId], (graphicalItems, id) => graphicalItems.filter((item) => item.type === "bar").find((item) => item.id === id));
  var selectMaxBarSize = createSelector([selectSynchronisedBarSettings], (barSettings) => barSettings === null || barSettings === void 0 ? void 0 : barSettings.maxBarSize);
  var pickCells$2 = (_state, _xAxisId, _yAxisId, _isPanorama, _id, cells) => cells;
  var getBarSize = (globalSize, totalSize, selfSize) => {
    var barSize = selfSize !== null && selfSize !== void 0 ? selfSize : globalSize;
    if (isNullish(barSize)) {
      return void 0;
    }
    return getPercentValue(barSize, totalSize, 0);
  };
  var selectAllVisibleBars = createSelector([selectChartLayout, selectUnfilteredCartesianItems, pickXAxisId, pickYAxisId, pickIsPanorama], (layout, allItems, xAxisId, yAxisId, isPanorama) => allItems.filter((i) => {
    if (layout === "horizontal") {
      return i.xAxisId === xAxisId;
    }
    return i.yAxisId === yAxisId;
  }).filter((i) => i.isPanorama === isPanorama).filter((i) => i.hide === false).filter((i) => i.type === "bar"));
  var selectBarStackGroups = (state, xAxisId, yAxisId, isPanorama) => {
    var layout = selectChartLayout(state);
    if (layout === "horizontal") {
      return selectStackGroups$1(state, "yAxis", yAxisId, isPanorama);
    }
    return selectStackGroups$1(state, "xAxis", xAxisId, isPanorama);
  };
  var selectBarCartesianAxisSize = (state, xAxisId, yAxisId) => {
    var layout = selectChartLayout(state);
    if (layout === "horizontal") {
      return selectCartesianAxisSize(state, "xAxis", xAxisId);
    }
    return selectCartesianAxisSize(state, "yAxis", yAxisId);
  };
  var combineBarSizeList = (allBars, globalSize, totalSize) => {
    var initialValue = {};
    var stackedBars = allBars.filter(isStacked);
    var unstackedBars = allBars.filter((b) => b.stackId == null);
    var groupByStack = stackedBars.reduce((acc, bar) => {
      if (!acc[bar.stackId]) {
        acc[bar.stackId] = [];
      }
      acc[bar.stackId].push(bar);
      return acc;
    }, initialValue);
    var stackedSizeList = Object.entries(groupByStack).map((_ref2) => {
      var [stackId, bars] = _ref2;
      var dataKeys = bars.map((b) => b.dataKey);
      var barSize = getBarSize(globalSize, totalSize, bars[0].barSize);
      return {
        stackId,
        dataKeys,
        barSize
      };
    });
    var unstackedSizeList = unstackedBars.map((b) => {
      var dataKeys = [b.dataKey].filter((dk) => dk != null);
      var barSize = getBarSize(globalSize, totalSize, b.barSize);
      return {
        stackId: void 0,
        dataKeys,
        barSize
      };
    });
    return [...stackedSizeList, ...unstackedSizeList];
  };
  var selectBarSizeList = createSelector([selectAllVisibleBars, selectRootBarSize, selectBarCartesianAxisSize], combineBarSizeList);
  var selectBarBandSize = (state, xAxisId, yAxisId, isPanorama, id) => {
    var _ref2, _getBandSizeOfAxis;
    var barSettings = selectSynchronisedBarSettings(state, xAxisId, yAxisId, isPanorama, id);
    if (barSettings == null) {
      return void 0;
    }
    var layout = selectChartLayout(state);
    var globalMaxBarSize = selectRootMaxBarSize(state);
    var {
      maxBarSize: childMaxBarSize
    } = barSettings;
    var maxBarSize = isNullish(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
    var axis, ticks2;
    if (layout === "horizontal") {
      axis = selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
      ticks2 = selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
    } else {
      axis = selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
      ticks2 = selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
    }
    return (_ref2 = (_getBandSizeOfAxis = getBandSizeOfAxis(axis, ticks2, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref2 !== void 0 ? _ref2 : 0;
  };
  var selectAxisBandSize = (state, xAxisId, yAxisId, isPanorama) => {
    var layout = selectChartLayout(state);
    var axis, ticks2;
    if (layout === "horizontal") {
      axis = selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
      ticks2 = selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
    } else {
      axis = selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
      ticks2 = selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
    }
    return getBandSizeOfAxis(axis, ticks2);
  };
  function getBarPositions(barGap, barCategoryGap, bandSize, sizeList, maxBarSize) {
    var len = sizeList.length;
    if (len < 1) {
      return void 0;
    }
    var realBarGap = getPercentValue(barGap, bandSize, 0, true);
    var result;
    var initialValue = [];
    if (isWellBehavedNumber(sizeList[0].barSize)) {
      var useFull = false;
      var fullBarSize = bandSize / len;
      var sum2 = sizeList.reduce((res, entry) => res + (entry.barSize || 0), 0);
      sum2 += (len - 1) * realBarGap;
      if (sum2 >= bandSize) {
        sum2 -= (len - 1) * realBarGap;
        realBarGap = 0;
      }
      if (sum2 >= bandSize && fullBarSize > 0) {
        useFull = true;
        fullBarSize *= 0.9;
        sum2 = len * fullBarSize;
      }
      var offset = (bandSize - sum2) / 2 >> 0;
      var prev = {
        offset: offset - realBarGap,
        size: 0
      };
      result = sizeList.reduce((res, entry) => {
        var _entry$barSize;
        var newPosition = {
          stackId: entry.stackId,
          dataKeys: entry.dataKeys,
          position: {
            offset: prev.offset + prev.size + realBarGap,
            size: useFull ? fullBarSize : (_entry$barSize = entry.barSize) !== null && _entry$barSize !== void 0 ? _entry$barSize : 0
          }
        };
        var newRes = [...res, newPosition];
        prev = newRes[newRes.length - 1].position;
        return newRes;
      }, initialValue);
    } else {
      var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);
      if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {
        realBarGap = 0;
      }
      var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;
      if (originalSize > 1) {
        originalSize >>= 0;
      }
      var size = isWellBehavedNumber(maxBarSize) ? Math.min(originalSize, maxBarSize) : originalSize;
      result = sizeList.reduce((res, entry, i) => [...res, {
        stackId: entry.stackId,
        dataKeys: entry.dataKeys,
        position: {
          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,
          size
        }
      }], initialValue);
    }
    return result;
  }
  var combineAllBarPositions = (sizeList, globalMaxBarSize, barGap, barCategoryGap, barBandSize, bandSize, childMaxBarSize) => {
    var maxBarSize = isNullish(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
    var allBarPositions = getBarPositions(barGap, barCategoryGap, barBandSize !== bandSize ? barBandSize : bandSize, sizeList, maxBarSize);
    if (barBandSize !== bandSize && allBarPositions != null) {
      allBarPositions = allBarPositions.map((pos) => _objectSpread$n(_objectSpread$n({}, pos), {}, {
        position: _objectSpread$n(_objectSpread$n({}, pos.position), {}, {
          offset: pos.position.offset - barBandSize / 2
        })
      }));
    }
    return allBarPositions;
  };
  var selectAllBarPositions = createSelector([selectBarSizeList, selectRootMaxBarSize, selectBarGap, selectBarCategoryGap, selectBarBandSize, selectAxisBandSize, selectMaxBarSize], combineAllBarPositions);
  var selectXAxisWithScale$3 = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
  var selectYAxisWithScale$3 = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
  var selectXAxisTicks$3 = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
  var selectYAxisTicks$3 = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
  var selectBarPosition = createSelector([selectAllBarPositions, selectSynchronisedBarSettings], (allBarPositions, barSettings) => {
    if (allBarPositions == null || barSettings == null) {
      return void 0;
    }
    var position2 = allBarPositions.find((p) => p.stackId === barSettings.stackId && barSettings.dataKey != null && p.dataKeys.includes(barSettings.dataKey));
    if (position2 == null) {
      return void 0;
    }
    return position2.position;
  });
  var combineStackedData = (stackGroups, barSettings) => {
    var stackSeriesIdentifier = getStackSeriesIdentifier(barSettings);
    if (!stackGroups || stackSeriesIdentifier == null || barSettings == null) {
      return void 0;
    }
    var {
      stackId
    } = barSettings;
    if (stackId == null) {
      return void 0;
    }
    var stackGroup = stackGroups[stackId];
    if (!stackGroup) {
      return void 0;
    }
    var {
      stackedData
    } = stackGroup;
    if (!stackedData) {
      return void 0;
    }
    return stackedData.find((sd) => sd.key === stackSeriesIdentifier);
  };
  var selectStackedDataOfItem = createSelector([selectBarStackGroups, selectSynchronisedBarSettings], combineStackedData);
  var selectBarRectangles = createSelector([selectChartOffsetInternal, selectXAxisWithScale$3, selectYAxisWithScale$3, selectXAxisTicks$3, selectYAxisTicks$3, selectBarPosition, selectChartLayout, selectChartDataWithIndexesIfNotInPanorama, selectAxisBandSize, selectStackedDataOfItem, selectSynchronisedBarSettings, pickCells$2], (offset, xAxis, yAxis, xAxisTicks, yAxisTicks, pos, layout, _ref3, bandSize, stackedData, barSettings, cells) => {
    var {
      chartData,
      dataStartIndex,
      dataEndIndex
    } = _ref3;
    if (barSettings == null || pos == null || layout !== "horizontal" && layout !== "vertical" || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || bandSize == null) {
      return void 0;
    }
    var {
      data
    } = barSettings;
    var displayedData;
    if (data != null && data.length > 0) {
      displayedData = data;
    } else {
      displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
    }
    if (displayedData == null) {
      return void 0;
    }
    return computeBarRectangles({
      layout,
      barSettings,
      pos,
      bandSize,
      xAxis,
      yAxis,
      xAxisTicks,
      yAxisTicks,
      stackedData,
      displayedData,
      offset,
      cells
    });
  });
  function ownKeys$m(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r22) {
        return Object.getOwnPropertyDescriptor(e, r22).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$m(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$m(Object(t), true).forEach(function(r22) {
        _defineProperty$p(e, r22, t[r22]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$m(Object(t)).forEach(function(r22) {
        Object.defineProperty(e, r22, Object.getOwnPropertyDescriptor(t, r22));
      });
    }
    return e;
  }
  function _defineProperty$p(e, r2, t) {
    return (r2 = _toPropertyKey$p(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$p(t) {
    var i = _toPrimitive$p(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$p(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var selectRadiusAxisForRadialBar = (state, radiusAxisId) => selectRadiusAxis(state, radiusAxisId);
  var selectRadiusAxisScaleForRadar = (state, radiusAxisId) => selectPolarAxisScale(state, "radiusAxis", radiusAxisId);
  var selectRadiusAxisWithScale = createSelector([selectRadiusAxisForRadialBar, selectRadiusAxisScaleForRadar], (axis, scale) => {
    if (axis == null || scale == null) {
      return void 0;
    }
    return _objectSpread$m(_objectSpread$m({}, axis), {}, {
      scale
    });
  });
  var selectRadiusAxisTicks = (state, radiusAxisId, _angleAxisId, isPanorama) => {
    return selectPolarGraphicalItemAxisTicks(state, "radiusAxis", radiusAxisId, isPanorama);
  };
  var selectAngleAxisForRadialBar = (state, _radiusAxisId, angleAxisId) => selectAngleAxis(state, angleAxisId);
  var selectAngleAxisScaleForRadialBar = (state, _radiusAxisId, angleAxisId) => selectPolarAxisScale(state, "angleAxis", angleAxisId);
  var selectAngleAxisWithScale = createSelector([selectAngleAxisForRadialBar, selectAngleAxisScaleForRadialBar], (axis, scale) => {
    if (axis == null || scale == null) {
      return void 0;
    }
    return _objectSpread$m(_objectSpread$m({}, axis), {}, {
      scale
    });
  });
  var selectAngleAxisTicks = (state, _radiusAxisId, angleAxisId, isPanorama) => {
    return selectPolarAxisTicks(state, "angleAxis", angleAxisId, isPanorama);
  };
  var pickRadialBarSettings = (_state, _radiusAxisId, _angleAxisId, radialBarSettings) => radialBarSettings;
  var selectSynchronisedRadialBarSettings = createSelector([selectUnfilteredPolarItems, pickRadialBarSettings], (graphicalItems, radialBarSettingsFromProps) => {
    if (graphicalItems.some((pgis) => pgis.type === "radialBar" && radialBarSettingsFromProps.dataKey === pgis.dataKey && radialBarSettingsFromProps.stackId === pgis.stackId)) {
      return radialBarSettingsFromProps;
    }
    return void 0;
  });
  var selectBandSizeOfPolarAxis = createSelector([selectChartLayout, selectRadiusAxisWithScale, selectRadiusAxisTicks, selectAngleAxisWithScale, selectAngleAxisTicks], (layout, radiusAxis, radiusAxisTicks, angleAxis, angleAxisTicks) => {
    if (isCategoricalAxis(layout, "radiusAxis")) {
      return getBandSizeOfAxis(radiusAxis, radiusAxisTicks, false);
    }
    return getBandSizeOfAxis(angleAxis, angleAxisTicks, false);
  });
  var selectBaseValue = createSelector([selectAngleAxisWithScale, selectRadiusAxisWithScale, selectChartLayout], (angleAxis, radiusAxis, layout) => {
    var numericAxis = layout === "radial" ? angleAxis : radiusAxis;
    if (numericAxis == null || numericAxis.scale == null) {
      return void 0;
    }
    return getBaseValueOfBar({
      numericAxis
    });
  });
  var pickCells$1 = (_state, _radiusAxisId, _angleAxisId, _radialBarSettings, cells) => cells;
  var pickAngleAxisId = (_state, _radiusAxisId, angleAxisId, _radialBarSettings, _cells) => angleAxisId;
  var pickRadiusAxisId = (_state, radiusAxisId, _angleAxisId, _radialBarSettings, _cells) => radiusAxisId;
  var pickMaxBarSize = (_state, _radiusAxisId, _angleAxisId, radialBarSettings, _cells) => radialBarSettings.maxBarSize;
  var selectAllVisibleRadialBars = createSelector([selectChartLayout, selectUnfilteredPolarItems, pickAngleAxisId, pickRadiusAxisId], (layout, allItems, angleAxisId, radiusAxisId) => {
    return allItems.filter((i) => {
      if (layout === "centric") {
        return i.angleAxisId === angleAxisId;
      }
      return i.radiusAxisId === radiusAxisId;
    }).filter((i) => i.hide === false).filter((i) => i.type === "radialBar");
  });
  var selectPolarBarAxisSize = () => void 0;
  var selectPolarBarSizeList = createSelector([selectAllVisibleRadialBars, selectRootBarSize, selectPolarBarAxisSize], combineBarSizeList);
  var selectPolarBarBandSize = createSelector([selectChartLayout, selectRootMaxBarSize, selectAngleAxisWithScale, selectAngleAxisTicks, selectRadiusAxisWithScale, selectRadiusAxisTicks, pickMaxBarSize], (layout, globalMaxBarSize, angleAxis, angleAxisTicks, radiusAxis, radiusAxisTicks, childMaxBarSize) => {
    var _ref2, _getBandSizeOfAxis2;
    var maxBarSize = isNullish(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
    if (layout === "centric") {
      var _ref3, _getBandSizeOfAxis;
      return (_ref3 = (_getBandSizeOfAxis = getBandSizeOfAxis(angleAxis, angleAxisTicks, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref3 !== void 0 ? _ref3 : 0;
    }
    return (_ref2 = (_getBandSizeOfAxis2 = getBandSizeOfAxis(radiusAxis, radiusAxisTicks, true)) !== null && _getBandSizeOfAxis2 !== void 0 ? _getBandSizeOfAxis2 : maxBarSize) !== null && _ref2 !== void 0 ? _ref2 : 0;
  });
  var selectAllPolarBarPositions = createSelector([selectPolarBarSizeList, selectRootMaxBarSize, selectBarGap, selectBarCategoryGap, selectPolarBarBandSize, selectBandSizeOfPolarAxis, pickMaxBarSize], combineAllBarPositions);
  var selectPolarBarPosition = createSelector([selectAllPolarBarPositions, selectSynchronisedRadialBarSettings], (allBarPositions, barSettings) => {
    if (allBarPositions == null || barSettings == null) {
      return void 0;
    }
    var position2 = allBarPositions.find((p) => p.stackId === barSettings.stackId && barSettings.dataKey != null && p.dataKeys.includes(barSettings.dataKey));
    if (position2 == null) {
      return void 0;
    }
    return position2.position;
  });
  var selectStackedRadialBars = createSelector([selectPolarItemsSettings], (allPolarItems) => allPolarItems.filter((item) => item.type === "radialBar").filter(isStacked));
  var selectPolarCombinedStackedData = createSelector([selectStackedRadialBars, selectChartDataAndAlwaysIgnoreIndexes, selectTooltipAxis], combineDisplayedStackedData);
  var selectStackGroups = createSelector([selectPolarCombinedStackedData, selectStackedRadialBars, selectStackOffsetType], combineStackGroups);
  var selectRadialBarStackGroups = (state, radiusAxisId, angleAxisId) => {
    var layout = selectChartLayout(state);
    if (layout === "centric") {
      return selectStackGroups(state, "radiusAxis", radiusAxisId);
    }
    return selectStackGroups(state, "angleAxis", angleAxisId);
  };
  var selectPolarStackedData = createSelector([selectRadialBarStackGroups, selectSynchronisedRadialBarSettings], combineStackedData);
  var selectRadialBarSectors = createSelector([selectAngleAxisWithScale, selectAngleAxisTicks, selectRadiusAxisWithScale, selectRadiusAxisTicks, selectChartDataWithIndexes, selectSynchronisedRadialBarSettings, selectBandSizeOfPolarAxis, selectChartLayout, selectBaseValue, selectPolarViewBox, pickCells$1, selectPolarBarPosition, selectPolarStackedData], (angleAxis, angleAxisTicks, radiusAxis, radiusAxisTicks, _ref3, radialBarSettings, bandSize, layout, baseValue, polarViewBox, cells, pos, stackedData) => {
    var {
      chartData,
      dataStartIndex,
      dataEndIndex
    } = _ref3;
    if (radialBarSettings == null || radiusAxis == null || angleAxis == null || chartData == null || bandSize == null || pos == null || layout !== "centric" && layout !== "radial" || radiusAxisTicks == null) {
      return [];
    }
    var {
      dataKey,
      minPointSize
    } = radialBarSettings;
    var {
      cx,
      cy,
      startAngle,
      endAngle
    } = polarViewBox;
    var displayedData = chartData.slice(dataStartIndex, dataEndIndex + 1);
    var numericAxis = layout === "centric" ? radiusAxis : angleAxis;
    var stackedDomain = stackedData ? numericAxis.scale.domain() : null;
    return computeRadialBarDataItems({
      angleAxis,
      angleAxisTicks,
      bandSize,
      baseValue,
      cells,
      cx,
      cy,
      dataKey,
      dataStartIndex,
      displayedData,
      endAngle,
      layout,
      minPointSize,
      pos,
      radiusAxis,
      radiusAxisTicks,
      stackedData,
      stackedDomain,
      startAngle
    });
  });
  var selectRadialBarLegendPayload = createSelector([selectChartDataAndAlwaysIgnoreIndexes, (_s, l) => l], (_ref4, legendType) => {
    var {
      chartData,
      dataStartIndex,
      dataEndIndex
    } = _ref4;
    if (chartData == null) {
      return [];
    }
    var displayedData = chartData.slice(dataStartIndex, dataEndIndex + 1);
    if (displayedData.length === 0) {
      return [];
    }
    return displayedData.map((entry) => {
      return {
        type: legendType,
        // @ts-expect-error we need a better typing for our data inputs
        value: entry.name,
        // @ts-expect-error we need a better typing for our data inputs
        color: entry.fill,
        payload: entry
      };
    });
  });
  var _excluded$g = ["shape", "activeShape", "cornerRadius", "id"], _excluded2$8 = ["onMouseEnter", "onClick", "onMouseLeave"], _excluded3$3 = ["value", "background"];
  function _extends$l() {
    return _extends$l = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$l.apply(null, arguments);
  }
  function ownKeys$l(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$l(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$l(Object(t), true).forEach(function(r3) {
        _defineProperty$o(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$l(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$o(e, r2, t) {
    return (r2 = _toPropertyKey$o(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$o(t) {
    var i = _toPrimitive$o(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$o(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _objectWithoutProperties$g(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$g(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$g(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var STABLE_EMPTY_ARRAY = [];
  function RadialBarSectors(_ref2) {
    var {
      sectors,
      allOtherRadialBarProps,
      showLabels
    } = _ref2;
    var {
      shape,
      activeShape,
      cornerRadius,
      id
    } = allOtherRadialBarProps, others = _objectWithoutProperties$g(allOtherRadialBarProps, _excluded$g);
    var baseProps = svgPropertiesNoEvents(others);
    var activeIndex = useAppSelector(selectActiveTooltipIndex);
    var {
      onMouseEnter: onMouseEnterFromProps,
      onClick: onItemClickFromProps,
      onMouseLeave: onMouseLeaveFromProps
    } = allOtherRadialBarProps, restOfAllOtherProps = _objectWithoutProperties$g(allOtherRadialBarProps, _excluded2$8);
    var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, allOtherRadialBarProps.dataKey);
    var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
    var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, allOtherRadialBarProps.dataKey);
    if (sectors == null) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, sectors.map((entry, i) => {
      var isActive = activeShape && activeIndex === String(i);
      var onMouseEnter = onMouseEnterFromContext(entry, i);
      var onMouseLeave = onMouseLeaveFromContext(entry, i);
      var onClick = onClickFromContext(entry, i);
      var radialBarSectorProps = _objectSpread$l(_objectSpread$l(_objectSpread$l(_objectSpread$l({}, baseProps), {}, {
        cornerRadius: parseCornerRadius(cornerRadius)
      }, entry), adaptEventsOfChild(restOfAllOtherProps, entry, i)), {}, {
        onMouseEnter,
        onMouseLeave,
        onClick,
        key: "sector-".concat(i),
        className: "recharts-radial-bar-sector ".concat(entry.className),
        forceCornerRadius: others.forceCornerRadius,
        cornerIsExternal: others.cornerIsExternal,
        isActive,
        option: isActive ? activeShape : shape
      });
      return /* @__PURE__ */ React__namespace.createElement(RadialBarSector, radialBarSectorProps);
    }), showLabels && LabelList.renderCallByParent(allOtherRadialBarProps, sectors));
  }
  function SectorsWithAnimation(_ref2) {
    var {
      props,
      previousSectorsRef
    } = _ref2;
    var {
      data,
      isAnimationActive,
      animationBegin,
      animationDuration,
      animationEasing,
      onAnimationEnd,
      onAnimationStart
    } = props;
    var animationId = useAnimationId$1(props, "recharts-radialbar-");
    var prevData = previousSectorsRef.current;
    var [isAnimating, setIsAnimating] = React.useState(true);
    var handleAnimationEnd = React.useCallback(() => {
      if (typeof onAnimationEnd === "function") {
        onAnimationEnd();
      }
      setIsAnimating(false);
    }, [onAnimationEnd]);
    var handleAnimationStart = React.useCallback(() => {
      if (typeof onAnimationStart === "function") {
        onAnimationStart();
      }
      setIsAnimating(true);
    }, [onAnimationStart]);
    return /* @__PURE__ */ React__namespace.createElement(JavascriptAnimate, {
      begin: animationBegin,
      duration: animationDuration,
      isActive: isAnimationActive,
      easing: animationEasing,
      onAnimationStart: handleAnimationStart,
      onAnimationEnd: handleAnimationEnd,
      key: animationId
    }, (t) => {
      var stepData = t === 1 ? data : (data !== null && data !== void 0 ? data : STABLE_EMPTY_ARRAY).map((entry, index2) => {
        var prev = prevData && prevData[index2];
        if (prev) {
          var interpolatorStartAngle = interpolateNumber$2(prev.startAngle, entry.startAngle);
          var interpolatorEndAngle = interpolateNumber$2(prev.endAngle, entry.endAngle);
          return _objectSpread$l(_objectSpread$l({}, entry), {}, {
            startAngle: interpolatorStartAngle(t),
            endAngle: interpolatorEndAngle(t)
          });
        }
        var {
          endAngle,
          startAngle
        } = entry;
        var interpolator = interpolateNumber$2(startAngle, endAngle);
        return _objectSpread$l(_objectSpread$l({}, entry), {}, {
          endAngle: interpolator(t)
        });
      });
      if (t > 0) {
        previousSectorsRef.current = stepData !== null && stepData !== void 0 ? stepData : null;
      }
      return /* @__PURE__ */ React__namespace.createElement(Layer, null, /* @__PURE__ */ React__namespace.createElement(RadialBarSectors, {
        sectors: stepData !== null && stepData !== void 0 ? stepData : STABLE_EMPTY_ARRAY,
        allOtherRadialBarProps: props,
        showLabels: !isAnimating
      }));
    });
  }
  function RenderSectors(props) {
    var {
      data = [],
      isAnimationActive
    } = props;
    var previousSectorsRef = React.useRef(null);
    var prevData = previousSectorsRef.current;
    if (isAnimationActive && data && data.length && (!prevData || prevData !== data)) {
      return /* @__PURE__ */ React__namespace.createElement(SectorsWithAnimation, {
        props,
        previousSectorsRef
      });
    }
    return /* @__PURE__ */ React__namespace.createElement(RadialBarSectors, {
      sectors: data,
      allOtherRadialBarProps: props,
      showLabels: true
    });
  }
  function SetRadialBarPayloadLegend(props) {
    var legendPayload = useAppSelector((state) => selectRadialBarLegendPayload(state, props.legendType));
    return /* @__PURE__ */ React__namespace.createElement(SetPolarLegendPayload, {
      legendPayload: legendPayload !== null && legendPayload !== void 0 ? legendPayload : []
    });
  }
  function getTooltipEntrySettings$7(props) {
    var {
      dataKey,
      data,
      stroke,
      strokeWidth,
      name,
      hide,
      fill: fill2,
      tooltipType
    } = props;
    return {
      dataDefinedOnItem: data,
      positions: void 0,
      settings: {
        stroke,
        strokeWidth,
        fill: fill2,
        nameKey: void 0,
        // RadialBar does not have nameKey, why?
        dataKey,
        name: getTooltipNameProp(name, dataKey),
        hide,
        type: tooltipType,
        color: fill2,
        unit: ""
        // Why does RadialBar not support unit?
      }
    };
  }
  class RadialBarWithState extends React.PureComponent {
    renderBackground(sectors) {
      if (sectors == null) {
        return null;
      }
      var {
        cornerRadius
      } = this.props;
      var backgroundProps = filterProps(this.props.background, false);
      return sectors.map((entry, i) => {
        var {
          value,
          background
        } = entry, rest2 = _objectWithoutProperties$g(entry, _excluded3$3);
        if (!background) {
          return null;
        }
        var props = _objectSpread$l(_objectSpread$l(_objectSpread$l(_objectSpread$l(_objectSpread$l({
          cornerRadius: parseCornerRadius(cornerRadius)
        }, rest2), {}, {
          fill: "#eee"
        }, background), backgroundProps), adaptEventsOfChild(this.props, entry, i)), {}, {
          index: i,
          key: "sector-".concat(i),
          className: clsx("recharts-radial-bar-background-sector", backgroundProps === null || backgroundProps === void 0 ? void 0 : backgroundProps.className),
          option: background,
          isActive: false
        });
        return /* @__PURE__ */ React__namespace.createElement(RadialBarSector, props);
      });
    }
    render() {
      var {
        hide,
        data,
        className,
        background
      } = this.props;
      if (hide) {
        return null;
      }
      var layerClass = clsx("recharts-area", className);
      return /* @__PURE__ */ React__namespace.createElement(Layer, {
        className: layerClass
      }, background && /* @__PURE__ */ React__namespace.createElement(Layer, {
        className: "recharts-radial-bar-background"
      }, this.renderBackground(data)), /* @__PURE__ */ React__namespace.createElement(Layer, {
        className: "recharts-radial-bar-sectors"
      }, /* @__PURE__ */ React__namespace.createElement(RenderSectors, this.props)));
    }
  }
  function RadialBarImpl(props) {
    var _useAppSelector;
    var cells = findAllByType(props.children, Cell);
    var radialBarSettings = {
      data: void 0,
      hide: false,
      id: props.id,
      dataKey: props.dataKey,
      minPointSize: props.minPointSize,
      stackId: getNormalizedStackId(props.stackId),
      maxBarSize: props.maxBarSize,
      barSize: props.barSize,
      type: "radialBar",
      angleAxisId: props.angleAxisId,
      radiusAxisId: props.radiusAxisId
    };
    var data = (_useAppSelector = useAppSelector((state) => selectRadialBarSectors(state, props.radiusAxisId, props.angleAxisId, radialBarSettings, cells))) !== null && _useAppSelector !== void 0 ? _useAppSelector : STABLE_EMPTY_ARRAY;
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(SetTooltipEntrySettings, {
      fn: getTooltipEntrySettings$7,
      args: _objectSpread$l(_objectSpread$l({}, props), {}, {
        data
      })
    }), /* @__PURE__ */ React__namespace.createElement(RadialBarWithState, _extends$l({}, props, {
      data
    })));
  }
  var defaultRadialBarProps = {
    angleAxisId: 0,
    radiusAxisId: 0,
    minPointSize: 0,
    hide: false,
    legendType: "rect",
    data: [],
    isAnimationActive: !Global.isSsr,
    animationBegin: 0,
    animationDuration: 1500,
    animationEasing: "ease",
    forceCornerRadius: false,
    cornerIsExternal: false
  };
  function computeRadialBarDataItems(_ref3) {
    var {
      displayedData,
      stackedData,
      dataStartIndex,
      stackedDomain,
      dataKey,
      baseValue,
      layout,
      radiusAxis,
      radiusAxisTicks,
      bandSize,
      pos,
      angleAxis,
      minPointSize,
      cx,
      cy,
      angleAxisTicks,
      cells,
      startAngle: rootStartAngle,
      endAngle: rootEndAngle
    } = _ref3;
    return (displayedData !== null && displayedData !== void 0 ? displayedData : []).map((entry, index2) => {
      var value, innerRadius, outerRadius, startAngle, endAngle, backgroundSector;
      if (stackedData) {
        value = truncateByDomain(stackedData[dataStartIndex + index2], stackedDomain);
      } else {
        value = getValueByDataKey(entry, dataKey);
        if (!Array.isArray(value)) {
          value = [baseValue, value];
        }
      }
      if (layout === "radial") {
        innerRadius = getCateCoordinateOfBar({
          axis: radiusAxis,
          ticks: radiusAxisTicks,
          bandSize,
          offset: pos.offset,
          entry,
          index: index2
        });
        endAngle = angleAxis.scale(value[1]);
        startAngle = angleAxis.scale(value[0]);
        outerRadius = (innerRadius !== null && innerRadius !== void 0 ? innerRadius : 0) + pos.size;
        var deltaAngle = endAngle - startAngle;
        if (Math.abs(minPointSize) > 0 && Math.abs(deltaAngle) < Math.abs(minPointSize)) {
          var delta = mathSign(deltaAngle || minPointSize) * (Math.abs(minPointSize) - Math.abs(deltaAngle));
          endAngle += delta;
        }
        backgroundSector = {
          background: {
            cx,
            cy,
            innerRadius,
            outerRadius,
            startAngle: rootStartAngle,
            endAngle: rootEndAngle
          }
        };
      } else {
        innerRadius = radiusAxis.scale(value[0]);
        outerRadius = radiusAxis.scale(value[1]);
        startAngle = getCateCoordinateOfBar({
          axis: angleAxis,
          ticks: angleAxisTicks,
          bandSize,
          offset: pos.offset,
          entry,
          index: index2
        });
        endAngle = (startAngle !== null && startAngle !== void 0 ? startAngle : 0) + pos.size;
        var deltaRadius = outerRadius - innerRadius;
        if (Math.abs(minPointSize) > 0 && Math.abs(deltaRadius) < Math.abs(minPointSize)) {
          var _delta = mathSign(deltaRadius || minPointSize) * (Math.abs(minPointSize) - Math.abs(deltaRadius));
          outerRadius += _delta;
        }
      }
      return _objectSpread$l(_objectSpread$l(_objectSpread$l({}, entry), backgroundSector), {}, {
        payload: entry,
        value: stackedData ? value : value[1],
        cx,
        cy,
        innerRadius,
        outerRadius,
        startAngle,
        endAngle
      }, cells && cells[index2] && cells[index2].props);
    });
  }
  class RadialBar extends React.PureComponent {
    render() {
      return /* @__PURE__ */ React__namespace.createElement(RegisterGraphicalItemId, {
        id: this.props.id,
        type: "radialBar"
      }, (id) => {
        var _this$props$hide, _this$props$angleAxis, _this$props$radiusAxi;
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(SetPolarGraphicalItem, {
          type: "radialBar",
          id,
          data: void 0,
          dataKey: this.props.dataKey,
          hide: (_this$props$hide = this.props.hide) !== null && _this$props$hide !== void 0 ? _this$props$hide : defaultRadialBarProps.hide,
          angleAxisId: (_this$props$angleAxis = this.props.angleAxisId) !== null && _this$props$angleAxis !== void 0 ? _this$props$angleAxis : defaultRadialBarProps.angleAxisId,
          radiusAxisId: (_this$props$radiusAxi = this.props.radiusAxisId) !== null && _this$props$radiusAxi !== void 0 ? _this$props$radiusAxi : defaultRadialBarProps.radiusAxisId,
          stackId: getNormalizedStackId(this.props.stackId),
          barSize: this.props.barSize,
          minPointSize: this.props.minPointSize,
          maxBarSize: this.props.maxBarSize
        }), /* @__PURE__ */ React__namespace.createElement(SetRadialBarPayloadLegend, this.props), /* @__PURE__ */ React__namespace.createElement(RadialBarImpl, _extends$l({}, this.props, {
          id
        })));
      });
    }
  }
  _defineProperty$o(RadialBar, "displayName", "RadialBar");
  _defineProperty$o(RadialBar, "defaultProps", defaultRadialBarProps);
  function ownKeys$k(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$k(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$k(Object(t), true).forEach(function(r3) {
        _defineProperty$n(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$k(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$n(e, r2, t) {
    return (r2 = _toPropertyKey$n(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$n(t) {
    var i = _toPrimitive$n(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$n(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var PREFIX_LIST = ["Webkit", "Moz", "O", "ms"];
  var generatePrefixStyle = (name, value) => {
    if (!name) {
      return void 0;
    }
    var camelName = name.replace(/(\w)/, (v) => v.toUpperCase());
    var result = PREFIX_LIST.reduce((res, entry) => _objectSpread$k(_objectSpread$k({}, res), {}, {
      [entry + camelName]: value
    }), {});
    result[name] = value;
    return result;
  };
  var ChartDataContextProvider = (props) => {
    var {
      chartData
    } = props;
    var dispatch = useAppDispatch();
    var isPanorama = useIsPanorama();
    React.useEffect(() => {
      if (isPanorama) {
        return () => {
        };
      }
      dispatch(setChartData(chartData));
      return () => {
        dispatch(setChartData(void 0));
      };
    }, [chartData, dispatch, isPanorama]);
    return null;
  };
  var SetComputedData = (props) => {
    var {
      computedData
    } = props;
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(setComputedData(computedData));
      return () => {
        dispatch(setChartData(void 0));
      };
    }, [computedData, dispatch]);
    return null;
  };
  var selectChartData = (state) => state.chartData.chartData;
  var useChartData = () => useAppSelector(selectChartData);
  var selectDataIndex = (state) => {
    var {
      dataStartIndex,
      dataEndIndex
    } = state.chartData;
    return {
      startIndex: dataStartIndex,
      endIndex: dataEndIndex
    };
  };
  var useDataIndex = () => {
    return useAppSelector(selectDataIndex);
  };
  var BrushUpdateDispatchContext = /* @__PURE__ */ React.createContext(() => {
  });
  var initialState$3 = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  };
  var brushSlice = createSlice({
    name: "brush",
    initialState: initialState$3,
    reducers: {
      setBrushSettings(_state, action) {
        if (action.payload == null) {
          return initialState$3;
        }
        return action.payload;
      }
    }
  });
  var {
    setBrushSettings
  } = brushSlice.actions;
  var brushReducer = brushSlice.reducer;
  function _extends$k() {
    return _extends$k = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$k.apply(null, arguments);
  }
  function ownKeys$j(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$j(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$j(Object(t), true).forEach(function(r3) {
        _defineProperty$m(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$j(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$m(e, r2, t) {
    return (r2 = _toPropertyKey$m(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$m(t) {
    var i = _toPrimitive$m(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$m(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function DefaultTraveller(props) {
    var {
      x: x2,
      y: y2,
      width,
      height,
      stroke
    } = props;
    var lineY = Math.floor(y2 + height / 2) - 1;
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("rect", {
      x: x2,
      y: y2,
      width,
      height,
      fill: stroke,
      stroke: "none"
    }), /* @__PURE__ */ React__namespace.createElement("line", {
      x1: x2 + 1,
      y1: lineY,
      x2: x2 + width - 1,
      y2: lineY,
      fill: "none",
      stroke: "#fff"
    }), /* @__PURE__ */ React__namespace.createElement("line", {
      x1: x2 + 1,
      y1: lineY + 2,
      x2: x2 + width - 1,
      y2: lineY + 2,
      fill: "none",
      stroke: "#fff"
    }));
  }
  function Traveller(props) {
    var {
      travellerProps,
      travellerType
    } = props;
    if (/* @__PURE__ */ React__namespace.isValidElement(travellerType)) {
      return /* @__PURE__ */ React__namespace.cloneElement(travellerType, travellerProps);
    }
    if (typeof travellerType === "function") {
      return travellerType(travellerProps);
    }
    return /* @__PURE__ */ React__namespace.createElement(DefaultTraveller, travellerProps);
  }
  function TravellerLayer(_ref2) {
    var _data$startIndex, _data$endIndex;
    var {
      otherProps,
      travellerX,
      id,
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onTouchStart,
      onTravellerMoveKeyboard,
      onFocus,
      onBlur
    } = _ref2;
    var {
      y: y2,
      x: xFromProps,
      travellerWidth,
      height,
      traveller,
      ariaLabel,
      data,
      startIndex,
      endIndex
    } = otherProps;
    var x2 = Math.max(travellerX, xFromProps);
    var travellerProps = _objectSpread$j(_objectSpread$j({}, svgPropertiesNoEvents(otherProps)), {}, {
      x: x2,
      y: y2,
      width: travellerWidth,
      height
    });
    var ariaLabelBrush = ariaLabel || "Min value: ".concat((_data$startIndex = data[startIndex]) === null || _data$startIndex === void 0 ? void 0 : _data$startIndex.name, ", Max value: ").concat((_data$endIndex = data[endIndex]) === null || _data$endIndex === void 0 ? void 0 : _data$endIndex.name);
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      tabIndex: 0,
      role: "slider",
      "aria-label": ariaLabelBrush,
      "aria-valuenow": travellerX,
      className: "recharts-brush-traveller",
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onTouchStart,
      onKeyDown: (e) => {
        if (!["ArrowLeft", "ArrowRight"].includes(e.key)) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();
        onTravellerMoveKeyboard(e.key === "ArrowRight" ? 1 : -1, id);
      },
      onFocus,
      onBlur,
      style: {
        cursor: "col-resize"
      }
    }, /* @__PURE__ */ React__namespace.createElement(Traveller, {
      travellerType: traveller,
      travellerProps
    }));
  }
  function getTextOfTick(props) {
    var {
      index: index2,
      data,
      tickFormatter,
      dataKey
    } = props;
    var text = getValueByDataKey(data[index2], dataKey, index2);
    return typeof tickFormatter === "function" ? tickFormatter(text, index2) : text;
  }
  function getIndexInRange(valueRange, x2) {
    var len = valueRange.length;
    var start = 0;
    var end = len - 1;
    while (end - start > 1) {
      var middle = Math.floor((start + end) / 2);
      if (valueRange[middle] > x2) {
        end = middle;
      } else {
        start = middle;
      }
    }
    return x2 >= valueRange[end] ? end : start;
  }
  function getIndex(_ref2) {
    var {
      startX,
      endX,
      scaleValues,
      gap,
      data
    } = _ref2;
    var lastIndex = data.length - 1;
    var min2 = Math.min(startX, endX);
    var max2 = Math.max(startX, endX);
    var minIndex2 = getIndexInRange(scaleValues, min2);
    var maxIndex2 = getIndexInRange(scaleValues, max2);
    return {
      startIndex: minIndex2 - minIndex2 % gap,
      endIndex: maxIndex2 === lastIndex ? lastIndex : maxIndex2 - maxIndex2 % gap
    };
  }
  function Background$1(_ref3) {
    var {
      x: x2,
      y: y2,
      width,
      height,
      fill: fill2,
      stroke
    } = _ref3;
    return /* @__PURE__ */ React__namespace.createElement("rect", {
      stroke,
      fill: fill2,
      x: x2,
      y: y2,
      width,
      height
    });
  }
  function BrushText(_ref4) {
    var {
      startIndex,
      endIndex,
      y: y2,
      height,
      travellerWidth,
      stroke,
      tickFormatter,
      dataKey,
      data,
      startX,
      endX
    } = _ref4;
    var offset = 5;
    var attrs = {
      pointerEvents: "none",
      fill: stroke
    };
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: "recharts-brush-texts"
    }, /* @__PURE__ */ React__namespace.createElement(Text, _extends$k({
      textAnchor: "end",
      verticalAnchor: "middle",
      x: Math.min(startX, endX) - offset,
      y: y2 + height / 2
    }, attrs), getTextOfTick({
      index: startIndex,
      tickFormatter,
      dataKey,
      data
    })), /* @__PURE__ */ React__namespace.createElement(Text, _extends$k({
      textAnchor: "start",
      verticalAnchor: "middle",
      x: Math.max(startX, endX) + travellerWidth + offset,
      y: y2 + height / 2
    }, attrs), getTextOfTick({
      index: endIndex,
      tickFormatter,
      dataKey,
      data
    })));
  }
  function Slide(_ref5) {
    var {
      y: y2,
      height,
      stroke,
      travellerWidth,
      startX,
      endX,
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onTouchStart
    } = _ref5;
    var x2 = Math.min(startX, endX) + travellerWidth;
    var width = Math.max(Math.abs(endX - startX) - travellerWidth, 0);
    return /* @__PURE__ */ React__namespace.createElement("rect", {
      className: "recharts-brush-slide",
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onTouchStart,
      style: {
        cursor: "move"
      },
      stroke: "none",
      fill: stroke,
      fillOpacity: 0.2,
      x: x2,
      y: y2,
      width,
      height
    });
  }
  function Panorama(_ref6) {
    var {
      x: x2,
      y: y2,
      width,
      height,
      data,
      children,
      padding
    } = _ref6;
    var isPanoramic = React__namespace.Children.count(children) === 1;
    if (!isPanoramic) {
      return null;
    }
    var chartElement = React.Children.only(children);
    if (!chartElement) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.cloneElement(chartElement, {
      x: x2,
      y: y2,
      width,
      height,
      margin: padding,
      compact: true,
      data
    });
  }
  var createScale = (_ref7) => {
    var {
      data,
      startIndex,
      endIndex,
      x: x2,
      width,
      travellerWidth
    } = _ref7;
    if (!data || !data.length) {
      return {};
    }
    var len = data.length;
    var scale = point().domain(range$4(0, len)).range([x2, x2 + width - travellerWidth]);
    var scaleValues = scale.domain().map((entry) => scale(entry));
    return {
      isTextActive: false,
      isSlideMoving: false,
      isTravellerMoving: false,
      isTravellerFocused: false,
      startX: scale(startIndex),
      endX: scale(endIndex),
      scale,
      scaleValues
    };
  };
  var isTouch = (e) => e.changedTouches && !!e.changedTouches.length;
  class BrushWithState extends React.PureComponent {
    constructor(props) {
      super(props);
      _defineProperty$m(this, "handleDrag", (e) => {
        if (this.leaveTimer) {
          clearTimeout(this.leaveTimer);
          this.leaveTimer = null;
        }
        if (this.state.isTravellerMoving) {
          this.handleTravellerMove(e);
        } else if (this.state.isSlideMoving) {
          this.handleSlideDrag(e);
        }
      });
      _defineProperty$m(this, "handleTouchMove", (e) => {
        if (e.changedTouches != null && e.changedTouches.length > 0) {
          this.handleDrag(e.changedTouches[0]);
        }
      });
      _defineProperty$m(this, "handleDragEnd", () => {
        this.setState({
          isTravellerMoving: false,
          isSlideMoving: false
        }, () => {
          var {
            endIndex,
            onDragEnd,
            startIndex
          } = this.props;
          onDragEnd === null || onDragEnd === void 0 || onDragEnd({
            endIndex,
            startIndex
          });
        });
        this.detachDragEndListener();
      });
      _defineProperty$m(this, "handleLeaveWrapper", () => {
        if (this.state.isTravellerMoving || this.state.isSlideMoving) {
          this.leaveTimer = window.setTimeout(this.handleDragEnd, this.props.leaveTimeOut);
        }
      });
      _defineProperty$m(this, "handleEnterSlideOrTraveller", () => {
        this.setState({
          isTextActive: true
        });
      });
      _defineProperty$m(this, "handleLeaveSlideOrTraveller", () => {
        this.setState({
          isTextActive: false
        });
      });
      _defineProperty$m(this, "handleSlideDragStart", (e) => {
        var event = isTouch(e) ? e.changedTouches[0] : e;
        this.setState({
          isTravellerMoving: false,
          isSlideMoving: true,
          slideMoveStartX: event.pageX
        });
        this.attachDragEndListener();
      });
      _defineProperty$m(this, "handleTravellerMoveKeyboard", (direction, id) => {
        var {
          data,
          gap
        } = this.props;
        var {
          scaleValues,
          startX,
          endX
        } = this.state;
        if (scaleValues == null) {
          return;
        }
        var currentScaleValue = this.state[id];
        var currentIndex = scaleValues.indexOf(currentScaleValue);
        if (currentIndex === -1) {
          return;
        }
        var newIndex = currentIndex + direction;
        if (newIndex === -1 || newIndex >= scaleValues.length) {
          return;
        }
        var newScaleValue = scaleValues[newIndex];
        if (id === "startX" && newScaleValue >= endX || id === "endX" && newScaleValue <= startX) {
          return;
        }
        this.setState(
          // @ts-expect-error not sure why typescript is not happy with this, partial update is fine in React
          {
            [id]: newScaleValue
          },
          () => {
            this.props.onChange(getIndex({
              startX: this.state.startX,
              endX: this.state.endX,
              data,
              gap,
              scaleValues
            }));
          }
        );
      });
      this.travellerDragStartHandlers = {
        startX: this.handleTravellerDragStart.bind(this, "startX"),
        endX: this.handleTravellerDragStart.bind(this, "endX")
      };
      this.state = {
        brushMoveStartX: 0,
        movingTravellerId: void 0,
        endX: 0,
        startX: 0,
        slideMoveStartX: 0
      };
    }
    static getDerivedStateFromProps(nextProps, prevState) {
      var {
        data,
        width,
        x: x2,
        travellerWidth,
        startIndex,
        endIndex,
        startIndexControlledFromProps,
        endIndexControlledFromProps
      } = nextProps;
      if (data !== prevState.prevData) {
        return _objectSpread$j({
          prevData: data,
          prevTravellerWidth: travellerWidth,
          prevX: x2,
          prevWidth: width
        }, data && data.length ? createScale({
          data,
          width,
          x: x2,
          travellerWidth,
          startIndex,
          endIndex
        }) : {
          scale: void 0,
          scaleValues: void 0
        });
      }
      var prevScale = prevState.scale;
      if (prevScale && (width !== prevState.prevWidth || x2 !== prevState.prevX || travellerWidth !== prevState.prevTravellerWidth)) {
        prevScale.range([x2, x2 + width - travellerWidth]);
        var scaleValues = prevScale.domain().map((entry) => prevScale(entry)).filter(Boolean);
        return {
          prevData: data,
          prevTravellerWidth: travellerWidth,
          prevX: x2,
          prevWidth: width,
          startX: prevScale(nextProps.startIndex),
          endX: prevScale(nextProps.endIndex),
          scaleValues
        };
      }
      if (prevState.scale && !prevState.isSlideMoving && !prevState.isTravellerMoving && !prevState.isTravellerFocused && !prevState.isTextActive) {
        if (startIndexControlledFromProps != null && prevState.prevStartIndexControlledFromProps !== startIndexControlledFromProps) {
          return {
            startX: prevState.scale(startIndexControlledFromProps),
            prevStartIndexControlledFromProps: startIndexControlledFromProps
          };
        }
        if (endIndexControlledFromProps != null && prevState.prevEndIndexControlledFromProps !== endIndexControlledFromProps) {
          return {
            endX: prevState.scale(endIndexControlledFromProps),
            prevEndIndexControlledFromProps: endIndexControlledFromProps
          };
        }
      }
      return null;
    }
    componentWillUnmount() {
      if (this.leaveTimer) {
        clearTimeout(this.leaveTimer);
        this.leaveTimer = null;
      }
      this.detachDragEndListener();
    }
    attachDragEndListener() {
      window.addEventListener("mouseup", this.handleDragEnd, true);
      window.addEventListener("touchend", this.handleDragEnd, true);
      window.addEventListener("mousemove", this.handleDrag, true);
    }
    detachDragEndListener() {
      window.removeEventListener("mouseup", this.handleDragEnd, true);
      window.removeEventListener("touchend", this.handleDragEnd, true);
      window.removeEventListener("mousemove", this.handleDrag, true);
    }
    handleSlideDrag(e) {
      var {
        slideMoveStartX,
        startX,
        endX,
        scaleValues
      } = this.state;
      if (scaleValues == null) {
        return;
      }
      var {
        x: x2,
        width,
        travellerWidth,
        startIndex,
        endIndex,
        onChange,
        data,
        gap
      } = this.props;
      var delta = e.pageX - slideMoveStartX;
      if (delta > 0) {
        delta = Math.min(delta, x2 + width - travellerWidth - endX, x2 + width - travellerWidth - startX);
      } else if (delta < 0) {
        delta = Math.max(delta, x2 - startX, x2 - endX);
      }
      var newIndex = getIndex({
        startX: startX + delta,
        endX: endX + delta,
        data,
        gap,
        scaleValues
      });
      if ((newIndex.startIndex !== startIndex || newIndex.endIndex !== endIndex) && onChange) {
        onChange(newIndex);
      }
      this.setState({
        startX: startX + delta,
        endX: endX + delta,
        slideMoveStartX: e.pageX
      });
    }
    handleTravellerDragStart(id, e) {
      var event = isTouch(e) ? e.changedTouches[0] : e;
      this.setState({
        isSlideMoving: false,
        isTravellerMoving: true,
        movingTravellerId: id,
        brushMoveStartX: event.pageX
      });
      this.attachDragEndListener();
    }
    handleTravellerMove(e) {
      var {
        brushMoveStartX,
        movingTravellerId,
        endX,
        startX,
        scaleValues
      } = this.state;
      if (movingTravellerId == null) {
        return;
      }
      var prevValue = this.state[movingTravellerId];
      var {
        x: x2,
        width,
        travellerWidth,
        onChange,
        gap,
        data
      } = this.props;
      var params = {
        startX: this.state.startX,
        endX: this.state.endX,
        data,
        gap,
        scaleValues
      };
      var delta = e.pageX - brushMoveStartX;
      if (delta > 0) {
        delta = Math.min(delta, x2 + width - travellerWidth - prevValue);
      } else if (delta < 0) {
        delta = Math.max(delta, x2 - prevValue);
      }
      params[movingTravellerId] = prevValue + delta;
      var newIndex = getIndex(params);
      var {
        startIndex,
        endIndex
      } = newIndex;
      var isFullGap = () => {
        var lastIndex = data.length - 1;
        if (movingTravellerId === "startX" && (endX > startX ? startIndex % gap === 0 : endIndex % gap === 0) || endX < startX && endIndex === lastIndex || movingTravellerId === "endX" && (endX > startX ? endIndex % gap === 0 : startIndex % gap === 0) || endX > startX && endIndex === lastIndex) {
          return true;
        }
        return false;
      };
      this.setState(
        // @ts-expect-error not sure why typescript is not happy with this, partial update is fine in React
        {
          [movingTravellerId]: prevValue + delta,
          brushMoveStartX: e.pageX
        },
        () => {
          if (onChange) {
            if (isFullGap()) {
              onChange(newIndex);
            }
          }
        }
      );
    }
    render() {
      var {
        data,
        className,
        children,
        x: x2,
        y: y2,
        dy,
        width,
        height,
        alwaysShowText,
        fill: fill2,
        stroke,
        startIndex,
        endIndex,
        travellerWidth,
        tickFormatter,
        dataKey,
        padding
      } = this.props;
      var {
        startX,
        endX,
        isTextActive,
        isSlideMoving,
        isTravellerMoving,
        isTravellerFocused
      } = this.state;
      if (!data || !data.length || !isNumber(x2) || !isNumber(y2) || !isNumber(width) || !isNumber(height) || width <= 0 || height <= 0) {
        return null;
      }
      var layerClass = clsx("recharts-brush", className);
      var style = generatePrefixStyle("userSelect", "none");
      var calculatedY = y2 + (dy !== null && dy !== void 0 ? dy : 0);
      return /* @__PURE__ */ React__namespace.createElement(Layer, {
        className: layerClass,
        onMouseLeave: this.handleLeaveWrapper,
        onTouchMove: this.handleTouchMove,
        style
      }, /* @__PURE__ */ React__namespace.createElement(Background$1, {
        x: x2,
        y: calculatedY,
        width,
        height,
        fill: fill2,
        stroke
      }), /* @__PURE__ */ React__namespace.createElement(PanoramaContextProvider, null, /* @__PURE__ */ React__namespace.createElement(Panorama, {
        x: x2,
        y: calculatedY,
        width,
        height,
        data,
        padding
      }, children)), /* @__PURE__ */ React__namespace.createElement(Slide, {
        y: calculatedY,
        height,
        stroke,
        travellerWidth,
        startX,
        endX,
        onMouseEnter: this.handleEnterSlideOrTraveller,
        onMouseLeave: this.handleLeaveSlideOrTraveller,
        onMouseDown: this.handleSlideDragStart,
        onTouchStart: this.handleSlideDragStart
      }), /* @__PURE__ */ React__namespace.createElement(TravellerLayer, {
        travellerX: startX,
        id: "startX",
        otherProps: _objectSpread$j(_objectSpread$j({}, this.props), {}, {
          y: calculatedY
        }),
        onMouseEnter: this.handleEnterSlideOrTraveller,
        onMouseLeave: this.handleLeaveSlideOrTraveller,
        onMouseDown: this.travellerDragStartHandlers.startX,
        onTouchStart: this.travellerDragStartHandlers.startX,
        onTravellerMoveKeyboard: this.handleTravellerMoveKeyboard,
        onFocus: () => {
          this.setState({
            isTravellerFocused: true
          });
        },
        onBlur: () => {
          this.setState({
            isTravellerFocused: false
          });
        }
      }), /* @__PURE__ */ React__namespace.createElement(TravellerLayer, {
        travellerX: endX,
        id: "endX",
        otherProps: _objectSpread$j(_objectSpread$j({}, this.props), {}, {
          y: calculatedY
        }),
        onMouseEnter: this.handleEnterSlideOrTraveller,
        onMouseLeave: this.handleLeaveSlideOrTraveller,
        onMouseDown: this.travellerDragStartHandlers.endX,
        onTouchStart: this.travellerDragStartHandlers.endX,
        onTravellerMoveKeyboard: this.handleTravellerMoveKeyboard,
        onFocus: () => {
          this.setState({
            isTravellerFocused: true
          });
        },
        onBlur: () => {
          this.setState({
            isTravellerFocused: false
          });
        }
      }), (isTextActive || isSlideMoving || isTravellerMoving || isTravellerFocused || alwaysShowText) && /* @__PURE__ */ React__namespace.createElement(BrushText, {
        startIndex,
        endIndex,
        y: calculatedY,
        height,
        travellerWidth,
        stroke,
        tickFormatter,
        dataKey,
        data,
        startX,
        endX
      }));
    }
  }
  function BrushInternal(props) {
    var dispatch = useAppDispatch();
    var chartData = useChartData();
    var dataIndexes = useDataIndex();
    var onChangeFromContext = React.useContext(BrushUpdateDispatchContext);
    var onChangeFromProps = props.onChange;
    var {
      startIndex: startIndexFromProps,
      endIndex: endIndexFromProps
    } = props;
    React.useEffect(() => {
      dispatch(setDataStartEndIndexes({
        startIndex: startIndexFromProps,
        endIndex: endIndexFromProps
      }));
    }, [dispatch, endIndexFromProps, startIndexFromProps]);
    useBrushChartSynchronisation();
    var onChange = React.useCallback((nextState) => {
      if (dataIndexes == null) {
        return;
      }
      var {
        startIndex: startIndex2,
        endIndex: endIndex2
      } = dataIndexes;
      if (nextState.startIndex !== startIndex2 || nextState.endIndex !== endIndex2) {
        onChangeFromContext === null || onChangeFromContext === void 0 || onChangeFromContext(nextState);
        onChangeFromProps === null || onChangeFromProps === void 0 || onChangeFromProps(nextState);
        dispatch(setDataStartEndIndexes(nextState));
      }
    }, [onChangeFromProps, onChangeFromContext, dispatch, dataIndexes]);
    var brushDimensions = useAppSelector(selectBrushDimensions);
    if (brushDimensions == null || dataIndexes == null || chartData == null || !chartData.length) {
      return null;
    }
    var {
      startIndex,
      endIndex
    } = dataIndexes;
    var {
      x: x2,
      y: y2,
      width
    } = brushDimensions;
    var contextProperties = {
      data: chartData,
      x: x2,
      y: y2,
      width,
      startIndex,
      endIndex,
      onChange
    };
    return /* @__PURE__ */ React__namespace.createElement(BrushWithState, _extends$k({}, props, contextProperties, {
      startIndexControlledFromProps: startIndexFromProps !== null && startIndexFromProps !== void 0 ? startIndexFromProps : void 0,
      endIndexControlledFromProps: endIndexFromProps !== null && endIndexFromProps !== void 0 ? endIndexFromProps : void 0
    }));
  }
  function BrushSettingsDispatcher(props) {
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(setBrushSettings(props));
      return () => {
        dispatch(setBrushSettings(null));
      };
    }, [dispatch, props]);
    return null;
  }
  var defaultBrushProps = {
    height: 40,
    travellerWidth: 5,
    gap: 1,
    fill: "#fff",
    stroke: "#666",
    padding: {
      top: 1,
      right: 1,
      bottom: 1,
      left: 1
    },
    leaveTimeOut: 1e3,
    alwaysShowText: false
  };
  function Brush(outsideProps) {
    var props = resolveDefaultProps(outsideProps, defaultBrushProps);
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(BrushSettingsDispatcher, {
      height: props.height,
      x: props.x,
      y: props.y,
      width: props.width,
      padding: props.padding
    }), /* @__PURE__ */ React__namespace.createElement(BrushInternal, props));
  }
  Brush.displayName = "Brush";
  function ownKeys$i(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$i(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$i(Object(t), true).forEach(function(r3) {
        _defineProperty$l(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$i(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$l(e, r2, t) {
    return (r2 = _toPropertyKey$l(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$l(t) {
    var i = _toPrimitive$l(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$l(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var rectWithPoints = (_ref2, _ref22) => {
    var {
      x: x1,
      y: y1
    } = _ref2;
    var {
      x: x2,
      y: y2
    } = _ref22;
    return {
      x: Math.min(x1, x2),
      y: Math.min(y1, y2),
      width: Math.abs(x2 - x1),
      height: Math.abs(y2 - y1)
    };
  };
  var rectWithCoords = (_ref3) => {
    var {
      x1,
      y1,
      x2,
      y2
    } = _ref3;
    return rectWithPoints({
      x: x1,
      y: y1
    }, {
      x: x2,
      y: y2
    });
  };
  class ScaleHelper {
    static create(obj) {
      return new ScaleHelper(obj);
    }
    constructor(scale) {
      this.scale = scale;
    }
    get domain() {
      return this.scale.domain;
    }
    get range() {
      return this.scale.range;
    }
    get rangeMin() {
      return this.range()[0];
    }
    get rangeMax() {
      return this.range()[1];
    }
    get bandwidth() {
      return this.scale.bandwidth;
    }
    apply(value) {
      var {
        bandAware,
        position: position2
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (value === void 0) {
        return void 0;
      }
      if (position2) {
        switch (position2) {
          case "start": {
            return this.scale(value);
          }
          case "middle": {
            var offset = this.bandwidth ? this.bandwidth() / 2 : 0;
            return this.scale(value) + offset;
          }
          case "end": {
            var _offset = this.bandwidth ? this.bandwidth() : 0;
            return this.scale(value) + _offset;
          }
          default: {
            return this.scale(value);
          }
        }
      }
      if (bandAware) {
        var _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;
        return this.scale(value) + _offset2;
      }
      return this.scale(value);
    }
    isInRange(value) {
      var range2 = this.range();
      var first = range2[0];
      var last2 = range2[range2.length - 1];
      return first <= last2 ? value >= first && value <= last2 : value >= last2 && value <= first;
    }
  }
  _defineProperty$l(ScaleHelper, "EPS", 1e-4);
  var createLabeledScales = (options2) => {
    var scales = Object.keys(options2).reduce((res, key) => _objectSpread$i(_objectSpread$i({}, res), {}, {
      [key]: ScaleHelper.create(options2[key])
    }), {});
    return _objectSpread$i(_objectSpread$i({}, scales), {}, {
      apply(coord) {
        var {
          bandAware,
          position: position2
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return Object.fromEntries(Object.entries(coord).map((_ref4) => {
          var [label, value] = _ref4;
          return [label, scales[label].apply(value, {
            bandAware,
            position: position2
          })];
        }));
      },
      isInRange(coord) {
        return Object.keys(coord).every((label) => scales[label].isInRange(coord[label]));
      }
    });
  };
  function normalizeAngle(angle) {
    return (angle % 180 + 180) % 180;
  }
  var getAngledRectangleWidth = function getAngledRectangleWidth2(_ref5) {
    var {
      width,
      height
    } = _ref5;
    var angle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var normalizedAngle = normalizeAngle(angle);
    var angleRadians = normalizedAngle * Math.PI / 180;
    var angleThreshold = Math.atan(height / width);
    var angledWidth = angleRadians > angleThreshold && angleRadians < Math.PI - angleThreshold ? height / Math.sin(angleRadians) : width / Math.cos(angleRadians);
    return Math.abs(angledWidth);
  };
  var initialState$2 = {
    dots: [],
    areas: [],
    lines: []
  };
  var referenceElementsSlice = createSlice({
    name: "referenceElements",
    initialState: initialState$2,
    reducers: {
      addDot: (state, action) => {
        state.dots.push(action.payload);
      },
      removeDot: (state, action) => {
        var index2 = current(state).dots.findIndex((dot) => dot === action.payload);
        if (index2 !== -1) {
          state.dots.splice(index2, 1);
        }
      },
      addArea: (state, action) => {
        state.areas.push(action.payload);
      },
      removeArea: (state, action) => {
        var index2 = current(state).areas.findIndex((area) => area === action.payload);
        if (index2 !== -1) {
          state.areas.splice(index2, 1);
        }
      },
      addLine: (state, action) => {
        state.lines.push(action.payload);
      },
      removeLine: (state, action) => {
        var index2 = current(state).lines.findIndex((line) => line === action.payload);
        if (index2 !== -1) {
          state.lines.splice(index2, 1);
        }
      }
    }
  });
  var {
    addDot,
    removeDot,
    addArea,
    removeArea,
    addLine,
    removeLine
  } = referenceElementsSlice.actions;
  var referenceElementsReducer = referenceElementsSlice.reducer;
  var ClipPathIdContext = /* @__PURE__ */ React.createContext(void 0);
  var ClipPathProvider = (_ref2) => {
    var {
      children
    } = _ref2;
    var [clipPathId] = React.useState("".concat(uniqueId("recharts"), "-clip"));
    var plotArea = usePlotArea();
    if (plotArea == null) {
      return null;
    }
    var {
      x: x2,
      y: y2,
      width,
      height
    } = plotArea;
    return /* @__PURE__ */ React__namespace.createElement(ClipPathIdContext.Provider, {
      value: clipPathId
    }, /* @__PURE__ */ React__namespace.createElement("defs", null, /* @__PURE__ */ React__namespace.createElement("clipPath", {
      id: clipPathId
    }, /* @__PURE__ */ React__namespace.createElement("rect", {
      x: x2,
      y: y2,
      height,
      width
    }))), children);
  };
  var useClipPathId = () => {
    return React.useContext(ClipPathIdContext);
  };
  function ownKeys$h(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$h(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$h(Object(t), true).forEach(function(r3) {
        _defineProperty$k(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$h(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$k(e, r2, t) {
    return (r2 = _toPropertyKey$k(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$k(t) {
    var i = _toPrimitive$k(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$k(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _extends$j() {
    return _extends$j = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$j.apply(null, arguments);
  }
  var renderLine = (option, props) => {
    var line;
    if (/* @__PURE__ */ React__namespace.isValidElement(option)) {
      line = /* @__PURE__ */ React__namespace.cloneElement(option, props);
    } else if (typeof option === "function") {
      line = option(props);
    } else {
      line = /* @__PURE__ */ React__namespace.createElement("line", _extends$j({}, props, {
        className: "recharts-reference-line-line"
      }));
    }
    return line;
  };
  var getEndPoints = (scales, isFixedX, isFixedY, isSegment, viewBox, position2, xAxisOrientation, yAxisOrientation, props) => {
    var {
      x: x2,
      y: y2,
      width,
      height
    } = viewBox;
    if (isFixedY) {
      var {
        y: yCoord
      } = props;
      var coord = scales.y.apply(yCoord, {
        position: position2
      });
      if (isNan(coord)) return null;
      if (props.ifOverflow === "discard" && !scales.y.isInRange(coord)) {
        return null;
      }
      var points = [{
        x: x2 + width,
        y: coord
      }, {
        x: x2,
        y: coord
      }];
      return yAxisOrientation === "left" ? points.reverse() : points;
    }
    if (isFixedX) {
      var {
        x: xCoord
      } = props;
      var _coord = scales.x.apply(xCoord, {
        position: position2
      });
      if (isNan(_coord)) return null;
      if (props.ifOverflow === "discard" && !scales.x.isInRange(_coord)) {
        return null;
      }
      var _points = [{
        x: _coord,
        y: y2 + height
      }, {
        x: _coord,
        y: y2
      }];
      return xAxisOrientation === "top" ? _points.reverse() : _points;
    }
    if (isSegment) {
      var {
        segment
      } = props;
      var _points2 = segment.map((p) => scales.apply(p, {
        position: position2
      }));
      if (props.ifOverflow === "discard" && _points2.some((p) => !scales.isInRange(p))) {
        return null;
      }
      return _points2;
    }
    return null;
  };
  function ReportReferenceLine(props) {
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(addLine(props));
      return () => {
        dispatch(removeLine(props));
      };
    });
    return null;
  }
  function ReferenceLineImpl(props) {
    var {
      x: fixedX,
      y: fixedY,
      segment,
      xAxisId,
      yAxisId,
      shape,
      className,
      ifOverflow
    } = props;
    var isPanorama = useIsPanorama();
    var clipPathId = useClipPathId();
    var xAxis = useAppSelector((state) => selectXAxisSettings(state, xAxisId));
    var yAxis = useAppSelector((state) => selectYAxisSettings(state, yAxisId));
    var xAxisScale = useAppSelector((state) => selectAxisScale(state, "xAxis", xAxisId, isPanorama));
    var yAxisScale = useAppSelector((state) => selectAxisScale(state, "yAxis", yAxisId, isPanorama));
    var viewBox = useViewBox();
    var isFixedX = isNumOrStr(fixedX);
    var isFixedY = isNumOrStr(fixedY);
    if (!clipPathId || !viewBox || xAxis == null || yAxis == null || xAxisScale == null || yAxisScale == null) {
      return null;
    }
    var scales = createLabeledScales({
      x: xAxisScale,
      y: yAxisScale
    });
    var isSegment = segment && segment.length === 2;
    var endPoints = getEndPoints(scales, isFixedX, isFixedY, isSegment, viewBox, props.position, xAxis.orientation, yAxis.orientation, props);
    if (!endPoints) {
      return null;
    }
    var [{
      x: x1,
      y: y1
    }, {
      x: x2,
      y: y2
    }] = endPoints;
    var clipPath = ifOverflow === "hidden" ? "url(#".concat(clipPathId, ")") : void 0;
    var lineProps = _objectSpread$h(_objectSpread$h({
      clipPath
    }, filterProps(props, true)), {}, {
      x1,
      y1,
      x2,
      y2
    });
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: clsx("recharts-reference-line", className)
    }, renderLine(shape, lineProps), Label.renderCallByParent(props, rectWithCoords({
      x1,
      y1,
      x2,
      y2
    })));
  }
  function ReferenceLineSettingsDispatcher(props) {
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(ReportReferenceLine, {
      yAxisId: props.yAxisId,
      xAxisId: props.xAxisId,
      ifOverflow: props.ifOverflow,
      x: props.x,
      y: props.y
    }), /* @__PURE__ */ React__namespace.createElement(ReferenceLineImpl, props));
  }
  class ReferenceLine extends React.Component {
    render() {
      return /* @__PURE__ */ React__namespace.createElement(ReferenceLineSettingsDispatcher, this.props);
    }
  }
  _defineProperty$k(ReferenceLine, "displayName", "ReferenceLine");
  _defineProperty$k(ReferenceLine, "defaultProps", {
    ifOverflow: "discard",
    xAxisId: 0,
    yAxisId: 0,
    fill: "none",
    stroke: "#ccc",
    fillOpacity: 1,
    strokeWidth: 1,
    position: "middle"
  });
  function ownKeys$g(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$g(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$g(Object(t), true).forEach(function(r3) {
        _defineProperty$j(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$g(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$j(e, r2, t) {
    return (r2 = _toPropertyKey$j(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$j(t) {
    var i = _toPrimitive$j(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$j(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _extends$i() {
    return _extends$i = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$i.apply(null, arguments);
  }
  var useCoordinate = (x2, y2, xAxisId, yAxisId, ifOverflow) => {
    var isX = isNumOrStr(x2);
    var isY = isNumOrStr(y2);
    var isPanorama = useIsPanorama();
    var xAxisScale = useAppSelector((state) => selectAxisScale(state, "xAxis", xAxisId, isPanorama));
    var yAxisScale = useAppSelector((state) => selectAxisScale(state, "yAxis", yAxisId, isPanorama));
    if (!isX || !isY || xAxisScale == null || yAxisScale == null) {
      return null;
    }
    var scales = createLabeledScales({
      x: xAxisScale,
      y: yAxisScale
    });
    var result = scales.apply({
      x: x2,
      y: y2
    }, {
      bandAware: true
    });
    if (ifOverflow === "discard" && !scales.isInRange(result)) {
      return null;
    }
    return result;
  };
  function ReportReferenceDot(props) {
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(addDot(props));
      return () => {
        dispatch(removeDot(props));
      };
    });
    return null;
  }
  var renderDot = (option, props) => {
    var dot;
    if (/* @__PURE__ */ React__namespace.isValidElement(option)) {
      dot = /* @__PURE__ */ React__namespace.cloneElement(option, props);
    } else if (typeof option === "function") {
      dot = option(props);
    } else {
      dot = /* @__PURE__ */ React__namespace.createElement(Dot, _extends$i({}, props, {
        cx: props.cx,
        cy: props.cy,
        className: "recharts-reference-dot-dot"
      }));
    }
    return dot;
  };
  function ReferenceDotImpl(props) {
    var {
      x: x2,
      y: y2,
      r: r2
    } = props;
    var clipPathId = useClipPathId();
    var coordinate = useCoordinate(x2, y2, props.xAxisId, props.yAxisId, props.ifOverflow);
    if (!coordinate) {
      return null;
    }
    var {
      x: cx,
      y: cy
    } = coordinate;
    var {
      shape,
      className,
      ifOverflow
    } = props;
    var clipPath = ifOverflow === "hidden" ? "url(#".concat(clipPathId, ")") : void 0;
    var dotProps = _objectSpread$g(_objectSpread$g({
      clipPath
    }, filterProps(props, true)), {}, {
      cx,
      cy
    });
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: clsx("recharts-reference-dot", className)
    }, renderDot(shape, dotProps), Label.renderCallByParent(props, {
      x: cx - r2,
      y: cy - r2,
      width: 2 * r2,
      height: 2 * r2
    }));
  }
  function ReferenceDotSettingsDispatcher(props) {
    var {
      x: x2,
      y: y2,
      r: r2,
      ifOverflow,
      yAxisId,
      xAxisId
    } = props;
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(ReportReferenceDot, {
      y: y2,
      x: x2,
      r: r2,
      yAxisId,
      xAxisId,
      ifOverflow
    }), /* @__PURE__ */ React__namespace.createElement(ReferenceDotImpl, props));
  }
  class ReferenceDot extends React.Component {
    render() {
      return /* @__PURE__ */ React__namespace.createElement(ReferenceDotSettingsDispatcher, this.props);
    }
  }
  _defineProperty$j(ReferenceDot, "displayName", "ReferenceDot");
  _defineProperty$j(ReferenceDot, "defaultProps", {
    ifOverflow: "discard",
    xAxisId: 0,
    yAxisId: 0,
    r: 10,
    fill: "#fff",
    stroke: "#ccc",
    fillOpacity: 1,
    strokeWidth: 1
  });
  function ownKeys$f(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$f(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$f(Object(t), true).forEach(function(r3) {
        _defineProperty$i(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$f(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$i(e, r2, t) {
    return (r2 = _toPropertyKey$i(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$i(t) {
    var i = _toPrimitive$i(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$i(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _extends$h() {
    return _extends$h = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$h.apply(null, arguments);
  }
  var getRect = (hasX1, hasX2, hasY1, hasY2, xAxisScale, yAxisScale, props) => {
    var {
      x1: xValue1,
      x2: xValue2,
      y1: yValue1,
      y2: yValue2
    } = props;
    if (xAxisScale == null || yAxisScale == null) {
      return null;
    }
    var scales = createLabeledScales({
      x: xAxisScale,
      y: yAxisScale
    });
    var p1 = {
      x: hasX1 ? scales.x.apply(xValue1, {
        position: "start"
      }) : scales.x.rangeMin,
      y: hasY1 ? scales.y.apply(yValue1, {
        position: "start"
      }) : scales.y.rangeMin
    };
    var p2 = {
      x: hasX2 ? scales.x.apply(xValue2, {
        position: "end"
      }) : scales.x.rangeMax,
      y: hasY2 ? scales.y.apply(yValue2, {
        position: "end"
      }) : scales.y.rangeMax
    };
    if (props.ifOverflow === "discard" && (!scales.isInRange(p1) || !scales.isInRange(p2))) {
      return null;
    }
    return rectWithPoints(p1, p2);
  };
  var renderRect = (option, props) => {
    var rect;
    if (/* @__PURE__ */ React__namespace.isValidElement(option)) {
      rect = /* @__PURE__ */ React__namespace.cloneElement(option, props);
    } else if (typeof option === "function") {
      rect = option(props);
    } else {
      rect = /* @__PURE__ */ React__namespace.createElement(Rectangle, _extends$h({}, props, {
        className: "recharts-reference-area-rect"
      }));
    }
    return rect;
  };
  function ReportReferenceArea(props) {
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(addArea(props));
      return () => {
        dispatch(removeArea(props));
      };
    });
    return null;
  }
  function ReferenceAreaImpl(props) {
    var {
      x1,
      x2,
      y1,
      y2,
      className,
      shape,
      xAxisId,
      yAxisId
    } = props;
    var clipPathId = useClipPathId();
    var isPanorama = useIsPanorama();
    var xAxisScale = useAppSelector((state) => selectAxisScale(state, "xAxis", xAxisId, isPanorama));
    var yAxisScale = useAppSelector((state) => selectAxisScale(state, "yAxis", yAxisId, isPanorama));
    if (xAxisScale == null || !yAxisScale == null) {
      return null;
    }
    var hasX1 = isNumOrStr(x1);
    var hasX2 = isNumOrStr(x2);
    var hasY1 = isNumOrStr(y1);
    var hasY2 = isNumOrStr(y2);
    if (!hasX1 && !hasX2 && !hasY1 && !hasY2 && !shape) {
      return null;
    }
    var rect = getRect(hasX1, hasX2, hasY1, hasY2, xAxisScale, yAxisScale, props);
    if (!rect && !shape) {
      return null;
    }
    var isOverflowHidden = props.ifOverflow === "hidden";
    var clipPath = isOverflowHidden ? "url(#".concat(clipPathId, ")") : void 0;
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: clsx("recharts-reference-area", className)
    }, renderRect(shape, _objectSpread$f(_objectSpread$f({
      clipPath
    }, filterProps(props, true)), rect)), Label.renderCallByParent(props, rect));
  }
  function ReferenceAreaSettingsDispatcher(props) {
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(ReportReferenceArea, {
      yAxisId: props.yAxisId,
      xAxisId: props.xAxisId,
      ifOverflow: props.ifOverflow,
      x1: props.x1,
      x2: props.x2,
      y1: props.y1,
      y2: props.y2
    }), /* @__PURE__ */ React__namespace.createElement(ReferenceAreaImpl, props));
  }
  class ReferenceArea extends React.Component {
    render() {
      return /* @__PURE__ */ React__namespace.createElement(ReferenceAreaSettingsDispatcher, this.props);
    }
  }
  _defineProperty$i(ReferenceArea, "displayName", "ReferenceArea");
  _defineProperty$i(ReferenceArea, "defaultProps", {
    ifOverflow: "discard",
    xAxisId: 0,
    yAxisId: 0,
    r: 10,
    fill: "#ccc",
    fillOpacity: 0.5,
    stroke: "none",
    strokeWidth: 1
  });
  function shallowEqual$1(a2, b) {
    for (var key in a2) {
      if ({}.hasOwnProperty.call(a2, key) && (!{}.hasOwnProperty.call(b, key) || a2[key] !== b[key])) {
        return false;
      }
    }
    for (var _key in b) {
      if ({}.hasOwnProperty.call(b, _key) && !{}.hasOwnProperty.call(a2, _key)) {
        return false;
      }
    }
    return true;
  }
  function getEveryNthWithCondition(array2, n, isValid) {
    if (n < 1) {
      return [];
    }
    if (n === 1 && isValid === void 0) {
      return array2;
    }
    var result = [];
    for (var i = 0; i < array2.length; i += n) {
      if (isValid === void 0 || isValid(array2[i]) === true) {
        result.push(array2[i]);
      } else {
        return void 0;
      }
    }
    return result;
  }
  function getAngledTickWidth(contentSize, unitSize, angle) {
    var size = {
      width: contentSize.width + unitSize.width,
      height: contentSize.height + unitSize.height
    };
    return getAngledRectangleWidth(size, angle);
  }
  function getTickBoundaries(viewBox, sign2, sizeKey) {
    var isWidth = sizeKey === "width";
    var {
      x: x2,
      y: y2,
      width,
      height
    } = viewBox;
    if (sign2 === 1) {
      return {
        start: isWidth ? x2 : y2,
        end: isWidth ? x2 + width : y2 + height
      };
    }
    return {
      start: isWidth ? x2 + width : y2 + height,
      end: isWidth ? x2 : y2
    };
  }
  function isVisible(sign2, tickPosition, getSize, start, end) {
    if (sign2 * tickPosition < sign2 * start || sign2 * tickPosition > sign2 * end) {
      return false;
    }
    var size = getSize();
    return sign2 * (tickPosition - sign2 * size / 2 - start) >= 0 && sign2 * (tickPosition + sign2 * size / 2 - end) <= 0;
  }
  function getNumberIntervalTicks(ticks2, interval) {
    return getEveryNthWithCondition(ticks2, interval + 1);
  }
  function getEquidistantTicks(sign2, boundaries, getTickSize, ticks2, minTickGap) {
    var result = (ticks2 || []).slice();
    var {
      start: initialStart,
      end
    } = boundaries;
    var index2 = 0;
    var stepsize = 1;
    var start = initialStart;
    var _loop = function _loop2() {
      var entry = ticks2 === null || ticks2 === void 0 ? void 0 : ticks2[index2];
      if (entry === void 0) {
        return {
          v: getEveryNthWithCondition(ticks2, stepsize)
        };
      }
      var i = index2;
      var size;
      var getSize = () => {
        if (size === void 0) {
          size = getTickSize(entry, i);
        }
        return size;
      };
      var tickCoord = entry.coordinate;
      var isShow = index2 === 0 || isVisible(sign2, tickCoord, getSize, start, end);
      if (!isShow) {
        index2 = 0;
        start = initialStart;
        stepsize += 1;
      }
      if (isShow) {
        start = tickCoord + sign2 * (getSize() / 2 + minTickGap);
        index2 += stepsize;
      }
    }, _ret;
    while (stepsize <= result.length) {
      _ret = _loop();
      if (_ret) return _ret.v;
    }
    return [];
  }
  function ownKeys$e(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$e(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$e(Object(t), true).forEach(function(r3) {
        _defineProperty$h(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$h(e, r2, t) {
    return (r2 = _toPropertyKey$h(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$h(t) {
    var i = _toPrimitive$h(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$h(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function getTicksEnd(sign2, boundaries, getTickSize, ticks2, minTickGap) {
    var result = (ticks2 || []).slice();
    var len = result.length;
    var {
      start
    } = boundaries;
    var {
      end
    } = boundaries;
    var _loop = function _loop2(i2) {
      var entry = result[i2];
      var size;
      var getSize = () => {
        if (size === void 0) {
          size = getTickSize(entry, i2);
        }
        return size;
      };
      if (i2 === len - 1) {
        var gap = sign2 * (entry.coordinate + sign2 * getSize() / 2 - end);
        result[i2] = entry = _objectSpread$e(_objectSpread$e({}, entry), {}, {
          tickCoord: gap > 0 ? entry.coordinate - gap * sign2 : entry.coordinate
        });
      } else {
        result[i2] = entry = _objectSpread$e(_objectSpread$e({}, entry), {}, {
          tickCoord: entry.coordinate
        });
      }
      var isShow = isVisible(sign2, entry.tickCoord, getSize, start, end);
      if (isShow) {
        end = entry.tickCoord - sign2 * (getSize() / 2 + minTickGap);
        result[i2] = _objectSpread$e(_objectSpread$e({}, entry), {}, {
          isShow: true
        });
      }
    };
    for (var i = len - 1; i >= 0; i--) {
      _loop(i);
    }
    return result;
  }
  function getTicksStart(sign2, boundaries, getTickSize, ticks2, minTickGap, preserveEnd) {
    var result = (ticks2 || []).slice();
    var len = result.length;
    var {
      start,
      end
    } = boundaries;
    if (preserveEnd) {
      var tail2 = ticks2[len - 1];
      var tailSize = getTickSize(tail2, len - 1);
      var tailGap = sign2 * (tail2.coordinate + sign2 * tailSize / 2 - end);
      result[len - 1] = tail2 = _objectSpread$e(_objectSpread$e({}, tail2), {}, {
        tickCoord: tailGap > 0 ? tail2.coordinate - tailGap * sign2 : tail2.coordinate
      });
      var isTailShow = isVisible(sign2, tail2.tickCoord, () => tailSize, start, end);
      if (isTailShow) {
        end = tail2.tickCoord - sign2 * (tailSize / 2 + minTickGap);
        result[len - 1] = _objectSpread$e(_objectSpread$e({}, tail2), {}, {
          isShow: true
        });
      }
    }
    var count2 = preserveEnd ? len - 1 : len;
    var _loop2 = function _loop22(i2) {
      var entry = result[i2];
      var size;
      var getSize = () => {
        if (size === void 0) {
          size = getTickSize(entry, i2);
        }
        return size;
      };
      if (i2 === 0) {
        var gap = sign2 * (entry.coordinate - sign2 * getSize() / 2 - start);
        result[i2] = entry = _objectSpread$e(_objectSpread$e({}, entry), {}, {
          tickCoord: gap < 0 ? entry.coordinate - gap * sign2 : entry.coordinate
        });
      } else {
        result[i2] = entry = _objectSpread$e(_objectSpread$e({}, entry), {}, {
          tickCoord: entry.coordinate
        });
      }
      var isShow = isVisible(sign2, entry.tickCoord, getSize, start, end);
      if (isShow) {
        start = entry.tickCoord + sign2 * (getSize() / 2 + minTickGap);
        result[i2] = _objectSpread$e(_objectSpread$e({}, entry), {}, {
          isShow: true
        });
      }
    };
    for (var i = 0; i < count2; i++) {
      _loop2(i);
    }
    return result;
  }
  function getTicks(props, fontSize, letterSpacing) {
    var {
      tick,
      ticks: ticks2,
      viewBox,
      minTickGap,
      orientation,
      interval,
      tickFormatter,
      unit: unit2,
      angle
    } = props;
    if (!ticks2 || !ticks2.length || !tick) {
      return [];
    }
    if (isNumber(interval) || Global.isSsr) {
      var _getNumberIntervalTic;
      return (_getNumberIntervalTic = getNumberIntervalTicks(ticks2, isNumber(interval) ? interval : 0)) !== null && _getNumberIntervalTic !== void 0 ? _getNumberIntervalTic : [];
    }
    var candidates = [];
    var sizeKey = orientation === "top" || orientation === "bottom" ? "width" : "height";
    var unitSize = unit2 && sizeKey === "width" ? getStringSize(unit2, {
      fontSize,
      letterSpacing
    }) : {
      width: 0,
      height: 0
    };
    var getTickSize = (content, index2) => {
      var value = typeof tickFormatter === "function" ? tickFormatter(content.value, index2) : content.value;
      return sizeKey === "width" ? getAngledTickWidth(getStringSize(value, {
        fontSize,
        letterSpacing
      }), unitSize, angle) : getStringSize(value, {
        fontSize,
        letterSpacing
      })[sizeKey];
    };
    var sign2 = ticks2.length >= 2 ? mathSign(ticks2[1].coordinate - ticks2[0].coordinate) : 1;
    var boundaries = getTickBoundaries(viewBox, sign2, sizeKey);
    if (interval === "equidistantPreserveStart") {
      return getEquidistantTicks(sign2, boundaries, getTickSize, ticks2, minTickGap);
    }
    if (interval === "preserveStart" || interval === "preserveStartEnd") {
      candidates = getTicksStart(sign2, boundaries, getTickSize, ticks2, minTickGap, interval === "preserveStartEnd");
    } else {
      candidates = getTicksEnd(sign2, boundaries, getTickSize, ticks2, minTickGap);
    }
    return candidates.filter((entry) => entry.isShow);
  }
  var _excluded$f = ["viewBox"], _excluded2$7 = ["viewBox"];
  function _extends$g() {
    return _extends$g = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$g.apply(null, arguments);
  }
  function ownKeys$d(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$d(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$d(Object(t), true).forEach(function(r3) {
        _defineProperty$g(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _objectWithoutProperties$f(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$f(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$f(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function _defineProperty$g(e, r2, t) {
    return (r2 = _toPropertyKey$g(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$g(t) {
    var i = _toPrimitive$g(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$g(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  class CartesianAxis extends React.Component {
    constructor(props) {
      super(props);
      this.tickRefs = /* @__PURE__ */ React__namespace.createRef();
      this.tickRefs.current = [];
      this.state = {
        fontSize: "",
        letterSpacing: ""
      };
    }
    shouldComponentUpdate(_ref2, nextState) {
      var {
        viewBox
      } = _ref2, restProps = _objectWithoutProperties$f(_ref2, _excluded$f);
      var _this$props = this.props, {
        viewBox: viewBoxOld
      } = _this$props, restPropsOld = _objectWithoutProperties$f(_this$props, _excluded2$7);
      return !shallowEqual$1(viewBox, viewBoxOld) || !shallowEqual$1(restProps, restPropsOld) || !shallowEqual$1(nextState, this.state);
    }
    /**
     * Calculate the coordinates of endpoints in ticks
     * @param  data The data of a simple tick
     * @return (x1, y1): The coordinate of endpoint close to tick text
     *  (x2, y2): The coordinate of endpoint close to axis
     */
    getTickLineCoord(data) {
      var {
        x: x2,
        y: y2,
        width,
        height,
        orientation,
        tickSize,
        mirror,
        tickMargin
      } = this.props;
      var x1, x22, y1, y22, tx, ty;
      var sign2 = mirror ? -1 : 1;
      var finalTickSize = data.tickSize || tickSize;
      var tickCoord = isNumber(data.tickCoord) ? data.tickCoord : data.coordinate;
      switch (orientation) {
        case "top":
          x1 = x22 = data.coordinate;
          y22 = y2 + +!mirror * height;
          y1 = y22 - sign2 * finalTickSize;
          ty = y1 - sign2 * tickMargin;
          tx = tickCoord;
          break;
        case "left":
          y1 = y22 = data.coordinate;
          x22 = x2 + +!mirror * width;
          x1 = x22 - sign2 * finalTickSize;
          tx = x1 - sign2 * tickMargin;
          ty = tickCoord;
          break;
        case "right":
          y1 = y22 = data.coordinate;
          x22 = x2 + +mirror * width;
          x1 = x22 + sign2 * finalTickSize;
          tx = x1 + sign2 * tickMargin;
          ty = tickCoord;
          break;
        default:
          x1 = x22 = data.coordinate;
          y22 = y2 + +mirror * height;
          y1 = y22 + sign2 * finalTickSize;
          ty = y1 + sign2 * tickMargin;
          tx = tickCoord;
          break;
      }
      return {
        line: {
          x1,
          y1,
          x2: x22,
          y2: y22
        },
        tick: {
          x: tx,
          y: ty
        }
      };
    }
    getTickTextAnchor() {
      var {
        orientation,
        mirror
      } = this.props;
      var textAnchor;
      switch (orientation) {
        case "left":
          textAnchor = mirror ? "start" : "end";
          break;
        case "right":
          textAnchor = mirror ? "end" : "start";
          break;
        default:
          textAnchor = "middle";
          break;
      }
      return textAnchor;
    }
    getTickVerticalAnchor() {
      var {
        orientation,
        mirror
      } = this.props;
      switch (orientation) {
        case "left":
        case "right":
          return "middle";
        case "top":
          return mirror ? "start" : "end";
        default:
          return mirror ? "end" : "start";
      }
    }
    renderAxisLine() {
      var {
        x: x2,
        y: y2,
        width,
        height,
        orientation,
        mirror,
        axisLine
      } = this.props;
      var props = _objectSpread$d(_objectSpread$d(_objectSpread$d({}, filterProps(this.props, false)), filterProps(axisLine, false)), {}, {
        fill: "none"
      });
      if (orientation === "top" || orientation === "bottom") {
        var needHeight = +(orientation === "top" && !mirror || orientation === "bottom" && mirror);
        props = _objectSpread$d(_objectSpread$d({}, props), {}, {
          x1: x2,
          y1: y2 + needHeight * height,
          x2: x2 + width,
          y2: y2 + needHeight * height
        });
      } else {
        var needWidth = +(orientation === "left" && !mirror || orientation === "right" && mirror);
        props = _objectSpread$d(_objectSpread$d({}, props), {}, {
          x1: x2 + needWidth * width,
          y1: y2,
          x2: x2 + needWidth * width,
          y2: y2 + height
        });
      }
      return /* @__PURE__ */ React__namespace.createElement("line", _extends$g({}, props, {
        className: clsx("recharts-cartesian-axis-line", get$2(axisLine, "className"))
      }));
    }
    static renderTickItem(option, props, value) {
      var tickItem;
      var combinedClassName = clsx(props.className, "recharts-cartesian-axis-tick-value");
      if (/* @__PURE__ */ React__namespace.isValidElement(option)) {
        tickItem = /* @__PURE__ */ React__namespace.cloneElement(option, _objectSpread$d(_objectSpread$d({}, props), {}, {
          className: combinedClassName
        }));
      } else if (typeof option === "function") {
        tickItem = option(_objectSpread$d(_objectSpread$d({}, props), {}, {
          className: combinedClassName
        }));
      } else {
        var className = "recharts-cartesian-axis-tick-value";
        if (typeof option !== "boolean") {
          className = clsx(className, option.className);
        }
        tickItem = /* @__PURE__ */ React__namespace.createElement(Text, _extends$g({}, props, {
          className
        }), value);
      }
      return tickItem;
    }
    /**
     * render the ticks
     * @param {string} fontSize Fontsize to consider for tick spacing
     * @param {string} letterSpacing Letter spacing to consider for tick spacing
     * @param {Array} ticks The ticks to actually render (overrides what was passed in props)
     * @return {ReactElement | null} renderedTicks
     */
    renderTicks(fontSize, letterSpacing) {
      var ticks2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      var {
        tickLine,
        stroke,
        tick,
        tickFormatter,
        unit: unit2,
        padding
      } = this.props;
      var finalTicks = getTicks(_objectSpread$d(_objectSpread$d({}, this.props), {}, {
        ticks: ticks2
      }), fontSize, letterSpacing);
      var textAnchor = this.getTickTextAnchor();
      var verticalAnchor = this.getTickVerticalAnchor();
      var axisProps = svgPropertiesNoEvents(this.props);
      var customTickProps = filterProps(tick, false);
      var tickLineProps = _objectSpread$d(_objectSpread$d({}, axisProps), {}, {
        fill: "none"
      }, filterProps(tickLine, false));
      var items = finalTicks.map((entry, i) => {
        var {
          line: lineCoord,
          tick: tickCoord
        } = this.getTickLineCoord(entry);
        var tickProps = _objectSpread$d(_objectSpread$d(_objectSpread$d(_objectSpread$d({
          textAnchor,
          verticalAnchor
        }, axisProps), {}, {
          stroke: "none",
          fill: stroke
        }, customTickProps), tickCoord), {}, {
          index: i,
          payload: entry,
          visibleTicksCount: finalTicks.length,
          tickFormatter,
          padding
        });
        return /* @__PURE__ */ React__namespace.createElement(Layer, _extends$g({
          className: "recharts-cartesian-axis-tick",
          key: "tick-".concat(entry.value, "-").concat(entry.coordinate, "-").concat(entry.tickCoord)
        }, adaptEventsOfChild(this.props, entry, i)), tickLine && // @ts-expect-error recharts scale is not compatible with SVG scale
        /* @__PURE__ */ React__namespace.createElement("line", _extends$g({}, tickLineProps, lineCoord, {
          className: clsx("recharts-cartesian-axis-tick-line", get$2(tickLine, "className"))
        })), tick && CartesianAxis.renderTickItem(tick, tickProps, "".concat(typeof tickFormatter === "function" ? tickFormatter(entry.value, i) : entry.value).concat(unit2 || "")));
      });
      return items.length > 0 ? /* @__PURE__ */ React__namespace.createElement("g", {
        className: "recharts-cartesian-axis-ticks"
      }, items) : null;
    }
    render() {
      var {
        axisLine,
        width,
        height,
        className,
        hide
      } = this.props;
      if (hide) {
        return null;
      }
      var {
        ticks: ticks2
      } = this.props;
      if (width != null && width <= 0 || height != null && height <= 0) {
        return null;
      }
      return /* @__PURE__ */ React__namespace.createElement(Layer, {
        className: clsx("recharts-cartesian-axis", className),
        ref: (_ref2) => {
          if (_ref2) {
            var tickNodes = _ref2.getElementsByClassName("recharts-cartesian-axis-tick-value");
            this.tickRefs.current = Array.from(tickNodes);
            var tick = tickNodes[0];
            if (tick) {
              var calculatedFontSize = window.getComputedStyle(tick).fontSize;
              var calculatedLetterSpacing = window.getComputedStyle(tick).letterSpacing;
              if (calculatedFontSize !== this.state.fontSize || calculatedLetterSpacing !== this.state.letterSpacing) {
                this.setState({
                  fontSize: window.getComputedStyle(tick).fontSize,
                  letterSpacing: window.getComputedStyle(tick).letterSpacing
                });
              }
            }
          }
        }
      }, axisLine && this.renderAxisLine(), this.renderTicks(this.state.fontSize, this.state.letterSpacing, ticks2), Label.renderCallByParent(this.props));
    }
  }
  _defineProperty$g(CartesianAxis, "displayName", "CartesianAxis");
  _defineProperty$g(CartesianAxis, "defaultProps", {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    viewBox: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    // The orientation of axis
    orientation: "bottom",
    // The ticks
    ticks: [],
    stroke: "#666",
    tickLine: true,
    axisLine: true,
    tick: true,
    mirror: false,
    minTickGap: 5,
    // The width or height of tick
    tickSize: 6,
    tickMargin: 2,
    interval: "preserveEnd"
  });
  var _excluded$e = ["x1", "y1", "x2", "y2", "key"], _excluded2$6 = ["offset"], _excluded3$2 = ["xAxisId", "yAxisId"], _excluded4 = ["xAxisId", "yAxisId"];
  function ownKeys$c(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$c(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$c(Object(t), true).forEach(function(r3) {
        _defineProperty$f(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$f(e, r2, t) {
    return (r2 = _toPropertyKey$f(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$f(t) {
    var i = _toPrimitive$f(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$f(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _extends$f() {
    return _extends$f = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$f.apply(null, arguments);
  }
  function _objectWithoutProperties$e(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$e(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$e(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var Background = (props) => {
    var {
      fill: fill2
    } = props;
    if (!fill2 || fill2 === "none") {
      return null;
    }
    var {
      fillOpacity,
      x: x2,
      y: y2,
      width,
      height,
      ry
    } = props;
    return /* @__PURE__ */ React__namespace.createElement("rect", {
      x: x2,
      y: y2,
      ry,
      width,
      height,
      stroke: "none",
      fill: fill2,
      fillOpacity,
      className: "recharts-cartesian-grid-bg"
    });
  };
  function renderLineItem(option, props) {
    var lineItem;
    if (/* @__PURE__ */ React__namespace.isValidElement(option)) {
      lineItem = /* @__PURE__ */ React__namespace.cloneElement(option, props);
    } else if (typeof option === "function") {
      lineItem = option(props);
    } else {
      var {
        x1,
        y1,
        x2,
        y2,
        key
      } = props, others = _objectWithoutProperties$e(props, _excluded$e);
      var _svgPropertiesNoEvent = svgPropertiesNoEvents(others), {
        offset: __
      } = _svgPropertiesNoEvent, restOfFilteredProps = _objectWithoutProperties$e(_svgPropertiesNoEvent, _excluded2$6);
      lineItem = /* @__PURE__ */ React__namespace.createElement("line", _extends$f({}, restOfFilteredProps, {
        x1,
        y1,
        x2,
        y2,
        fill: "none",
        key
      }));
    }
    return lineItem;
  }
  function HorizontalGridLines(props) {
    var {
      x: x2,
      width,
      horizontal = true,
      horizontalPoints
    } = props;
    if (!horizontal || !horizontalPoints || !horizontalPoints.length) {
      return null;
    }
    var {
      xAxisId,
      yAxisId
    } = props, otherLineItemProps = _objectWithoutProperties$e(props, _excluded3$2);
    var items = horizontalPoints.map((entry, i) => {
      var lineItemProps = _objectSpread$c(_objectSpread$c({}, otherLineItemProps), {}, {
        x1: x2,
        y1: entry,
        x2: x2 + width,
        y2: entry,
        key: "line-".concat(i),
        index: i
      });
      return renderLineItem(horizontal, lineItemProps);
    });
    return /* @__PURE__ */ React__namespace.createElement("g", {
      className: "recharts-cartesian-grid-horizontal"
    }, items);
  }
  function VerticalGridLines(props) {
    var {
      y: y2,
      height,
      vertical = true,
      verticalPoints
    } = props;
    if (!vertical || !verticalPoints || !verticalPoints.length) {
      return null;
    }
    var {
      xAxisId,
      yAxisId
    } = props, otherLineItemProps = _objectWithoutProperties$e(props, _excluded4);
    var items = verticalPoints.map((entry, i) => {
      var lineItemProps = _objectSpread$c(_objectSpread$c({}, otherLineItemProps), {}, {
        x1: entry,
        y1: y2,
        x2: entry,
        y2: y2 + height,
        key: "line-".concat(i),
        index: i
      });
      return renderLineItem(vertical, lineItemProps);
    });
    return /* @__PURE__ */ React__namespace.createElement("g", {
      className: "recharts-cartesian-grid-vertical"
    }, items);
  }
  function HorizontalStripes(props) {
    var {
      horizontalFill,
      fillOpacity,
      x: x2,
      y: y2,
      width,
      height,
      horizontalPoints,
      horizontal = true
    } = props;
    if (!horizontal || !horizontalFill || !horizontalFill.length) {
      return null;
    }
    var roundedSortedHorizontalPoints = horizontalPoints.map((e) => Math.round(e + y2 - y2)).sort((a2, b) => a2 - b);
    if (y2 !== roundedSortedHorizontalPoints[0]) {
      roundedSortedHorizontalPoints.unshift(0);
    }
    var items = roundedSortedHorizontalPoints.map((entry, i) => {
      var lastStripe = !roundedSortedHorizontalPoints[i + 1];
      var lineHeight = lastStripe ? y2 + height - entry : roundedSortedHorizontalPoints[i + 1] - entry;
      if (lineHeight <= 0) {
        return null;
      }
      var colorIndex = i % horizontalFill.length;
      return /* @__PURE__ */ React__namespace.createElement("rect", {
        key: "react-".concat(i),
        y: entry,
        x: x2,
        height: lineHeight,
        width,
        stroke: "none",
        fill: horizontalFill[colorIndex],
        fillOpacity,
        className: "recharts-cartesian-grid-bg"
      });
    });
    return /* @__PURE__ */ React__namespace.createElement("g", {
      className: "recharts-cartesian-gridstripes-horizontal"
    }, items);
  }
  function VerticalStripes(props) {
    var {
      vertical = true,
      verticalFill,
      fillOpacity,
      x: x2,
      y: y2,
      width,
      height,
      verticalPoints
    } = props;
    if (!vertical || !verticalFill || !verticalFill.length) {
      return null;
    }
    var roundedSortedVerticalPoints = verticalPoints.map((e) => Math.round(e + x2 - x2)).sort((a2, b) => a2 - b);
    if (x2 !== roundedSortedVerticalPoints[0]) {
      roundedSortedVerticalPoints.unshift(0);
    }
    var items = roundedSortedVerticalPoints.map((entry, i) => {
      var lastStripe = !roundedSortedVerticalPoints[i + 1];
      var lineWidth = lastStripe ? x2 + width - entry : roundedSortedVerticalPoints[i + 1] - entry;
      if (lineWidth <= 0) {
        return null;
      }
      var colorIndex = i % verticalFill.length;
      return /* @__PURE__ */ React__namespace.createElement("rect", {
        key: "react-".concat(i),
        x: entry,
        y: y2,
        width: lineWidth,
        height,
        stroke: "none",
        fill: verticalFill[colorIndex],
        fillOpacity,
        className: "recharts-cartesian-grid-bg"
      });
    });
    return /* @__PURE__ */ React__namespace.createElement("g", {
      className: "recharts-cartesian-gridstripes-vertical"
    }, items);
  }
  var defaultVerticalCoordinatesGenerator = (_ref2, syncWithTicks) => {
    var {
      xAxis,
      width,
      height,
      offset
    } = _ref2;
    return getCoordinatesOfGrid(getTicks(_objectSpread$c(_objectSpread$c(_objectSpread$c({}, CartesianAxis.defaultProps), xAxis), {}, {
      ticks: getTicksOfAxis(xAxis, true),
      viewBox: {
        x: 0,
        y: 0,
        width,
        height
      }
    })), offset.left, offset.left + offset.width, syncWithTicks);
  };
  var defaultHorizontalCoordinatesGenerator = (_ref2, syncWithTicks) => {
    var {
      yAxis,
      width,
      height,
      offset
    } = _ref2;
    return getCoordinatesOfGrid(getTicks(_objectSpread$c(_objectSpread$c(_objectSpread$c({}, CartesianAxis.defaultProps), yAxis), {}, {
      ticks: getTicksOfAxis(yAxis, true),
      viewBox: {
        x: 0,
        y: 0,
        width,
        height
      }
    })), offset.top, offset.top + offset.height, syncWithTicks);
  };
  var defaultProps$6 = {
    horizontal: true,
    vertical: true,
    // The ordinates of horizontal grid lines
    horizontalPoints: [],
    // The abscissas of vertical grid lines
    verticalPoints: [],
    stroke: "#ccc",
    fill: "none",
    // The fill of colors of grid lines
    verticalFill: [],
    horizontalFill: [],
    xAxisId: 0,
    yAxisId: 0
  };
  function CartesianGrid(props) {
    var chartWidth = useChartWidth();
    var chartHeight = useChartHeight();
    var offset = useOffsetInternal();
    var propsIncludingDefaults = _objectSpread$c(_objectSpread$c({}, resolveDefaultProps(props, defaultProps$6)), {}, {
      x: isNumber(props.x) ? props.x : offset.left,
      y: isNumber(props.y) ? props.y : offset.top,
      width: isNumber(props.width) ? props.width : offset.width,
      height: isNumber(props.height) ? props.height : offset.height
    });
    var {
      xAxisId,
      yAxisId,
      x: x2,
      y: y2,
      width,
      height,
      syncWithTicks,
      horizontalValues,
      verticalValues
    } = propsIncludingDefaults;
    var isPanorama = useIsPanorama();
    var xAxis = useAppSelector((state) => selectAxisPropsNeededForCartesianGridTicksGenerator(state, "xAxis", xAxisId, isPanorama));
    var yAxis = useAppSelector((state) => selectAxisPropsNeededForCartesianGridTicksGenerator(state, "yAxis", yAxisId, isPanorama));
    if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0 || !isNumber(x2) || x2 !== +x2 || !isNumber(y2) || y2 !== +y2) {
      return null;
    }
    var verticalCoordinatesGenerator = propsIncludingDefaults.verticalCoordinatesGenerator || defaultVerticalCoordinatesGenerator;
    var horizontalCoordinatesGenerator = propsIncludingDefaults.horizontalCoordinatesGenerator || defaultHorizontalCoordinatesGenerator;
    var {
      horizontalPoints,
      verticalPoints
    } = propsIncludingDefaults;
    if ((!horizontalPoints || !horizontalPoints.length) && typeof horizontalCoordinatesGenerator === "function") {
      var isHorizontalValues = horizontalValues && horizontalValues.length;
      var generatorResult = horizontalCoordinatesGenerator({
        yAxis: yAxis ? _objectSpread$c(_objectSpread$c({}, yAxis), {}, {
          ticks: isHorizontalValues ? horizontalValues : yAxis.ticks
        }) : void 0,
        width: chartWidth,
        height: chartHeight,
        offset
      }, isHorizontalValues ? true : syncWithTicks);
      warn(Array.isArray(generatorResult), "horizontalCoordinatesGenerator should return Array but instead it returned [".concat(typeof generatorResult, "]"));
      if (Array.isArray(generatorResult)) {
        horizontalPoints = generatorResult;
      }
    }
    if ((!verticalPoints || !verticalPoints.length) && typeof verticalCoordinatesGenerator === "function") {
      var isVerticalValues = verticalValues && verticalValues.length;
      var _generatorResult = verticalCoordinatesGenerator({
        xAxis: xAxis ? _objectSpread$c(_objectSpread$c({}, xAxis), {}, {
          ticks: isVerticalValues ? verticalValues : xAxis.ticks
        }) : void 0,
        width: chartWidth,
        height: chartHeight,
        offset
      }, isVerticalValues ? true : syncWithTicks);
      warn(Array.isArray(_generatorResult), "verticalCoordinatesGenerator should return Array but instead it returned [".concat(typeof _generatorResult, "]"));
      if (Array.isArray(_generatorResult)) {
        verticalPoints = _generatorResult;
      }
    }
    return /* @__PURE__ */ React__namespace.createElement("g", {
      className: "recharts-cartesian-grid"
    }, /* @__PURE__ */ React__namespace.createElement(Background, {
      fill: propsIncludingDefaults.fill,
      fillOpacity: propsIncludingDefaults.fillOpacity,
      x: propsIncludingDefaults.x,
      y: propsIncludingDefaults.y,
      width: propsIncludingDefaults.width,
      height: propsIncludingDefaults.height,
      ry: propsIncludingDefaults.ry
    }), /* @__PURE__ */ React__namespace.createElement(HorizontalStripes, _extends$f({}, propsIncludingDefaults, {
      horizontalPoints
    })), /* @__PURE__ */ React__namespace.createElement(VerticalStripes, _extends$f({}, propsIncludingDefaults, {
      verticalPoints
    })), /* @__PURE__ */ React__namespace.createElement(HorizontalGridLines, _extends$f({}, propsIncludingDefaults, {
      offset,
      horizontalPoints,
      xAxis,
      yAxis
    })), /* @__PURE__ */ React__namespace.createElement(VerticalGridLines, _extends$f({}, propsIncludingDefaults, {
      offset,
      verticalPoints,
      xAxis,
      yAxis
    })));
  }
  CartesianGrid.displayName = "CartesianGrid";
  var selectXAxisWithScale$2 = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
  var selectXAxisTicks$2 = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
  var selectYAxisWithScale$2 = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
  var selectYAxisTicks$2 = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
  var selectBandSize$1 = createSelector([selectChartLayout, selectXAxisWithScale$2, selectYAxisWithScale$2, selectXAxisTicks$2, selectYAxisTicks$2], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {
    if (isCategoricalAxis(layout, "xAxis")) {
      return getBandSizeOfAxis(xAxis, xAxisTicks, false);
    }
    return getBandSizeOfAxis(yAxis, yAxisTicks, false);
  });
  var pickLineId = (_state, _xAxisId, _yAxisId, _isPanorama, id) => id;
  function isLineSettings(item) {
    return item.type === "line";
  }
  var selectSynchronisedLineSettings = createSelector([selectUnfilteredCartesianItems, pickLineId], (graphicalItems, id) => graphicalItems.filter(isLineSettings).find((x2) => x2.id === id));
  var selectLinePoints = createSelector([selectChartLayout, selectXAxisWithScale$2, selectYAxisWithScale$2, selectXAxisTicks$2, selectYAxisTicks$2, selectSynchronisedLineSettings, selectBandSize$1, selectChartDataWithIndexesIfNotInPanorama], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, lineSettings, bandSize, _ref2) => {
    var {
      chartData,
      dataStartIndex,
      dataEndIndex
    } = _ref2;
    if (lineSettings == null || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null) {
      return void 0;
    }
    var {
      dataKey,
      data
    } = lineSettings;
    var displayedData;
    if (data != null && data.length > 0) {
      displayedData = data;
    } else {
      displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
    }
    if (displayedData == null) {
      return void 0;
    }
    return computeLinePoints({
      layout,
      xAxis,
      yAxis,
      xAxisTicks,
      yAxisTicks,
      dataKey,
      bandSize,
      displayedData
    });
  });
  var _excluded$d = ["id"], _excluded2$5 = ["type", "layout", "connectNulls", "needClip"], _excluded3$1 = ["activeDot", "animateNewValues", "animationBegin", "animationDuration", "animationEasing", "connectNulls", "dot", "hide", "isAnimationActive", "label", "legendType", "xAxisId", "yAxisId", "id"];
  function ownKeys$b(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$b(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$b(Object(t), true).forEach(function(r3) {
        _defineProperty$e(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$e(e, r2, t) {
    return (r2 = _toPropertyKey$e(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$e(t) {
    var i = _toPrimitive$e(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$e(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _objectWithoutProperties$d(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$d(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$d(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function _extends$e() {
    return _extends$e = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$e.apply(null, arguments);
  }
  var computeLegendPayloadFromAreaData$1 = (props) => {
    var {
      dataKey,
      name,
      stroke,
      legendType,
      hide
    } = props;
    return [{
      inactive: hide,
      dataKey,
      type: legendType,
      color: stroke,
      value: getTooltipNameProp(name, dataKey),
      payload: props
    }];
  };
  function getTooltipEntrySettings$6(props) {
    var {
      dataKey,
      data,
      stroke,
      strokeWidth,
      fill: fill2,
      name,
      hide,
      unit: unit2
    } = props;
    return {
      dataDefinedOnItem: data,
      positions: void 0,
      settings: {
        stroke,
        strokeWidth,
        fill: fill2,
        dataKey,
        nameKey: void 0,
        name: getTooltipNameProp(name, dataKey),
        hide,
        type: props.tooltipType,
        color: props.stroke,
        unit: unit2
      }
    };
  }
  var generateSimpleStrokeDasharray = (totalLength, length2) => {
    return "".concat(length2, "px ").concat(totalLength - length2, "px");
  };
  function repeat(lines, count2) {
    var linesUnit = lines.length % 2 !== 0 ? [...lines, 0] : lines;
    var result = [];
    for (var i = 0; i < count2; ++i) {
      result = [...result, ...linesUnit];
    }
    return result;
  }
  var getStrokeDasharray = (length2, totalLength, lines) => {
    var lineLength = lines.reduce((pre, next) => pre + next);
    if (!lineLength) {
      return generateSimpleStrokeDasharray(totalLength, length2);
    }
    var count2 = Math.floor(length2 / lineLength);
    var remainLength = length2 % lineLength;
    var restLength = totalLength - length2;
    var remainLines = [];
    for (var i = 0, sum2 = 0; i < lines.length; sum2 += lines[i], ++i) {
      if (sum2 + lines[i] > remainLength) {
        remainLines = [...lines.slice(0, i), remainLength - sum2];
        break;
      }
    }
    var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];
    return [...repeat(lines, count2), ...remainLines, ...emptyLines].map((line) => "".concat(line, "px")).join(", ");
  };
  function renderDotItem$1(option, props) {
    var dotItem;
    if (/* @__PURE__ */ React__namespace.isValidElement(option)) {
      dotItem = /* @__PURE__ */ React__namespace.cloneElement(option, props);
    } else if (typeof option === "function") {
      dotItem = option(props);
    } else {
      var className = clsx("recharts-line-dot", typeof option !== "boolean" ? option.className : "");
      dotItem = /* @__PURE__ */ React__namespace.createElement(Dot, _extends$e({}, props, {
        className
      }));
    }
    return dotItem;
  }
  function shouldRenderDots$1(points, dot) {
    if (points == null) {
      return false;
    }
    if (dot) {
      return true;
    }
    return points.length === 1;
  }
  function Dots$1(_ref2) {
    var {
      clipPathId,
      points,
      props
    } = _ref2;
    var {
      dot,
      dataKey,
      needClip
    } = props;
    if (!shouldRenderDots$1(points, dot)) {
      return null;
    }
    var {
      id
    } = props, propsWithoutId = _objectWithoutProperties$d(props, _excluded$d);
    var clipDot = isClipDot(dot);
    var lineProps = svgPropertiesNoEvents(propsWithoutId);
    var customDotProps = filterProps(dot, true);
    var dots = points.map((entry, i) => {
      var dotProps = _objectSpread$b(_objectSpread$b(_objectSpread$b({
        key: "dot-".concat(i),
        r: 3
      }, lineProps), customDotProps), {}, {
        index: i,
        cx: entry.x,
        cy: entry.y,
        dataKey,
        value: entry.value,
        payload: entry.payload,
        points
      });
      return renderDotItem$1(dot, dotProps);
    });
    var dotsProps = {
      clipPath: needClip ? "url(#clipPath-".concat(clipDot ? "" : "dots-").concat(clipPathId, ")") : void 0
    };
    return /* @__PURE__ */ React__namespace.createElement(Layer, _extends$e({
      className: "recharts-line-dots",
      key: "dots"
    }, dotsProps), dots);
  }
  function StaticCurve(_ref2) {
    var {
      clipPathId,
      pathRef,
      points,
      strokeDasharray,
      props,
      showLabels
    } = _ref2;
    var {
      type,
      layout,
      connectNulls,
      needClip
    } = props, others = _objectWithoutProperties$d(props, _excluded2$5);
    var curveProps = _objectSpread$b(_objectSpread$b({}, filterProps(others, true)), {}, {
      fill: "none",
      className: "recharts-line-curve",
      clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : void 0,
      points,
      type,
      layout,
      connectNulls,
      strokeDasharray: strokeDasharray !== null && strokeDasharray !== void 0 ? strokeDasharray : props.strokeDasharray
    });
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /* @__PURE__ */ React__namespace.createElement(Curve, _extends$e({}, curveProps, {
      pathRef
    })), /* @__PURE__ */ React__namespace.createElement(Dots$1, {
      points,
      clipPathId,
      props
    }), showLabels && LabelList.renderCallByParent(props, points));
  }
  function getTotalLength(mainCurve) {
    try {
      return mainCurve && mainCurve.getTotalLength && mainCurve.getTotalLength() || 0;
    } catch (_unused) {
      return 0;
    }
  }
  function CurveWithAnimation(_ref3) {
    var {
      clipPathId,
      props,
      pathRef,
      previousPointsRef,
      longestAnimatedLengthRef
    } = _ref3;
    var {
      points,
      strokeDasharray,
      isAnimationActive,
      animationBegin,
      animationDuration,
      animationEasing,
      animateNewValues,
      width,
      height,
      onAnimationEnd,
      onAnimationStart
    } = props;
    var prevPoints = previousPointsRef.current;
    var animationId = useAnimationId$1(props, "recharts-line-");
    var [isAnimating, setIsAnimating] = React.useState(false);
    var handleAnimationEnd = React.useCallback(() => {
      if (typeof onAnimationEnd === "function") {
        onAnimationEnd();
      }
      setIsAnimating(false);
    }, [onAnimationEnd]);
    var handleAnimationStart = React.useCallback(() => {
      if (typeof onAnimationStart === "function") {
        onAnimationStart();
      }
      setIsAnimating(true);
    }, [onAnimationStart]);
    var totalLength = getTotalLength(pathRef.current);
    var startingPoint = longestAnimatedLengthRef.current;
    return /* @__PURE__ */ React__namespace.createElement(JavascriptAnimate, {
      begin: animationBegin,
      duration: animationDuration,
      isActive: isAnimationActive,
      easing: animationEasing,
      onAnimationEnd: handleAnimationEnd,
      onAnimationStart: handleAnimationStart,
      key: animationId
    }, (t) => {
      var lengthInterpolated = interpolate$1(startingPoint, totalLength + startingPoint, t);
      var curLength = Math.min(lengthInterpolated, totalLength);
      var currentStrokeDasharray;
      if (strokeDasharray) {
        var lines = "".concat(strokeDasharray).split(/[,\s]+/gim).map((num) => parseFloat(num));
        currentStrokeDasharray = getStrokeDasharray(curLength, totalLength, lines);
      } else {
        currentStrokeDasharray = generateSimpleStrokeDasharray(totalLength, curLength);
      }
      if (prevPoints) {
        var prevPointsDiffFactor = prevPoints.length / points.length;
        var stepData = t === 1 ? points : points.map((entry, index2) => {
          var prevPointIndex = Math.floor(index2 * prevPointsDiffFactor);
          if (prevPoints[prevPointIndex]) {
            var prev = prevPoints[prevPointIndex];
            return _objectSpread$b(_objectSpread$b({}, entry), {}, {
              x: interpolate$1(prev.x, entry.x, t),
              y: interpolate$1(prev.y, entry.y, t)
            });
          }
          if (animateNewValues) {
            return _objectSpread$b(_objectSpread$b({}, entry), {}, {
              x: interpolate$1(width * 2, entry.x, t),
              y: interpolate$1(height / 2, entry.y, t)
            });
          }
          return _objectSpread$b(_objectSpread$b({}, entry), {}, {
            x: entry.x,
            y: entry.y
          });
        });
        previousPointsRef.current = stepData;
        return /* @__PURE__ */ React__namespace.createElement(StaticCurve, {
          props,
          points: stepData,
          clipPathId,
          pathRef,
          showLabels: !isAnimating,
          strokeDasharray: currentStrokeDasharray
        });
      }
      if (t > 0 && totalLength > 0) {
        previousPointsRef.current = points;
        longestAnimatedLengthRef.current = curLength;
      }
      return /* @__PURE__ */ React__namespace.createElement(StaticCurve, {
        props,
        points,
        clipPathId,
        pathRef,
        showLabels: !isAnimating,
        strokeDasharray: currentStrokeDasharray
      });
    });
  }
  function RenderCurve(_ref4) {
    var {
      clipPathId,
      props
    } = _ref4;
    var {
      points,
      isAnimationActive
    } = props;
    var previousPointsRef = React.useRef(null);
    var longestAnimatedLengthRef = React.useRef(0);
    var pathRef = React.useRef(null);
    var prevPoints = previousPointsRef.current;
    if (isAnimationActive && points && points.length && prevPoints !== points) {
      return /* @__PURE__ */ React__namespace.createElement(CurveWithAnimation, {
        props,
        clipPathId,
        previousPointsRef,
        longestAnimatedLengthRef,
        pathRef
      });
    }
    return /* @__PURE__ */ React__namespace.createElement(StaticCurve, {
      props,
      points,
      clipPathId,
      pathRef,
      showLabels: true
    });
  }
  var errorBarDataPointFormatter$1 = (dataPoint, dataKey) => {
    return {
      x: dataPoint.x,
      y: dataPoint.y,
      value: dataPoint.value,
      // @ts-expect-error getValueByDataKey does not validate the output type
      errorVal: getValueByDataKey(dataPoint.payload, dataKey)
    };
  };
  class LineWithState extends React.Component {
    render() {
      var _filterProps;
      var {
        hide,
        dot,
        points,
        className,
        xAxisId,
        yAxisId,
        top,
        left,
        width,
        height,
        id,
        needClip
      } = this.props;
      if (hide) {
        return null;
      }
      var layerClass = clsx("recharts-line", className);
      var clipPathId = id;
      var {
        r: r2 = 3,
        strokeWidth = 2
      } = (_filterProps = filterProps(dot, false)) !== null && _filterProps !== void 0 ? _filterProps : {
        r: 3,
        strokeWidth: 2
      };
      var clipDot = isClipDot(dot);
      var dotSize = r2 * 2 + strokeWidth;
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(Layer, {
        className: layerClass
      }, needClip && /* @__PURE__ */ React__namespace.createElement("defs", null, /* @__PURE__ */ React__namespace.createElement(GraphicalItemClipPath, {
        clipPathId,
        xAxisId,
        yAxisId
      }), !clipDot && /* @__PURE__ */ React__namespace.createElement("clipPath", {
        id: "clipPath-dots-".concat(clipPathId)
      }, /* @__PURE__ */ React__namespace.createElement("rect", {
        x: left - dotSize / 2,
        y: top - dotSize / 2,
        width: width + dotSize,
        height: height + dotSize
      }))), /* @__PURE__ */ React__namespace.createElement(RenderCurve, {
        props: this.props,
        clipPathId
      }), /* @__PURE__ */ React__namespace.createElement(SetErrorBarContext, {
        xAxisId,
        yAxisId,
        data: points,
        dataPointFormatter: errorBarDataPointFormatter$1,
        errorBarOffset: 0
      }, this.props.children)), /* @__PURE__ */ React__namespace.createElement(ActivePoints, {
        activeDot: this.props.activeDot,
        points,
        mainColor: this.props.stroke,
        itemDataKey: this.props.dataKey
      }));
    }
  }
  var defaultLineProps = {
    activeDot: true,
    animateNewValues: true,
    animationBegin: 0,
    animationDuration: 1500,
    animationEasing: "ease",
    connectNulls: false,
    dot: true,
    fill: "#fff",
    hide: false,
    isAnimationActive: !Global.isSsr,
    label: false,
    legendType: "line",
    stroke: "#3182bd",
    strokeWidth: 1,
    xAxisId: 0,
    yAxisId: 0
  };
  function LineImpl(props) {
    var _resolveDefaultProps = resolveDefaultProps(props, defaultLineProps), {
      activeDot,
      animateNewValues,
      animationBegin,
      animationDuration,
      animationEasing,
      connectNulls,
      dot,
      hide,
      isAnimationActive,
      label,
      legendType,
      xAxisId,
      yAxisId,
      id
    } = _resolveDefaultProps, everythingElse = _objectWithoutProperties$d(_resolveDefaultProps, _excluded3$1);
    var {
      needClip
    } = useNeedsClip(xAxisId, yAxisId);
    var plotArea = usePlotArea();
    var layout = useChartLayout();
    var isPanorama = useIsPanorama();
    var points = useAppSelector((state) => selectLinePoints(state, xAxisId, yAxisId, isPanorama, id));
    if (layout !== "horizontal" && layout !== "vertical" || points == null || plotArea == null) {
      return null;
    }
    var {
      height,
      width,
      x: left,
      y: top
    } = plotArea;
    return /* @__PURE__ */ React__namespace.createElement(LineWithState, _extends$e({}, everythingElse, {
      id,
      connectNulls,
      dot,
      activeDot,
      animateNewValues,
      animationBegin,
      animationDuration,
      animationEasing,
      isAnimationActive,
      hide,
      label,
      legendType,
      xAxisId,
      yAxisId,
      points,
      layout,
      height,
      width,
      left,
      top,
      needClip
    }));
  }
  function computeLinePoints(_ref5) {
    var {
      layout,
      xAxis,
      yAxis,
      xAxisTicks,
      yAxisTicks,
      dataKey,
      bandSize,
      displayedData
    } = _ref5;
    return displayedData.map((entry, index2) => {
      var value = getValueByDataKey(entry, dataKey);
      if (layout === "horizontal") {
        var _x = getCateCoordinateOfLine({
          axis: xAxis,
          ticks: xAxisTicks,
          bandSize,
          entry,
          index: index2
        });
        var _y = isNullish(value) ? null : yAxis.scale(value);
        return {
          x: _x,
          y: _y,
          value,
          payload: entry
        };
      }
      var x2 = isNullish(value) ? null : xAxis.scale(value);
      var y2 = getCateCoordinateOfLine({
        axis: yAxis,
        ticks: yAxisTicks,
        bandSize,
        entry,
        index: index2
      });
      if (x2 == null || y2 == null) {
        return null;
      }
      return {
        x: x2,
        y: y2,
        value,
        payload: entry
      };
    }).filter(Boolean);
  }
  function Line(outsideProps) {
    var props = resolveDefaultProps(outsideProps, defaultLineProps);
    var isPanorama = useIsPanorama();
    return /* @__PURE__ */ React__namespace.createElement(RegisterGraphicalItemId, {
      id: props.id,
      type: "line"
    }, (id) => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(SetLegendPayload, {
      legendPayload: computeLegendPayloadFromAreaData$1(props)
    }), /* @__PURE__ */ React__namespace.createElement(SetTooltipEntrySettings, {
      fn: getTooltipEntrySettings$6,
      args: props
    }), /* @__PURE__ */ React__namespace.createElement(SetCartesianGraphicalItem, {
      type: "line",
      id,
      data: props.data,
      xAxisId: props.xAxisId,
      yAxisId: props.yAxisId,
      zAxisId: 0,
      dataKey: props.dataKey,
      hide: props.hide,
      isPanorama
    }), /* @__PURE__ */ React__namespace.createElement(LineImpl, _extends$e({}, props, {
      id
    }))));
  }
  Line.displayName = "Line";
  var selectXAxisWithScale$1 = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
  var selectXAxisTicks$1 = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
  var selectYAxisWithScale$1 = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
  var selectYAxisTicks$1 = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
  var selectBandSize = createSelector([selectChartLayout, selectXAxisWithScale$1, selectYAxisWithScale$1, selectXAxisTicks$1, selectYAxisTicks$1], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {
    if (isCategoricalAxis(layout, "xAxis")) {
      return getBandSizeOfAxis(xAxis, xAxisTicks, false);
    }
    return getBandSizeOfAxis(yAxis, yAxisTicks, false);
  });
  var pickAreaId = (_state, _xAxisId, _yAxisId, _isPanorama, id) => id;
  var selectSynchronisedAreaSettings = createSelector([selectUnfilteredCartesianItems, pickAreaId], (graphicalItems, id) => graphicalItems.filter((item) => item.type === "area").find((item) => item.id === id));
  var selectGraphicalItemStackedData = (state, xAxisId, yAxisId, isPanorama, id) => {
    var _stackGroups$stackId;
    var areaSettings = selectSynchronisedAreaSettings(state, xAxisId, yAxisId, isPanorama, id);
    if (areaSettings == null) {
      return void 0;
    }
    var layout = selectChartLayout(state);
    var isXAxisCategorical = isCategoricalAxis(layout, "xAxis");
    var stackGroups;
    if (isXAxisCategorical) {
      stackGroups = selectStackGroups$1(state, "yAxis", yAxisId, isPanorama);
    } else {
      stackGroups = selectStackGroups$1(state, "xAxis", xAxisId, isPanorama);
    }
    if (stackGroups == null) {
      return void 0;
    }
    var {
      stackId
    } = areaSettings;
    var stackSeriesIdentifier = getStackSeriesIdentifier(areaSettings);
    if (stackId == null || stackSeriesIdentifier == null) {
      return void 0;
    }
    var groups2 = (_stackGroups$stackId = stackGroups[stackId]) === null || _stackGroups$stackId === void 0 ? void 0 : _stackGroups$stackId.stackedData;
    return groups2 === null || groups2 === void 0 ? void 0 : groups2.find((v) => v.key === stackSeriesIdentifier);
  };
  var selectArea = createSelector([selectChartLayout, selectXAxisWithScale$1, selectYAxisWithScale$1, selectXAxisTicks$1, selectYAxisTicks$1, selectGraphicalItemStackedData, selectChartDataWithIndexesIfNotInPanorama, selectBandSize, selectSynchronisedAreaSettings], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, stackedData, _ref2, bandSize, areaSettings) => {
    var {
      chartData,
      dataStartIndex,
      dataEndIndex
    } = _ref2;
    if (areaSettings == null || layout !== "horizontal" && layout !== "vertical" || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null) {
      return void 0;
    }
    var {
      data
    } = areaSettings;
    var displayedData;
    if (data && data.length > 0) {
      displayedData = data;
    } else {
      displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
    }
    if (displayedData == null) {
      return void 0;
    }
    var chartBaseValue = void 0;
    return computeArea({
      layout,
      xAxis,
      yAxis,
      xAxisTicks,
      yAxisTicks,
      dataStartIndex,
      areaSettings,
      stackedData,
      displayedData,
      chartBaseValue,
      bandSize
    });
  });
  var _excluded$c = ["id"], _excluded2$4 = ["activeDot", "animationBegin", "animationDuration", "animationEasing", "connectNulls", "dot", "fill", "fillOpacity", "hide", "isAnimationActive", "legendType", "stroke", "xAxisId", "yAxisId"];
  function _objectWithoutProperties$c(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$c(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$c(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function ownKeys$a(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$a(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$a(Object(t), true).forEach(function(r3) {
        _defineProperty$d(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$d(e, r2, t) {
    return (r2 = _toPropertyKey$d(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$d(t) {
    var i = _toPrimitive$d(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$d(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _extends$d() {
    return _extends$d = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$d.apply(null, arguments);
  }
  function getLegendItemColor(stroke, fill2) {
    return stroke && stroke !== "none" ? stroke : fill2;
  }
  var computeLegendPayloadFromAreaData = (props) => {
    var {
      dataKey,
      name,
      stroke,
      fill: fill2,
      legendType,
      hide
    } = props;
    return [{
      inactive: hide,
      dataKey,
      type: legendType,
      color: getLegendItemColor(stroke, fill2),
      value: getTooltipNameProp(name, dataKey),
      payload: props
    }];
  };
  function getTooltipEntrySettings$5(props) {
    var {
      dataKey,
      data,
      stroke,
      strokeWidth,
      fill: fill2,
      name,
      hide,
      unit: unit2
    } = props;
    return {
      dataDefinedOnItem: data,
      positions: void 0,
      settings: {
        stroke,
        strokeWidth,
        fill: fill2,
        dataKey,
        nameKey: void 0,
        name: getTooltipNameProp(name, dataKey),
        hide,
        type: props.tooltipType,
        color: getLegendItemColor(stroke, fill2),
        unit: unit2
      }
    };
  }
  var renderDotItem = (option, props) => {
    var dotItem;
    if (/* @__PURE__ */ React__namespace.isValidElement(option)) {
      dotItem = /* @__PURE__ */ React__namespace.cloneElement(option, props);
    } else if (typeof option === "function") {
      dotItem = option(props);
    } else {
      var className = clsx("recharts-area-dot", typeof option !== "boolean" ? option.className : "");
      dotItem = /* @__PURE__ */ React__namespace.createElement(Dot, _extends$d({}, props, {
        className
      }));
    }
    return dotItem;
  };
  function shouldRenderDots(points, dot) {
    if (points == null) {
      return false;
    }
    if (dot) {
      return true;
    }
    return points.length === 1;
  }
  function Dots(_ref2) {
    var {
      clipPathId,
      points,
      props
    } = _ref2;
    var {
      needClip,
      dot,
      dataKey
    } = props;
    if (!shouldRenderDots(points, dot)) {
      return null;
    }
    var clipDot = isClipDot(dot);
    var areaProps = svgPropertiesNoEvents(props);
    var customDotProps = filterProps(dot, true);
    var dots = points.map((entry, i) => {
      var dotProps = _objectSpread$a(_objectSpread$a(_objectSpread$a({
        key: "dot-".concat(i),
        r: 3
      }, areaProps), customDotProps), {}, {
        index: i,
        cx: entry.x,
        cy: entry.y,
        dataKey,
        value: entry.value,
        payload: entry.payload,
        points
      });
      return renderDotItem(dot, dotProps);
    });
    var dotsProps = {
      clipPath: needClip ? "url(#clipPath-".concat(clipDot ? "" : "dots-").concat(clipPathId, ")") : void 0
    };
    return /* @__PURE__ */ React__namespace.createElement(Layer, _extends$d({
      className: "recharts-area-dots"
    }, dotsProps), dots);
  }
  function StaticArea(_ref2) {
    var {
      points,
      baseLine,
      needClip,
      clipPathId,
      props,
      showLabels
    } = _ref2;
    var {
      layout,
      type,
      stroke,
      connectNulls,
      isRange
    } = props;
    var {
      id
    } = props, propsWithoutId = _objectWithoutProperties$c(props, _excluded$c);
    var allOtherProps = svgPropertiesNoEvents(propsWithoutId);
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /* @__PURE__ */ React__namespace.createElement(Layer, {
      clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : void 0
    }, /* @__PURE__ */ React__namespace.createElement(Curve, _extends$d({}, allOtherProps, {
      id,
      points,
      connectNulls,
      type,
      baseLine,
      layout,
      stroke: "none",
      className: "recharts-area-area"
    })), stroke !== "none" && /* @__PURE__ */ React__namespace.createElement(Curve, _extends$d({}, allOtherProps, {
      className: "recharts-area-curve",
      layout,
      type,
      connectNulls,
      fill: "none",
      points
    })), stroke !== "none" && isRange && /* @__PURE__ */ React__namespace.createElement(Curve, _extends$d({}, allOtherProps, {
      className: "recharts-area-curve",
      layout,
      type,
      connectNulls,
      fill: "none",
      points: baseLine
    }))), /* @__PURE__ */ React__namespace.createElement(Dots, {
      points,
      props: propsWithoutId,
      clipPathId
    }), showLabels && LabelList.renderCallByParent(propsWithoutId, points));
  }
  function VerticalRect(_ref3) {
    var {
      alpha: alpha2,
      baseLine,
      points,
      strokeWidth
    } = _ref3;
    var startY = points[0].y;
    var endY = points[points.length - 1].y;
    if (!isWellBehavedNumber(startY) || !isWellBehavedNumber(endY)) {
      return null;
    }
    var height = alpha2 * Math.abs(startY - endY);
    var maxX = Math.max(...points.map((entry) => entry.x || 0));
    if (isNumber(baseLine)) {
      maxX = Math.max(baseLine, maxX);
    } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {
      maxX = Math.max(...baseLine.map((entry) => entry.x || 0), maxX);
    }
    if (isNumber(maxX)) {
      return /* @__PURE__ */ React__namespace.createElement("rect", {
        x: 0,
        y: startY < endY ? startY : startY - height,
        width: maxX + (strokeWidth ? parseInt("".concat(strokeWidth), 10) : 1),
        height: Math.floor(height)
      });
    }
    return null;
  }
  function HorizontalRect(_ref4) {
    var {
      alpha: alpha2,
      baseLine,
      points,
      strokeWidth
    } = _ref4;
    var startX = points[0].x;
    var endX = points[points.length - 1].x;
    if (!isWellBehavedNumber(startX) || !isWellBehavedNumber(endX)) {
      return null;
    }
    var width = alpha2 * Math.abs(startX - endX);
    var maxY = Math.max(...points.map((entry) => entry.y || 0));
    if (isNumber(baseLine)) {
      maxY = Math.max(baseLine, maxY);
    } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {
      maxY = Math.max(...baseLine.map((entry) => entry.y || 0), maxY);
    }
    if (isNumber(maxY)) {
      return /* @__PURE__ */ React__namespace.createElement("rect", {
        x: startX < endX ? startX : startX - width,
        y: 0,
        width,
        height: Math.floor(maxY + (strokeWidth ? parseInt("".concat(strokeWidth), 10) : 1))
      });
    }
    return null;
  }
  function ClipRect(_ref5) {
    var {
      alpha: alpha2,
      layout,
      points,
      baseLine,
      strokeWidth
    } = _ref5;
    if (layout === "vertical") {
      return /* @__PURE__ */ React__namespace.createElement(VerticalRect, {
        alpha: alpha2,
        points,
        baseLine,
        strokeWidth
      });
    }
    return /* @__PURE__ */ React__namespace.createElement(HorizontalRect, {
      alpha: alpha2,
      points,
      baseLine,
      strokeWidth
    });
  }
  function AreaWithAnimation(_ref6) {
    var {
      needClip,
      clipPathId,
      props,
      previousPointsRef,
      previousBaselineRef
    } = _ref6;
    var {
      points,
      baseLine,
      isAnimationActive,
      animationBegin,
      animationDuration,
      animationEasing,
      onAnimationStart,
      onAnimationEnd
    } = props;
    var animationId = useAnimationId$1(props, "recharts-area-");
    var [isAnimating, setIsAnimating] = React.useState(true);
    var handleAnimationEnd = React.useCallback(() => {
      if (typeof onAnimationEnd === "function") {
        onAnimationEnd();
      }
      setIsAnimating(false);
    }, [onAnimationEnd]);
    var handleAnimationStart = React.useCallback(() => {
      if (typeof onAnimationStart === "function") {
        onAnimationStart();
      }
      setIsAnimating(true);
    }, [onAnimationStart]);
    var prevPoints = previousPointsRef.current;
    var prevBaseLine = previousBaselineRef.current;
    return /* @__PURE__ */ React__namespace.createElement(JavascriptAnimate, {
      begin: animationBegin,
      duration: animationDuration,
      isActive: isAnimationActive,
      easing: animationEasing,
      onAnimationEnd: handleAnimationEnd,
      onAnimationStart: handleAnimationStart,
      key: animationId
    }, (t) => {
      if (prevPoints) {
        var prevPointsDiffFactor = prevPoints.length / points.length;
        var stepPoints = (
          /*
           * Here it is important that at the very end of the animation, on the last frame,
           * we render the original points without any interpolation.
           * This is needed because the code above is checking for reference equality to decide if the animation should run
           * and if we create a new array instance (even if the numbers were the same)
           * then we would break animations.
           */
          t === 1 ? points : points.map((entry, index2) => {
            var prevPointIndex = Math.floor(index2 * prevPointsDiffFactor);
            if (prevPoints[prevPointIndex]) {
              var prev = prevPoints[prevPointIndex];
              return _objectSpread$a(_objectSpread$a({}, entry), {}, {
                x: interpolate$1(prev.x, entry.x, t),
                y: interpolate$1(prev.y, entry.y, t)
              });
            }
            return entry;
          })
        );
        var stepBaseLine;
        if (isNumber(baseLine)) {
          stepBaseLine = interpolate$1(prevBaseLine, baseLine, t);
        } else if (isNullish(baseLine) || isNan(baseLine)) {
          stepBaseLine = interpolate$1(prevBaseLine, 0, t);
        } else {
          stepBaseLine = baseLine.map((entry, index2) => {
            var prevPointIndex = Math.floor(index2 * prevPointsDiffFactor);
            if (Array.isArray(prevBaseLine) && prevBaseLine[prevPointIndex]) {
              var prev = prevBaseLine[prevPointIndex];
              return _objectSpread$a(_objectSpread$a({}, entry), {}, {
                x: interpolate$1(prev.x, entry.x, t),
                y: interpolate$1(prev.y, entry.y, t)
              });
            }
            return entry;
          });
        }
        if (t > 0) {
          previousPointsRef.current = stepPoints;
          previousBaselineRef.current = stepBaseLine;
        }
        return /* @__PURE__ */ React__namespace.createElement(StaticArea, {
          points: stepPoints,
          baseLine: stepBaseLine,
          needClip,
          clipPathId,
          props,
          showLabels: !isAnimating
        });
      }
      if (t > 0) {
        previousPointsRef.current = points;
        previousBaselineRef.current = baseLine;
      }
      return /* @__PURE__ */ React__namespace.createElement(Layer, null, /* @__PURE__ */ React__namespace.createElement("defs", null, /* @__PURE__ */ React__namespace.createElement("clipPath", {
        id: "animationClipPath-".concat(clipPathId)
      }, /* @__PURE__ */ React__namespace.createElement(ClipRect, {
        alpha: t,
        points,
        baseLine,
        layout: props.layout,
        strokeWidth: props.strokeWidth
      }))), /* @__PURE__ */ React__namespace.createElement(Layer, {
        clipPath: "url(#animationClipPath-".concat(clipPathId, ")")
      }, /* @__PURE__ */ React__namespace.createElement(StaticArea, {
        points,
        baseLine,
        needClip,
        clipPathId,
        props,
        showLabels: true
      })));
    });
  }
  function RenderArea(_ref7) {
    var {
      needClip,
      clipPathId,
      props
    } = _ref7;
    var {
      points,
      baseLine,
      isAnimationActive
    } = props;
    var previousPointsRef = React.useRef(null);
    var previousBaselineRef = React.useRef();
    var prevPoints = previousPointsRef.current;
    var prevBaseLine = previousBaselineRef.current;
    if (isAnimationActive && /*
     * Here it's important that we unmount of AreaWithAnimation in case points are undefined
     * - this will make sure to interrupt the animation if it's running.
     * We still get to keep the last shape of the animation in the refs above.
     */
    points && points.length && (prevPoints !== points || prevBaseLine !== baseLine)) {
      return /* @__PURE__ */ React__namespace.createElement(AreaWithAnimation, {
        needClip,
        clipPathId,
        props,
        previousPointsRef,
        previousBaselineRef
      });
    }
    return /* @__PURE__ */ React__namespace.createElement(StaticArea, {
      points,
      baseLine,
      needClip,
      clipPathId,
      props,
      showLabels: true
    });
  }
  class AreaWithState extends React.PureComponent {
    render() {
      var _filterProps;
      var {
        hide,
        dot,
        points,
        className,
        top,
        left,
        needClip,
        xAxisId,
        yAxisId,
        width,
        height,
        id,
        baseLine
      } = this.props;
      if (hide) {
        return null;
      }
      var layerClass = clsx("recharts-area", className);
      var clipPathId = id;
      var {
        r: r2 = 3,
        strokeWidth = 2
      } = (_filterProps = filterProps(dot, false)) !== null && _filterProps !== void 0 ? _filterProps : {
        r: 3,
        strokeWidth: 2
      };
      var clipDot = isClipDot(dot);
      var dotSize = r2 * 2 + strokeWidth;
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(Layer, {
        className: layerClass
      }, needClip && /* @__PURE__ */ React__namespace.createElement("defs", null, /* @__PURE__ */ React__namespace.createElement(GraphicalItemClipPath, {
        clipPathId,
        xAxisId,
        yAxisId
      }), !clipDot && /* @__PURE__ */ React__namespace.createElement("clipPath", {
        id: "clipPath-dots-".concat(clipPathId)
      }, /* @__PURE__ */ React__namespace.createElement("rect", {
        x: left - dotSize / 2,
        y: top - dotSize / 2,
        width: width + dotSize,
        height: height + dotSize
      }))), /* @__PURE__ */ React__namespace.createElement(RenderArea, {
        needClip,
        clipPathId,
        props: this.props
      })), /* @__PURE__ */ React__namespace.createElement(ActivePoints, {
        points,
        mainColor: getLegendItemColor(this.props.stroke, this.props.fill),
        itemDataKey: this.props.dataKey,
        activeDot: this.props.activeDot
      }), this.props.isRange && Array.isArray(baseLine) && /* @__PURE__ */ React__namespace.createElement(ActivePoints, {
        points: baseLine,
        mainColor: getLegendItemColor(this.props.stroke, this.props.fill),
        itemDataKey: this.props.dataKey,
        activeDot: this.props.activeDot
      }));
    }
  }
  var defaultAreaProps = {
    activeDot: true,
    animationBegin: 0,
    animationDuration: 1500,
    animationEasing: "ease",
    connectNulls: false,
    dot: false,
    fill: "#3182bd",
    fillOpacity: 0.6,
    hide: false,
    isAnimationActive: !Global.isSsr,
    legendType: "line",
    stroke: "#3182bd",
    xAxisId: 0,
    yAxisId: 0
  };
  function AreaImpl(props) {
    var _useAppSelector;
    var _resolveDefaultProps = resolveDefaultProps(props, defaultAreaProps), {
      activeDot,
      animationBegin,
      animationDuration,
      animationEasing,
      connectNulls,
      dot,
      fill: fill2,
      fillOpacity,
      hide,
      isAnimationActive,
      legendType,
      stroke,
      xAxisId,
      yAxisId
    } = _resolveDefaultProps, everythingElse = _objectWithoutProperties$c(_resolveDefaultProps, _excluded2$4);
    var layout = useChartLayout();
    var chartName = useChartName();
    var {
      needClip
    } = useNeedsClip(xAxisId, yAxisId);
    var isPanorama = useIsPanorama();
    var {
      points,
      isRange,
      baseLine
    } = (_useAppSelector = useAppSelector((state) => selectArea(state, xAxisId, yAxisId, isPanorama, props.id))) !== null && _useAppSelector !== void 0 ? _useAppSelector : {};
    var plotArea = usePlotArea();
    if (layout !== "horizontal" && layout !== "vertical" || plotArea == null) {
      return null;
    }
    if (chartName !== "AreaChart" && chartName !== "ComposedChart") {
      return null;
    }
    var {
      height,
      width,
      x: left,
      y: top
    } = plotArea;
    if (!points || !points.length) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(AreaWithState, _extends$d({}, everythingElse, {
      activeDot,
      animationBegin,
      animationDuration,
      animationEasing,
      baseLine,
      connectNulls,
      dot,
      fill: fill2,
      fillOpacity,
      height,
      hide,
      layout,
      isAnimationActive,
      isRange,
      legendType,
      needClip,
      points,
      stroke,
      width,
      left,
      top,
      xAxisId,
      yAxisId
    }));
  }
  var getBaseValue = (layout, chartBaseValue, itemBaseValue, xAxis, yAxis) => {
    var baseValue = itemBaseValue !== null && itemBaseValue !== void 0 ? itemBaseValue : chartBaseValue;
    if (isNumber(baseValue)) {
      return baseValue;
    }
    var numericAxis = layout === "horizontal" ? yAxis : xAxis;
    var domain = numericAxis.scale.domain();
    if (numericAxis.type === "number") {
      var domainMax = Math.max(domain[0], domain[1]);
      var domainMin = Math.min(domain[0], domain[1]);
      if (baseValue === "dataMin") {
        return domainMin;
      }
      if (baseValue === "dataMax") {
        return domainMax;
      }
      return domainMax < 0 ? domainMax : Math.max(Math.min(domain[0], domain[1]), 0);
    }
    if (baseValue === "dataMin") {
      return domain[0];
    }
    if (baseValue === "dataMax") {
      return domain[1];
    }
    return domain[0];
  };
  function computeArea(_ref8) {
    var {
      areaSettings: {
        connectNulls,
        baseValue: itemBaseValue,
        dataKey
      },
      stackedData,
      layout,
      chartBaseValue,
      xAxis,
      yAxis,
      displayedData,
      dataStartIndex,
      xAxisTicks,
      yAxisTicks,
      bandSize
    } = _ref8;
    var hasStack = stackedData && stackedData.length;
    var baseValue = getBaseValue(layout, chartBaseValue, itemBaseValue, xAxis, yAxis);
    var isHorizontalLayout = layout === "horizontal";
    var isRange = false;
    var points = displayedData.map((entry, index2) => {
      var value;
      if (hasStack) {
        value = stackedData[dataStartIndex + index2];
      } else {
        value = getValueByDataKey(entry, dataKey);
        if (!Array.isArray(value)) {
          value = [baseValue, value];
        } else {
          isRange = true;
        }
      }
      var isBreakPoint = value[1] == null || hasStack && !connectNulls && getValueByDataKey(entry, dataKey) == null;
      if (isHorizontalLayout) {
        return {
          // @ts-expect-error getCateCoordinateOfLine expects chart data to be an object, we allow unknown
          x: getCateCoordinateOfLine({
            axis: xAxis,
            ticks: xAxisTicks,
            bandSize,
            entry,
            index: index2
          }),
          y: isBreakPoint ? null : yAxis.scale(value[1]),
          value,
          payload: entry
        };
      }
      return {
        x: isBreakPoint ? null : xAxis.scale(value[1]),
        // @ts-expect-error getCateCoordinateOfLine expects chart data to be an object, we allow unknown
        y: getCateCoordinateOfLine({
          axis: yAxis,
          ticks: yAxisTicks,
          bandSize,
          entry,
          index: index2
        }),
        value,
        payload: entry
      };
    });
    var baseLine;
    if (hasStack || isRange) {
      baseLine = points.map((entry) => {
        var x2 = Array.isArray(entry.value) ? entry.value[0] : null;
        if (isHorizontalLayout) {
          return {
            x: entry.x,
            y: x2 != null && entry.y != null ? yAxis.scale(x2) : null,
            payload: entry.payload
          };
        }
        return {
          x: x2 != null ? xAxis.scale(x2) : null,
          y: entry.y,
          payload: entry.payload
        };
      });
    } else {
      baseLine = isHorizontalLayout ? yAxis.scale(baseValue) : xAxis.scale(baseValue);
    }
    return {
      points,
      baseLine,
      isRange
    };
  }
  function Area(outsideProps) {
    var props = resolveDefaultProps(outsideProps, defaultAreaProps);
    var isPanorama = useIsPanorama();
    return /* @__PURE__ */ React__namespace.createElement(RegisterGraphicalItemId, {
      id: props.id,
      type: "area"
    }, (id) => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(SetLegendPayload, {
      legendPayload: computeLegendPayloadFromAreaData(props)
    }), /* @__PURE__ */ React__namespace.createElement(SetTooltipEntrySettings, {
      fn: getTooltipEntrySettings$5,
      args: props
    }), /* @__PURE__ */ React__namespace.createElement(SetCartesianGraphicalItem, {
      type: "area",
      id,
      data: props.data,
      dataKey: props.dataKey,
      xAxisId: props.xAxisId,
      yAxisId: props.yAxisId,
      zAxisId: 0,
      stackId: getNormalizedStackId(props.stackId),
      hide: props.hide,
      barSize: void 0,
      baseValue: props.baseValue,
      isPanorama,
      connectNulls: props.connectNulls
    }), /* @__PURE__ */ React__namespace.createElement(AreaImpl, _extends$d({}, props, {
      id
    }))));
  }
  Area.displayName = "Area";
  function ownKeys$9(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$9(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$9(Object(t), true).forEach(function(r3) {
        _defineProperty$c(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$c(e, r2, t) {
    return (r2 = _toPropertyKey$c(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$c(t) {
    var i = _toPrimitive$c(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$c(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var initialState$1 = {
    xAxis: {},
    yAxis: {},
    zAxis: {}
  };
  var cartesianAxisSlice = createSlice({
    name: "cartesianAxis",
    initialState: initialState$1,
    reducers: {
      addXAxis(state, action) {
        state.xAxis[action.payload.id] = castDraft(action.payload);
      },
      removeXAxis(state, action) {
        delete state.xAxis[action.payload.id];
      },
      addYAxis(state, action) {
        state.yAxis[action.payload.id] = castDraft(action.payload);
      },
      removeYAxis(state, action) {
        delete state.yAxis[action.payload.id];
      },
      addZAxis(state, action) {
        state.zAxis[action.payload.id] = castDraft(action.payload);
      },
      removeZAxis(state, action) {
        delete state.zAxis[action.payload.id];
      },
      updateYAxisWidth(state, action) {
        var {
          id,
          width
        } = action.payload;
        if (state.yAxis[id]) {
          state.yAxis[id] = _objectSpread$9(_objectSpread$9({}, state.yAxis[id]), {}, {
            width
          });
        }
      }
    }
  });
  var {
    addXAxis,
    removeXAxis,
    addYAxis,
    removeYAxis,
    addZAxis,
    removeZAxis,
    updateYAxisWidth
  } = cartesianAxisSlice.actions;
  var cartesianAxisReducer = cartesianAxisSlice.reducer;
  function _defineProperty$b(e, r2, t) {
    return (r2 = _toPropertyKey$b(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$b(t) {
    var i = _toPrimitive$b(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$b(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function SetZAxisSettings(settings) {
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(addZAxis(settings));
      return () => {
        dispatch(removeZAxis(settings));
      };
    }, [settings, dispatch]);
    return null;
  }
  class ZAxis extends React.Component {
    render() {
      return /* @__PURE__ */ React__namespace.createElement(SetZAxisSettings, {
        domain: this.props.domain,
        id: this.props.zAxisId,
        dataKey: this.props.dataKey,
        name: this.props.name,
        unit: this.props.unit,
        range: this.props.range,
        scale: this.props.scale,
        type: this.props.type,
        allowDuplicatedCategory: implicitZAxis.allowDuplicatedCategory,
        allowDataOverflow: implicitZAxis.allowDataOverflow,
        reversed: implicitZAxis.reversed,
        includeHidden: implicitZAxis.includeHidden
      });
    }
  }
  _defineProperty$b(ZAxis, "displayName", "ZAxis");
  _defineProperty$b(ZAxis, "defaultProps", {
    zAxisId: 0,
    range: implicitZAxis.range,
    scale: implicitZAxis.scale,
    type: implicitZAxis.type
  });
  var _excluded$b = ["option", "isActive"];
  function _extends$c() {
    return _extends$c = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$c.apply(null, arguments);
  }
  function _objectWithoutProperties$b(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$b(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$b(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function ScatterSymbol(_ref2) {
    var {
      option,
      isActive
    } = _ref2, props = _objectWithoutProperties$b(_ref2, _excluded$b);
    if (typeof option === "string") {
      return /* @__PURE__ */ React__namespace.createElement(Shape, _extends$c({
        option: /* @__PURE__ */ React__namespace.createElement(Symbols, _extends$c({
          type: option
        }, props)),
        isActive,
        shapeType: "symbols"
      }, props));
    }
    return /* @__PURE__ */ React__namespace.createElement(Shape, _extends$c({
      option,
      isActive,
      shapeType: "symbols"
    }, props));
  }
  var selectXAxisWithScale = (state, xAxisId, _yAxisId, _zAxisId, _id, _cells, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
  var selectXAxisTicks = (state, xAxisId, _yAxisId, _zAxisId, _id, _cells, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
  var selectYAxisWithScale = (state, _xAxisId, yAxisId, _zAxisId, _id, _cells, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
  var selectYAxisTicks = (state, _xAxisId, yAxisId, _zAxisId, _id, _cells, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
  var selectZAxis = (state, _xAxisId, _yAxisId, zAxisId) => selectZAxisWithScale(state, "zAxis", zAxisId, false);
  var pickScatterId = (_state, _xAxisId, _yAxisId, _zAxisId, id) => id;
  var pickCells = (_state, _xAxisId, _yAxisId, _zAxisId, _id, cells) => cells;
  var scatterChartDataSelector = (state, xAxisId, yAxisId, _zAxisId, _id, _cells, isPanorama) => selectChartDataWithIndexesIfNotInPanorama(state, xAxisId, yAxisId, isPanorama);
  var selectSynchronisedScatterSettings = createSelector([selectUnfilteredCartesianItems, pickScatterId], (graphicalItems, id) => {
    return graphicalItems.filter((item) => item.type === "scatter").find((item) => item.id === id);
  });
  var selectScatterPoints = createSelector([scatterChartDataSelector, selectXAxisWithScale, selectXAxisTicks, selectYAxisWithScale, selectYAxisTicks, selectZAxis, selectSynchronisedScatterSettings, pickCells], (_ref2, xAxis, xAxisTicks, yAxis, yAxisTicks, zAxis, scatterSettings, cells) => {
    var {
      chartData,
      dataStartIndex,
      dataEndIndex
    } = _ref2;
    if (scatterSettings == null) {
      return void 0;
    }
    var displayedData;
    if ((scatterSettings === null || scatterSettings === void 0 ? void 0 : scatterSettings.data) != null && scatterSettings.data.length > 0) {
      displayedData = scatterSettings.data;
    } else {
      displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
    }
    if (displayedData == null || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || (xAxisTicks === null || xAxisTicks === void 0 ? void 0 : xAxisTicks.length) === 0 || (yAxisTicks === null || yAxisTicks === void 0 ? void 0 : yAxisTicks.length) === 0) {
      return void 0;
    }
    return computeScatterPoints({
      displayedData,
      xAxis,
      yAxis,
      zAxis,
      scatterSettings,
      xAxisTicks,
      yAxisTicks,
      cells
    });
  });
  var _excluded$a = ["onMouseEnter", "onClick", "onMouseLeave"], _excluded2$3 = ["id"], _excluded3 = ["animationBegin", "animationDuration", "animationEasing", "hide", "isAnimationActive", "legendType", "lineJointType", "lineType", "shape", "xAxisId", "yAxisId", "zAxisId"];
  function _objectWithoutProperties$a(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$a(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$a(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function _extends$b() {
    return _extends$b = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$b.apply(null, arguments);
  }
  function ownKeys$8(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$8(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$8(Object(t), true).forEach(function(r3) {
        _defineProperty$a(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$a(e, r2, t) {
    return (r2 = _toPropertyKey$a(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$a(t) {
    var i = _toPrimitive$a(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$a(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var computeLegendPayloadFromScatterProps = (props) => {
    var {
      dataKey,
      name,
      fill: fill2,
      legendType,
      hide
    } = props;
    return [{
      inactive: hide,
      dataKey,
      type: legendType,
      color: fill2,
      value: getTooltipNameProp(name, dataKey),
      payload: props
    }];
  };
  function ScatterLine(_ref2) {
    var {
      points,
      props
    } = _ref2;
    var {
      line,
      lineType,
      lineJointType
    } = props;
    if (!line) {
      return null;
    }
    var scatterProps = svgPropertiesNoEvents(props);
    var customLineProps = filterProps(line, false);
    var linePoints, lineItem;
    if (lineType === "joint") {
      linePoints = points.map((entry) => ({
        x: entry.cx,
        y: entry.cy
      }));
    } else if (lineType === "fitting") {
      var {
        xmin,
        xmax,
        a: a2,
        b
      } = getLinearRegression(points);
      var linearExp = (x2) => a2 * x2 + b;
      linePoints = [{
        x: xmin,
        y: linearExp(xmin)
      }, {
        x: xmax,
        y: linearExp(xmax)
      }];
    }
    var lineProps = _objectSpread$8(_objectSpread$8(_objectSpread$8({}, scatterProps), {}, {
      fill: "none",
      stroke: scatterProps && scatterProps.fill
    }, customLineProps), {}, {
      points: linePoints
    });
    if (/* @__PURE__ */ React__namespace.isValidElement(line)) {
      lineItem = /* @__PURE__ */ React__namespace.cloneElement(line, lineProps);
    } else if (typeof line === "function") {
      lineItem = line(lineProps);
    } else {
      lineItem = /* @__PURE__ */ React__namespace.createElement(Curve, _extends$b({}, lineProps, {
        type: lineJointType
      }));
    }
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: "recharts-scatter-line",
      key: "recharts-scatter-line"
    }, lineItem);
  }
  function ScatterSymbols(props) {
    var {
      points,
      showLabels,
      allOtherScatterProps
    } = props;
    var {
      shape,
      activeShape,
      dataKey
    } = allOtherScatterProps;
    var activeIndex = useAppSelector(selectActiveTooltipIndex);
    var {
      onMouseEnter: onMouseEnterFromProps,
      onClick: onItemClickFromProps,
      onMouseLeave: onMouseLeaveFromProps
    } = allOtherScatterProps, restOfAllOtherProps = _objectWithoutProperties$a(allOtherScatterProps, _excluded$a);
    var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, allOtherScatterProps.dataKey);
    var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
    var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, allOtherScatterProps.dataKey);
    if (points == null) {
      return null;
    }
    var {
      id
    } = allOtherScatterProps, allOtherPropsWithoutId = _objectWithoutProperties$a(allOtherScatterProps, _excluded2$3);
    var baseProps = svgPropertiesNoEvents(allOtherPropsWithoutId);
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(ScatterLine, {
      points,
      props: allOtherPropsWithoutId
    }), points.map((entry, i) => {
      var isActive = activeShape && activeIndex === String(i);
      var option = isActive ? activeShape : shape;
      var symbolProps = _objectSpread$8(_objectSpread$8(_objectSpread$8({
        key: "symbol-".concat(i)
      }, baseProps), entry), {}, {
        [DATA_ITEM_INDEX_ATTRIBUTE_NAME]: i,
        [DATA_ITEM_DATAKEY_ATTRIBUTE_NAME]: String(dataKey)
      });
      return /* @__PURE__ */ React__namespace.createElement(Layer, _extends$b({
        className: "recharts-scatter-symbol"
      }, adaptEventsOfChild(restOfAllOtherProps, entry, i), {
        // @ts-expect-error the types need a bit of attention
        onMouseEnter: onMouseEnterFromContext(entry, i),
        onMouseLeave: onMouseLeaveFromContext(entry, i),
        onClick: onClickFromContext(entry, i),
        key: "symbol-".concat(entry === null || entry === void 0 ? void 0 : entry.cx, "-").concat(entry === null || entry === void 0 ? void 0 : entry.cy, "-").concat(entry === null || entry === void 0 ? void 0 : entry.size, "-").concat(i)
      }), /* @__PURE__ */ React__namespace.createElement(ScatterSymbol, _extends$b({
        option,
        isActive
      }, symbolProps)));
    }), showLabels && LabelList.renderCallByParent(allOtherPropsWithoutId, points));
  }
  function SymbolsWithAnimation(_ref2) {
    var {
      previousPointsRef,
      props
    } = _ref2;
    var {
      points,
      isAnimationActive,
      animationBegin,
      animationDuration,
      animationEasing
    } = props;
    var prevPoints = previousPointsRef.current;
    var animationId = useAnimationId$1(props, "recharts-scatter-");
    var [isAnimating, setIsAnimating] = React.useState(false);
    var handleAnimationEnd = React.useCallback(() => {
      setIsAnimating(false);
    }, []);
    var handleAnimationStart = React.useCallback(() => {
      setIsAnimating(true);
    }, []);
    return /* @__PURE__ */ React__namespace.createElement(JavascriptAnimate, {
      begin: animationBegin,
      duration: animationDuration,
      isActive: isAnimationActive,
      easing: animationEasing,
      onAnimationEnd: handleAnimationEnd,
      onAnimationStart: handleAnimationStart,
      key: animationId
    }, (t) => {
      var stepData = t === 1 ? points : points.map((entry, index2) => {
        var prev = prevPoints && prevPoints[index2];
        if (prev) {
          var interpolatorCx = interpolateNumber$2(prev.cx, entry.cx);
          var interpolatorCy = interpolateNumber$2(prev.cy, entry.cy);
          var interpolatorSize = interpolateNumber$2(prev.size, entry.size);
          return _objectSpread$8(_objectSpread$8({}, entry), {}, {
            cx: interpolatorCx(t),
            cy: interpolatorCy(t),
            size: interpolatorSize(t)
          });
        }
        var interpolator = interpolateNumber$2(0, entry.size);
        return _objectSpread$8(_objectSpread$8({}, entry), {}, {
          size: interpolator(t)
        });
      });
      if (t > 0) {
        previousPointsRef.current = stepData;
      }
      return /* @__PURE__ */ React__namespace.createElement(Layer, null, /* @__PURE__ */ React__namespace.createElement(ScatterSymbols, {
        points: stepData,
        allOtherScatterProps: props,
        showLabels: !isAnimating
      }));
    });
  }
  function RenderSymbols(props) {
    var {
      points,
      isAnimationActive
    } = props;
    var previousPointsRef = React.useRef(null);
    var prevPoints = previousPointsRef.current;
    if (isAnimationActive && points && points.length && (!prevPoints || prevPoints !== points)) {
      return /* @__PURE__ */ React__namespace.createElement(SymbolsWithAnimation, {
        props,
        previousPointsRef
      });
    }
    return /* @__PURE__ */ React__namespace.createElement(ScatterSymbols, {
      points,
      allOtherScatterProps: props,
      showLabels: true
    });
  }
  function getTooltipEntrySettings$4(props) {
    var {
      dataKey,
      points,
      stroke,
      strokeWidth,
      fill: fill2,
      name,
      hide,
      tooltipType
    } = props;
    return {
      dataDefinedOnItem: points === null || points === void 0 ? void 0 : points.map((p) => p.tooltipPayload),
      positions: points === null || points === void 0 ? void 0 : points.map((p) => p.tooltipPosition),
      settings: {
        stroke,
        strokeWidth,
        fill: fill2,
        nameKey: void 0,
        dataKey,
        name: getTooltipNameProp(name, dataKey),
        hide,
        type: tooltipType,
        color: fill2,
        unit: ""
        // why doesn't Scatter support unit?
      }
    };
  }
  function computeScatterPoints(_ref3) {
    var {
      displayedData,
      xAxis,
      yAxis,
      zAxis,
      scatterSettings,
      xAxisTicks,
      yAxisTicks,
      cells
    } = _ref3;
    var xAxisDataKey = isNullish(xAxis.dataKey) ? scatterSettings.dataKey : xAxis.dataKey;
    var yAxisDataKey = isNullish(yAxis.dataKey) ? scatterSettings.dataKey : yAxis.dataKey;
    var zAxisDataKey = zAxis && zAxis.dataKey;
    var defaultRangeZ = zAxis ? zAxis.range : ZAxis.defaultProps.range;
    var defaultZ = defaultRangeZ && defaultRangeZ[0];
    var xBandSize = xAxis.scale.bandwidth ? xAxis.scale.bandwidth() : 0;
    var yBandSize = yAxis.scale.bandwidth ? yAxis.scale.bandwidth() : 0;
    return displayedData.map((entry, index2) => {
      var x2 = getValueByDataKey(entry, xAxisDataKey);
      var y2 = getValueByDataKey(entry, yAxisDataKey);
      var z = !isNullish(zAxisDataKey) && getValueByDataKey(entry, zAxisDataKey) || "-";
      var tooltipPayload = [{
        // @ts-expect-error name prop should not have dataKey in it
        name: isNullish(xAxis.dataKey) ? scatterSettings.name : xAxis.name || xAxis.dataKey,
        unit: xAxis.unit || "",
        // @ts-expect-error getValueByDataKey does not validate the output type
        value: x2,
        payload: entry,
        dataKey: xAxisDataKey,
        type: scatterSettings.tooltipType
      }, {
        // @ts-expect-error name prop should not have dataKey in it
        name: isNullish(yAxis.dataKey) ? scatterSettings.name : yAxis.name || yAxis.dataKey,
        unit: yAxis.unit || "",
        // @ts-expect-error getValueByDataKey does not validate the output type
        value: y2,
        payload: entry,
        dataKey: yAxisDataKey,
        type: scatterSettings.tooltipType
      }];
      if (z !== "-") {
        tooltipPayload.push({
          // @ts-expect-error name prop should not have dataKey in it
          name: zAxis.name || zAxis.dataKey,
          unit: zAxis.unit || "",
          // @ts-expect-error getValueByDataKey does not validate the output type
          value: z,
          payload: entry,
          dataKey: zAxisDataKey,
          type: scatterSettings.tooltipType
        });
      }
      var cx = getCateCoordinateOfLine({
        axis: xAxis,
        ticks: xAxisTicks,
        bandSize: xBandSize,
        entry,
        index: index2,
        dataKey: xAxisDataKey
      });
      var cy = getCateCoordinateOfLine({
        axis: yAxis,
        ticks: yAxisTicks,
        bandSize: yBandSize,
        entry,
        index: index2,
        dataKey: yAxisDataKey
      });
      var size = z !== "-" ? zAxis.scale(z) : defaultZ;
      var radius = Math.sqrt(Math.max(size, 0) / Math.PI);
      return _objectSpread$8(_objectSpread$8({}, entry), {}, {
        cx,
        cy,
        x: cx - radius,
        y: cy - radius,
        width: 2 * radius,
        height: 2 * radius,
        size,
        node: {
          x: x2,
          y: y2,
          z
        },
        tooltipPayload,
        tooltipPosition: {
          x: cx,
          y: cy
        },
        payload: entry
      }, cells && cells[index2] && cells[index2].props);
    });
  }
  var errorBarDataPointFormatter = (dataPoint, dataKey, direction) => {
    return {
      x: dataPoint.cx,
      y: dataPoint.cy,
      value: direction === "x" ? +dataPoint.node.x : +dataPoint.node.y,
      // @ts-expect-error getValueByDataKey does not validate the output type
      errorVal: getValueByDataKey(dataPoint, dataKey)
    };
  };
  function ScatterWithId(props) {
    var {
      hide,
      points,
      className,
      needClip,
      xAxisId,
      yAxisId,
      id,
      children
    } = props;
    if (hide) {
      return null;
    }
    var layerClass = clsx("recharts-scatter", className);
    var clipPathId = id;
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: layerClass,
      clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null,
      id
    }, needClip && /* @__PURE__ */ React__namespace.createElement("defs", null, /* @__PURE__ */ React__namespace.createElement(GraphicalItemClipPath, {
      clipPathId,
      xAxisId,
      yAxisId
    })), /* @__PURE__ */ React__namespace.createElement(SetErrorBarContext, {
      xAxisId,
      yAxisId,
      data: points,
      dataPointFormatter: errorBarDataPointFormatter,
      errorBarOffset: 0
    }, children), /* @__PURE__ */ React__namespace.createElement(Layer, {
      key: "recharts-scatter-symbols"
    }, /* @__PURE__ */ React__namespace.createElement(RenderSymbols, props)));
  }
  var defaultScatterProps = {
    xAxisId: 0,
    yAxisId: 0,
    zAxisId: 0,
    legendType: "circle",
    lineType: "joint",
    lineJointType: "linear",
    data: [],
    shape: "circle",
    hide: false,
    isAnimationActive: !Global.isSsr,
    animationBegin: 0,
    animationDuration: 400,
    animationEasing: "linear"
  };
  function ScatterImpl(props) {
    var _resolveDefaultProps = resolveDefaultProps(props, defaultScatterProps), {
      animationBegin,
      animationDuration,
      animationEasing,
      hide,
      isAnimationActive,
      legendType,
      lineJointType,
      lineType,
      shape,
      xAxisId,
      yAxisId,
      zAxisId
    } = _resolveDefaultProps, everythingElse = _objectWithoutProperties$a(_resolveDefaultProps, _excluded3);
    var {
      needClip
    } = useNeedsClip(xAxisId, yAxisId);
    var cells = React.useMemo(() => findAllByType(props.children, Cell), [props.children]);
    var isPanorama = useIsPanorama();
    var points = useAppSelector((state) => {
      return selectScatterPoints(state, xAxisId, yAxisId, zAxisId, props.id, cells, isPanorama);
    });
    if (needClip == null) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(SetTooltipEntrySettings, {
      fn: getTooltipEntrySettings$4,
      args: _objectSpread$8(_objectSpread$8({}, props), {}, {
        points
      })
    }), /* @__PURE__ */ React__namespace.createElement(ScatterWithId, _extends$b({}, everythingElse, {
      xAxisId,
      yAxisId,
      zAxisId,
      lineType,
      lineJointType,
      legendType,
      shape,
      hide,
      isAnimationActive,
      animationBegin,
      animationDuration,
      animationEasing,
      points,
      needClip
    })));
  }
  function Scatter(outsideProps) {
    var props = resolveDefaultProps(outsideProps, defaultScatterProps);
    var isPanorama = useIsPanorama();
    return /* @__PURE__ */ React__namespace.createElement(RegisterGraphicalItemId, {
      id: props.id,
      type: "scatter"
    }, (id) => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(SetLegendPayload, {
      legendPayload: computeLegendPayloadFromScatterProps(props)
    }), /* @__PURE__ */ React__namespace.createElement(SetCartesianGraphicalItem, {
      type: "scatter",
      id,
      data: props.data,
      xAxisId: props.xAxisId,
      yAxisId: props.yAxisId,
      zAxisId: props.zAxisId,
      dataKey: props.dataKey,
      hide: props.hide,
      name: props.name,
      tooltipType: props.tooltipType,
      isPanorama
    }), /* @__PURE__ */ React__namespace.createElement(ScatterImpl, _extends$b({}, props, {
      id
    }))));
  }
  Scatter.displayName = "Scatter";
  var _excluded$9 = ["children"], _excluded2$2 = ["dangerouslySetInnerHTML", "ticks"];
  function _defineProperty$9(e, r2, t) {
    return (r2 = _toPropertyKey$9(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$9(t) {
    var i = _toPrimitive$9(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$9(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _extends$a() {
    return _extends$a = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$a.apply(null, arguments);
  }
  function _objectWithoutProperties$9(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$9(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$9(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function SetXAxisSettings(props) {
    var dispatch = useAppDispatch();
    var settings = React.useMemo(() => {
      var {
        children
      } = props, rest2 = _objectWithoutProperties$9(props, _excluded$9);
      return rest2;
    }, [props]);
    var synchronizedSettings = useAppSelector((state) => selectXAxisSettings(state, settings.id));
    var settingsAreSynchronized = settings === synchronizedSettings;
    React.useEffect(() => {
      dispatch(addXAxis(settings));
      return () => {
        dispatch(removeXAxis(settings));
      };
    }, [settings, dispatch]);
    if (settingsAreSynchronized) {
      return props.children;
    }
    return null;
  }
  var XAxisImpl = (props) => {
    var {
      xAxisId,
      className
    } = props;
    var viewBox = useAppSelector(selectAxisViewBox);
    var isPanorama = useIsPanorama();
    var axisType = "xAxis";
    var scale = useAppSelector((state) => selectAxisScale(state, axisType, xAxisId, isPanorama));
    var cartesianTickItems = useAppSelector((state) => selectTicksOfAxis(state, axisType, xAxisId, isPanorama));
    var axisSize = useAppSelector((state) => selectXAxisSize(state, xAxisId));
    var position2 = useAppSelector((state) => selectXAxisPosition(state, xAxisId));
    if (axisSize == null || position2 == null) {
      return null;
    }
    var {
      dangerouslySetInnerHTML,
      ticks: ticks2
    } = props, allOtherProps = _objectWithoutProperties$9(props, _excluded2$2);
    return /* @__PURE__ */ React__namespace.createElement(CartesianAxis, _extends$a({}, allOtherProps, {
      scale,
      x: position2.x,
      y: position2.y,
      width: axisSize.width,
      height: axisSize.height,
      className: clsx("recharts-".concat(axisType, " ").concat(axisType), className),
      viewBox,
      ticks: cartesianTickItems
    }));
  };
  var XAxisSettingsDispatcher = (props) => {
    var _props$interval, _props$includeHidden, _props$angle, _props$minTickGap, _props$tick;
    return /* @__PURE__ */ React__namespace.createElement(SetXAxisSettings, {
      interval: (_props$interval = props.interval) !== null && _props$interval !== void 0 ? _props$interval : "preserveEnd",
      id: props.xAxisId,
      scale: props.scale,
      type: props.type,
      padding: props.padding,
      allowDataOverflow: props.allowDataOverflow,
      domain: props.domain,
      dataKey: props.dataKey,
      allowDuplicatedCategory: props.allowDuplicatedCategory,
      allowDecimals: props.allowDecimals,
      tickCount: props.tickCount,
      includeHidden: (_props$includeHidden = props.includeHidden) !== null && _props$includeHidden !== void 0 ? _props$includeHidden : false,
      reversed: props.reversed,
      ticks: props.ticks,
      height: props.height,
      orientation: props.orientation,
      mirror: props.mirror,
      hide: props.hide,
      unit: props.unit,
      name: props.name,
      angle: (_props$angle = props.angle) !== null && _props$angle !== void 0 ? _props$angle : 0,
      minTickGap: (_props$minTickGap = props.minTickGap) !== null && _props$minTickGap !== void 0 ? _props$minTickGap : 5,
      tick: (_props$tick = props.tick) !== null && _props$tick !== void 0 ? _props$tick : true,
      tickFormatter: props.tickFormatter
    }, /* @__PURE__ */ React__namespace.createElement(XAxisImpl, props));
  };
  class XAxis extends React.Component {
    render() {
      return /* @__PURE__ */ React__namespace.createElement(XAxisSettingsDispatcher, this.props);
    }
  }
  _defineProperty$9(XAxis, "displayName", "XAxis");
  _defineProperty$9(XAxis, "defaultProps", {
    allowDataOverflow: implicitXAxis.allowDataOverflow,
    allowDecimals: implicitXAxis.allowDecimals,
    allowDuplicatedCategory: implicitXAxis.allowDuplicatedCategory,
    height: implicitXAxis.height,
    hide: false,
    mirror: implicitXAxis.mirror,
    orientation: implicitXAxis.orientation,
    padding: implicitXAxis.padding,
    reversed: implicitXAxis.reversed,
    scale: implicitXAxis.scale,
    tickCount: implicitXAxis.tickCount,
    type: implicitXAxis.type,
    xAxisId: 0
  });
  var getCalculatedYAxisWidth = (_ref2) => {
    var {
      ticks: ticks2,
      label,
      labelGapWithTick = 5,
      // Default gap between label and tick
      tickSize = 0,
      tickMargin = 0
    } = _ref2;
    var maxTickWidth = 0;
    if (ticks2) {
      ticks2.forEach((tickNode) => {
        if (tickNode) {
          var bbox = tickNode.getBoundingClientRect();
          if (bbox.width > maxTickWidth) {
            maxTickWidth = bbox.width;
          }
        }
      });
      var labelWidth = label ? label.getBoundingClientRect().width : 0;
      var tickWidth = tickSize + tickMargin;
      var updatedYAxisWidth = maxTickWidth + tickWidth + labelWidth + (label ? labelGapWithTick : 0);
      return Math.round(updatedYAxisWidth);
    }
    return 0;
  };
  var _excluded$8 = ["dangerouslySetInnerHTML", "ticks"];
  function _defineProperty$8(e, r2, t) {
    return (r2 = _toPropertyKey$8(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$8(t) {
    var i = _toPrimitive$8(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$8(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _extends$9() {
    return _extends$9 = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$9.apply(null, arguments);
  }
  function _objectWithoutProperties$8(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$8(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$8(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function SetYAxisSettings(settings) {
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(addYAxis(settings));
      return () => {
        dispatch(removeYAxis(settings));
      };
    }, [settings, dispatch]);
    return null;
  }
  var YAxisImpl = (props) => {
    var _cartesianAxisRef$cur;
    var {
      yAxisId,
      className,
      width,
      label
    } = props;
    var cartesianAxisRef = React.useRef(null);
    var labelRef = React.useRef(null);
    var viewBox = useAppSelector(selectAxisViewBox);
    var isPanorama = useIsPanorama();
    var dispatch = useAppDispatch();
    var axisType = "yAxis";
    var scale = useAppSelector((state) => selectAxisScale(state, axisType, yAxisId, isPanorama));
    var axisSize = useAppSelector((state) => selectYAxisSize(state, yAxisId));
    var position2 = useAppSelector((state) => selectYAxisPosition(state, yAxisId));
    var cartesianTickItems = useAppSelector((state) => selectTicksOfAxis(state, axisType, yAxisId, isPanorama));
    React.useLayoutEffect(() => {
      var _axisComponent$tickRe;
      if (width !== "auto" || !axisSize || isLabelContentAFunction(label) || /* @__PURE__ */ React.isValidElement(label)) return;
      var axisComponent = cartesianAxisRef.current;
      var tickNodes = axisComponent === null || axisComponent === void 0 || (_axisComponent$tickRe = axisComponent.tickRefs) === null || _axisComponent$tickRe === void 0 ? void 0 : _axisComponent$tickRe.current;
      var {
        tickSize,
        tickMargin
      } = axisComponent.props;
      var updatedYAxisWidth = getCalculatedYAxisWidth({
        ticks: tickNodes,
        label: labelRef.current,
        labelGapWithTick: 5,
        tickSize,
        tickMargin
      });
      if (Math.round(axisSize.width) !== Math.round(updatedYAxisWidth)) dispatch(updateYAxisWidth({
        id: yAxisId,
        width: updatedYAxisWidth
      }));
    }, [
      cartesianAxisRef,
      cartesianAxisRef === null || cartesianAxisRef === void 0 || (_cartesianAxisRef$cur = cartesianAxisRef.current) === null || _cartesianAxisRef$cur === void 0 || (_cartesianAxisRef$cur = _cartesianAxisRef$cur.tickRefs) === null || _cartesianAxisRef$cur === void 0 ? void 0 : _cartesianAxisRef$cur.current,
      // required to do re-calculation when using brush
      axisSize === null || axisSize === void 0 ? void 0 : axisSize.width,
      axisSize,
      dispatch,
      label,
      yAxisId,
      width
    ]);
    if (axisSize == null || position2 == null) {
      return null;
    }
    var {
      dangerouslySetInnerHTML,
      ticks: ticks2
    } = props, allOtherProps = _objectWithoutProperties$8(props, _excluded$8);
    return /* @__PURE__ */ React__namespace.createElement(CartesianAxis, _extends$9({}, allOtherProps, {
      ref: cartesianAxisRef,
      labelRef,
      scale,
      x: position2.x,
      y: position2.y,
      width: axisSize.width,
      height: axisSize.height,
      className: clsx("recharts-".concat(axisType, " ").concat(axisType), className),
      viewBox,
      ticks: cartesianTickItems
    }));
  };
  var YAxisSettingsDispatcher = (props) => {
    var _props$interval, _props$includeHidden, _props$angle, _props$minTickGap, _props$tick;
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(SetYAxisSettings, {
      interval: (_props$interval = props.interval) !== null && _props$interval !== void 0 ? _props$interval : "preserveEnd",
      id: props.yAxisId,
      scale: props.scale,
      type: props.type,
      domain: props.domain,
      allowDataOverflow: props.allowDataOverflow,
      dataKey: props.dataKey,
      allowDuplicatedCategory: props.allowDuplicatedCategory,
      allowDecimals: props.allowDecimals,
      tickCount: props.tickCount,
      padding: props.padding,
      includeHidden: (_props$includeHidden = props.includeHidden) !== null && _props$includeHidden !== void 0 ? _props$includeHidden : false,
      reversed: props.reversed,
      ticks: props.ticks,
      width: props.width,
      orientation: props.orientation,
      mirror: props.mirror,
      hide: props.hide,
      unit: props.unit,
      name: props.name,
      angle: (_props$angle = props.angle) !== null && _props$angle !== void 0 ? _props$angle : 0,
      minTickGap: (_props$minTickGap = props.minTickGap) !== null && _props$minTickGap !== void 0 ? _props$minTickGap : 5,
      tick: (_props$tick = props.tick) !== null && _props$tick !== void 0 ? _props$tick : true,
      tickFormatter: props.tickFormatter
    }), /* @__PURE__ */ React__namespace.createElement(YAxisImpl, props));
  };
  var YAxisDefaultProps = {
    allowDataOverflow: implicitYAxis.allowDataOverflow,
    allowDecimals: implicitYAxis.allowDecimals,
    allowDuplicatedCategory: implicitYAxis.allowDuplicatedCategory,
    hide: false,
    mirror: implicitYAxis.mirror,
    orientation: implicitYAxis.orientation,
    padding: implicitYAxis.padding,
    reversed: implicitYAxis.reversed,
    scale: implicitYAxis.scale,
    tickCount: implicitYAxis.tickCount,
    type: implicitYAxis.type,
    width: implicitYAxis.width,
    yAxisId: 0
  };
  class YAxis extends React.Component {
    render() {
      return /* @__PURE__ */ React__namespace.createElement(YAxisSettingsDispatcher, this.props);
    }
  }
  _defineProperty$8(YAxis, "displayName", "YAxis");
  _defineProperty$8(YAxis, "defaultProps", YAxisDefaultProps);
  var defaultProps$5 = {
    begin: 0,
    duration: 1e3,
    easing: "ease",
    isActive: true,
    canBegin: true,
    onAnimationEnd: () => {
    },
    onAnimationStart: () => {
    }
  };
  function CSSTransitionAnimate(outsideProps) {
    var props = resolveDefaultProps(outsideProps, defaultProps$5);
    var {
      from: from2,
      to: to2,
      attributeName,
      isActive,
      canBegin,
      duration,
      easing,
      begin,
      onAnimationEnd,
      onAnimationStart,
      children
    } = props;
    var animationManager = useAnimationManager(attributeName, props.animationManager);
    var [style, setStyle] = React.useState(isActive ? from2 : to2);
    React.useEffect(() => {
      if (!isActive) {
        setStyle(to2);
      }
    }, [isActive, to2]);
    React.useEffect(() => {
      if (!isActive || !canBegin) {
        return noop$1;
      }
      var unsubscribe = animationManager.subscribe(setStyle);
      animationManager.start([onAnimationStart, begin, to2, duration, onAnimationEnd]);
      return () => {
        animationManager.stop();
        if (unsubscribe) {
          unsubscribe();
        }
        onAnimationEnd();
      };
    }, [isActive, canBegin, duration, easing, begin, onAnimationStart, onAnimationEnd, animationManager, to2]);
    if (isActive && canBegin) {
      var transition = getTransitionVal([attributeName], duration, easing);
      return children({
        transition,
        [attributeName]: style
      });
    }
    return children({
      [attributeName]: style
    });
  }
  var _excluded$7 = ["direction", "width", "dataKey", "isAnimationActive", "animationBegin", "animationDuration", "animationEasing"];
  function _extends$8() {
    return _extends$8 = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$8.apply(null, arguments);
  }
  function ownKeys$7(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$7(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$7(Object(t), true).forEach(function(r3) {
        _defineProperty$7(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$7(e, r2, t) {
    return (r2 = _toPropertyKey$7(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$7(t) {
    var i = _toPrimitive$7(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$7(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _objectWithoutProperties$7(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$7(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$7(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function ErrorBarImpl(props) {
    var {
      direction,
      width,
      dataKey,
      isAnimationActive,
      animationBegin,
      animationDuration,
      animationEasing
    } = props, others = _objectWithoutProperties$7(props, _excluded$7);
    var svgProps = svgPropertiesNoEvents(others);
    var {
      data,
      dataPointFormatter,
      xAxisId,
      yAxisId,
      errorBarOffset: offset
    } = useErrorBarContext();
    var xAxis = useXAxis(xAxisId);
    var yAxis = useYAxis(yAxisId);
    if ((xAxis === null || xAxis === void 0 ? void 0 : xAxis.scale) == null || (yAxis === null || yAxis === void 0 ? void 0 : yAxis.scale) == null || data == null) {
      return null;
    }
    if (direction === "x" && xAxis.type !== "number") {
      return null;
    }
    var errorBars = data.map((entry) => {
      var {
        x: x2,
        y: y2,
        value,
        errorVal
      } = dataPointFormatter(entry, dataKey, direction);
      if (!errorVal || x2 == null || y2 == null) {
        return null;
      }
      var lineCoordinates = [];
      var lowBound, highBound;
      if (Array.isArray(errorVal)) {
        [lowBound, highBound] = errorVal;
      } else {
        lowBound = highBound = errorVal;
      }
      if (direction === "x") {
        var {
          scale
        } = xAxis;
        var yMid = y2 + offset;
        var yMin = yMid + width;
        var yMax = yMid - width;
        var xMin = scale(value - lowBound);
        var xMax = scale(value + highBound);
        lineCoordinates.push({
          x1: xMax,
          y1: yMin,
          x2: xMax,
          y2: yMax
        });
        lineCoordinates.push({
          x1: xMin,
          y1: yMid,
          x2: xMax,
          y2: yMid
        });
        lineCoordinates.push({
          x1: xMin,
          y1: yMin,
          x2: xMin,
          y2: yMax
        });
      } else if (direction === "y") {
        var {
          scale: _scale
        } = yAxis;
        var xMid = x2 + offset;
        var _xMin = xMid - width;
        var _xMax = xMid + width;
        var _yMin = _scale(value - lowBound);
        var _yMax = _scale(value + highBound);
        lineCoordinates.push({
          x1: _xMin,
          y1: _yMax,
          x2: _xMax,
          y2: _yMax
        });
        lineCoordinates.push({
          x1: xMid,
          y1: _yMin,
          x2: xMid,
          y2: _yMax
        });
        lineCoordinates.push({
          x1: _xMin,
          y1: _yMin,
          x2: _xMax,
          y2: _yMin
        });
      }
      var scaleDirection = direction === "x" ? "scaleX" : "scaleY";
      var transformOrigin = "".concat(x2 + offset, "px ").concat(y2 + offset, "px");
      return /* @__PURE__ */ React__namespace.createElement(Layer, _extends$8({
        className: "recharts-errorBar",
        key: "bar-".concat(lineCoordinates.map((c2) => "".concat(c2.x1, "-").concat(c2.x2, "-").concat(c2.y1, "-").concat(c2.y2)))
      }, svgProps), lineCoordinates.map((coordinates) => {
        var lineStyle = isAnimationActive ? {
          transformOrigin
        } : void 0;
        return /* @__PURE__ */ React__namespace.createElement(CSSTransitionAnimate, {
          from: "".concat(scaleDirection, "(0)"),
          to: "".concat(scaleDirection, "(1)"),
          attributeName: "transform",
          begin: animationBegin,
          easing: animationEasing,
          isActive: isAnimationActive,
          duration: animationDuration,
          key: "line-".concat(coordinates.x1, "-").concat(coordinates.x2, "-").concat(coordinates.y1, "-").concat(coordinates.y2)
        }, (style) => /* @__PURE__ */ React__namespace.createElement("line", _extends$8({}, coordinates, {
          style: _objectSpread$7(_objectSpread$7({}, lineStyle), style)
        })));
      }));
    });
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: "recharts-errorBars"
    }, errorBars);
  }
  function useErrorBarDirection(directionFromProps) {
    var layout = useChartLayout();
    if (directionFromProps != null) {
      return directionFromProps;
    }
    if (layout != null) {
      return layout === "horizontal" ? "y" : "x";
    }
    return "x";
  }
  var errorBarDefaultProps = {
    stroke: "black",
    strokeWidth: 1.5,
    width: 5,
    offset: 0,
    isAnimationActive: true,
    animationBegin: 0,
    animationDuration: 400,
    animationEasing: "ease-in-out"
  };
  function ErrorBarInternal(props) {
    var realDirection = useErrorBarDirection(props.direction);
    var {
      width,
      isAnimationActive,
      animationBegin,
      animationDuration,
      animationEasing
    } = resolveDefaultProps(props, errorBarDefaultProps);
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(ReportErrorBarSettings, {
      dataKey: props.dataKey,
      direction: realDirection
    }), /* @__PURE__ */ React__namespace.createElement(ErrorBarImpl, _extends$8({}, props, {
      direction: realDirection,
      width,
      isAnimationActive,
      animationBegin,
      animationDuration,
      animationEasing
    })));
  }
  class ErrorBar extends React.Component {
    render() {
      return /* @__PURE__ */ React__namespace.createElement(ErrorBarInternal, this.props);
    }
  }
  _defineProperty$7(ErrorBar, "defaultProps", errorBarDefaultProps);
  _defineProperty$7(ErrorBar, "displayName", "ErrorBar");
  var withSelector$2 = { exports: {} };
  var useSyncExternalStoreWithSelector_development = {};
  var useSyncExternalStoreWithSelector;
  "use strict";
  /**
   * @license React
   * use-sync-external-store-with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  (function() {
    function is2(x2, y2) {
      return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React$1 = React, objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore2 = React$1.useSyncExternalStore, useRef = React$1.useRef, useEffect = React$1.useEffect, useMemo = React$1.useMemo, useDebugValue = React$1.useDebugValue;
    useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector_development.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual2) {
      var instRef = useRef(null);
      if (null === instRef.current) {
        var inst = { hasValue: false, value: null };
        instRef.current = inst;
      } else inst = instRef.current;
      instRef = useMemo(
        function() {
          function memoizedSelector(nextSnapshot) {
            if (!hasMemo) {
              hasMemo = true;
              memoizedSnapshot = nextSnapshot;
              nextSnapshot = selector(nextSnapshot);
              if (void 0 !== isEqual2 && inst.hasValue) {
                var currentSelection = inst.value;
                if (isEqual2(currentSelection, nextSnapshot))
                  return memoizedSelection = currentSelection;
              }
              return memoizedSelection = nextSnapshot;
            }
            currentSelection = memoizedSelection;
            if (objectIs(memoizedSnapshot, nextSnapshot))
              return currentSelection;
            var nextSelection = selector(nextSnapshot);
            if (void 0 !== isEqual2 && isEqual2(currentSelection, nextSelection))
              return memoizedSnapshot = nextSnapshot, currentSelection;
            memoizedSnapshot = nextSnapshot;
            return memoizedSelection = nextSelection;
          }
          var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
          return [
            function() {
              return memoizedSelector(getSnapshot());
            },
            null === maybeGetServerSnapshot ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            }
          ];
        },
        [getSnapshot, getServerSnapshot, selector, isEqual2]
      );
      var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
      useEffect(
        function() {
          inst.hasValue = true;
          inst.value = value;
        },
        [value]
      );
      useDebugValue(value);
      return value;
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
  var withSelector = withSelector$2.exports;
  "use strict";
  if (false) {
    module.exports = require("./cjs/use-sync-external-store-with-selector.production.js");
  } else {
    withSelector$2.exports = useSyncExternalStoreWithSelector_development;
  }
  var withSelectorExports = withSelector$2.exports;
  const withSelector$1 = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports);
  var IS_REACT_19 = /* @__PURE__ */ React__namespace.version.startsWith("19");
  var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for(
    IS_REACT_19 ? "react.transitional.element" : "react.element"
  );
  var REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal");
  var REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment");
  var REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode");
  var REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler");
  var REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer");
  var REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context");
  var REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref");
  var REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense");
  var REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for(
    "react.suspense_list"
  );
  var REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo");
  var REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy");
  var REACT_OFFSCREEN_TYPE = /* @__PURE__ */ Symbol.for("react.offscreen");
  var REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for(
    "react.client.reference"
  );
  var ForwardRef = REACT_FORWARD_REF_TYPE;
  var Memo = REACT_MEMO_TYPE;
  function isValidElementType(type) {
    return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) ? true : false;
  }
  function typeOf(object2) {
    if (typeof object2 === "object" && object2 !== null) {
      const { $$typeof } = object2;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (object2 = object2.type, object2) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
              return object2;
            default:
              switch (object2 = object2 && object2.$$typeof, object2) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                  return object2;
                case REACT_CONSUMER_TYPE:
                  return object2;
                default:
                  return $$typeof;
              }
          }
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  function isContextConsumer(object2) {
    return IS_REACT_19 ? typeOf(object2) === REACT_CONSUMER_TYPE : typeOf(object2) === REACT_CONTEXT_TYPE;
  }
  function isMemo(object2) {
    return typeOf(object2) === REACT_MEMO_TYPE;
  }
  function warning(message) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
      console.error(message);
    }
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
  function verify(selector, methodName) {
    if (!selector) {
      throw new Error(`Unexpected value for ${methodName} in connect.`);
    } else if (methodName === "mapStateToProps" || methodName === "mapDispatchToProps") {
      if (!Object.prototype.hasOwnProperty.call(selector, "dependsOnOwnProps")) {
        warning(
          `The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`
        );
      }
    }
  }
  function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {
    verify(mapStateToProps, "mapStateToProps");
    verify(mapDispatchToProps, "mapDispatchToProps");
    verify(mergeProps, "mergeProps");
  }
  function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, {
    areStatesEqual,
    areOwnPropsEqual,
    areStatePropsEqual
  }) {
    let hasRunAtLeastOnce = false;
    let state;
    let ownProps;
    let stateProps;
    let dispatchProps;
    let mergedProps;
    function handleFirstCall(firstState, firstOwnProps) {
      state = firstState;
      ownProps = firstOwnProps;
      stateProps = mapStateToProps(state, ownProps);
      dispatchProps = mapDispatchToProps(dispatch, ownProps);
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      hasRunAtLeastOnce = true;
      return mergedProps;
    }
    function handleNewPropsAndNewState() {
      stateProps = mapStateToProps(state, ownProps);
      if (mapDispatchToProps.dependsOnOwnProps)
        dispatchProps = mapDispatchToProps(dispatch, ownProps);
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      return mergedProps;
    }
    function handleNewProps() {
      if (mapStateToProps.dependsOnOwnProps)
        stateProps = mapStateToProps(state, ownProps);
      if (mapDispatchToProps.dependsOnOwnProps)
        dispatchProps = mapDispatchToProps(dispatch, ownProps);
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      return mergedProps;
    }
    function handleNewState() {
      const nextStateProps = mapStateToProps(state, ownProps);
      const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
      stateProps = nextStateProps;
      if (statePropsChanged)
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      return mergedProps;
    }
    function handleSubsequentCalls(nextState, nextOwnProps) {
      const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
      const stateChanged = !areStatesEqual(
        nextState,
        state,
        nextOwnProps,
        ownProps
      );
      state = nextState;
      ownProps = nextOwnProps;
      if (propsChanged && stateChanged) return handleNewPropsAndNewState();
      if (propsChanged) return handleNewProps();
      if (stateChanged) return handleNewState();
      return mergedProps;
    }
    return function pureFinalPropsSelector(nextState, nextOwnProps) {
      return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
    };
  }
  function finalPropsSelectorFactory(dispatch, {
    initMapStateToProps,
    initMapDispatchToProps,
    initMergeProps,
    ...options2
  }) {
    const mapStateToProps = initMapStateToProps(dispatch, options2);
    const mapDispatchToProps = initMapDispatchToProps(dispatch, options2);
    const mergeProps = initMergeProps(dispatch, options2);
    if (true) {
      verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);
    }
    return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options2);
  }
  function bindActionCreators(actionCreators, dispatch) {
    const boundActionCreators = {};
    for (const key in actionCreators) {
      const actionCreator = actionCreators[key];
      if (typeof actionCreator === "function") {
        boundActionCreators[key] = (...args) => dispatch(actionCreator(...args));
      }
    }
    return boundActionCreators;
  }
  function isPlainObject(obj) {
    if (typeof obj !== "object" || obj === null) return false;
    const proto2 = Object.getPrototypeOf(obj);
    if (proto2 === null) return true;
    let baseProto = proto2;
    while (Object.getPrototypeOf(baseProto) !== null) {
      baseProto = Object.getPrototypeOf(baseProto);
    }
    return proto2 === baseProto;
  }
  function verifyPlainObject(value, displayName, methodName) {
    if (!isPlainObject(value)) {
      warning(
        `${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`
      );
    }
  }
  function wrapMapToPropsConstant(getConstant) {
    return function initConstantSelector(dispatch) {
      const constant2 = getConstant(dispatch);
      function constantSelector() {
        return constant2;
      }
      constantSelector.dependsOnOwnProps = false;
      return constantSelector;
    };
  }
  function getDependsOnOwnProps(mapToProps) {
    return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
  }
  function wrapMapToPropsFunc(mapToProps, methodName) {
    return function initProxySelector(dispatch, { displayName }) {
      const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
        return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);
      };
      proxy.dependsOnOwnProps = true;
      proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
        proxy.mapToProps = mapToProps;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
        let props = proxy(stateOrDispatch, ownProps);
        if (typeof props === "function") {
          proxy.mapToProps = props;
          proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
          props = proxy(stateOrDispatch, ownProps);
        }
        if (true)
          verifyPlainObject(props, displayName, methodName);
        return props;
      };
      return proxy;
    };
  }
  function createInvalidArgFactory(arg, name) {
    return (dispatch, options2) => {
      throw new Error(
        `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options2.wrappedComponentName}.`
      );
    };
  }
  function mapDispatchToPropsFactory(mapDispatchToProps) {
    return mapDispatchToProps && typeof mapDispatchToProps === "object" ? wrapMapToPropsConstant(
      (dispatch) => (
        // @ts-ignore
        bindActionCreators(mapDispatchToProps, dispatch)
      )
    ) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch) => ({
      dispatch
    })) : typeof mapDispatchToProps === "function" ? (
      // @ts-ignore
      wrapMapToPropsFunc(mapDispatchToProps, "mapDispatchToProps")
    ) : createInvalidArgFactory(mapDispatchToProps, "mapDispatchToProps");
  }
  function mapStateToPropsFactory(mapStateToProps) {
    return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === "function" ? (
      // @ts-ignore
      wrapMapToPropsFunc(mapStateToProps, "mapStateToProps")
    ) : createInvalidArgFactory(mapStateToProps, "mapStateToProps");
  }
  function defaultMergeProps(stateProps, dispatchProps, ownProps) {
    return { ...ownProps, ...stateProps, ...dispatchProps };
  }
  function wrapMergePropsFunc(mergeProps) {
    return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {
      let hasRunOnce = false;
      let mergedProps;
      return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
        const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        if (hasRunOnce) {
          if (!areMergedPropsEqual(nextMergedProps, mergedProps))
            mergedProps = nextMergedProps;
        } else {
          hasRunOnce = true;
          mergedProps = nextMergedProps;
          if (true)
            verifyPlainObject(mergedProps, displayName, "mergeProps");
        }
        return mergedProps;
      };
    };
  }
  function mergePropsFactory(mergeProps) {
    return !mergeProps ? () => defaultMergeProps : typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, "mergeProps");
  }
  function defaultNoopBatch(callback) {
    callback();
  }
  function createListenerCollection() {
    let first = null;
    let last2 = null;
    return {
      clear() {
        first = null;
        last2 = null;
      },
      notify() {
        defaultNoopBatch(() => {
          let listener2 = first;
          while (listener2) {
            listener2.callback();
            listener2 = listener2.next;
          }
        });
      },
      get() {
        const listeners = [];
        let listener2 = first;
        while (listener2) {
          listeners.push(listener2);
          listener2 = listener2.next;
        }
        return listeners;
      },
      subscribe(callback) {
        let isSubscribed = true;
        const listener2 = last2 = {
          callback,
          next: null,
          prev: last2
        };
        if (listener2.prev) {
          listener2.prev.next = listener2;
        } else {
          first = listener2;
        }
        return function unsubscribe() {
          if (!isSubscribed || first === null) return;
          isSubscribed = false;
          if (listener2.next) {
            listener2.next.prev = listener2.prev;
          } else {
            last2 = listener2.prev;
          }
          if (listener2.prev) {
            listener2.prev.next = listener2.next;
          } else {
            first = listener2.next;
          }
        };
      }
    };
  }
  var nullListeners = {
    notify() {
    },
    get: () => []
  };
  function createSubscription(store, parentSub) {
    let unsubscribe;
    let listeners = nullListeners;
    let subscriptionsAmount = 0;
    let selfSubscribed = false;
    function addNestedSub(listener2) {
      trySubscribe();
      const cleanupListener = listeners.subscribe(listener2);
      let removed = false;
      return () => {
        if (!removed) {
          removed = true;
          cleanupListener();
          tryUnsubscribe();
        }
      };
    }
    function notifyNestedSubs() {
      listeners.notify();
    }
    function handleChangeWrapper() {
      if (subscription.onStateChange) {
        subscription.onStateChange();
      }
    }
    function isSubscribed() {
      return selfSubscribed;
    }
    function trySubscribe() {
      subscriptionsAmount++;
      if (!unsubscribe) {
        unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
        listeners = createListenerCollection();
      }
    }
    function tryUnsubscribe() {
      subscriptionsAmount--;
      if (unsubscribe && subscriptionsAmount === 0) {
        unsubscribe();
        unsubscribe = void 0;
        listeners.clear();
        listeners = nullListeners;
      }
    }
    function trySubscribeSelf() {
      if (!selfSubscribed) {
        selfSubscribed = true;
        trySubscribe();
      }
    }
    function tryUnsubscribeSelf() {
      if (selfSubscribed) {
        selfSubscribed = false;
        tryUnsubscribe();
      }
    }
    const subscription = {
      addNestedSub,
      notifyNestedSubs,
      handleChangeWrapper,
      isSubscribed,
      trySubscribe: trySubscribeSelf,
      tryUnsubscribe: tryUnsubscribeSelf,
      getListeners: () => listeners
    };
    return subscription;
  }
  var canUseDOM = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
  var isDOM = /* @__PURE__ */ canUseDOM();
  var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
  var isReactNative = /* @__PURE__ */ isRunningInReactNative();
  var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? React__namespace.useLayoutEffect : React__namespace.useEffect;
  var useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
  function is(x2, y2) {
    if (x2 === y2) {
      return x2 !== 0 || y2 !== 0 || 1 / x2 === 1 / y2;
    } else {
      return x2 !== x2 && y2 !== y2;
    }
  }
  function shallowEqual(objA, objB) {
    if (is(objA, objB)) return true;
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
      return false;
    }
    const keysA = Object.keys(objA);
    const keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;
    for (let i = 0; i < keysA.length; i++) {
      if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }
    return true;
  }
  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    $$typeof: true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    $$typeof: true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {
    [ForwardRef]: FORWARD_REF_STATICS,
    [Memo]: MEMO_STATICS
  };
  function getStatics(component) {
    if (isMemo(component)) {
      return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
  }
  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;
  function hoistNonReactStatics(targetComponent, sourceComponent) {
    if (typeof sourceComponent !== "string") {
      if (objectPrototype) {
        const inheritedComponent = getPrototypeOf(sourceComponent);
        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics(targetComponent, inheritedComponent);
        }
      }
      let keys = getOwnPropertyNames(sourceComponent);
      if (getOwnPropertySymbols) {
        keys = keys.concat(getOwnPropertySymbols(sourceComponent));
      }
      const targetStatics = getStatics(targetComponent);
      const sourceStatics = getStatics(sourceComponent);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
          const descriptor = getOwnPropertyDescriptor(sourceComponent, key);
          try {
            defineProperty(targetComponent, key, descriptor);
          } catch (e) {
          }
        }
      }
    }
    return targetComponent;
  }
  var ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);
  var gT = typeof globalThis !== "undefined" ? globalThis : (
    /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
    {}
  );
  function getContext() {
    if (!React__namespace.createContext) return {};
    const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());
    let realContext = contextMap.get(React__namespace.createContext);
    if (!realContext) {
      realContext = React__namespace.createContext(
        null
      );
      if (true) {
        realContext.displayName = "ReactRedux";
      }
      contextMap.set(React__namespace.createContext, realContext);
    }
    return realContext;
  }
  var ReactReduxContext = /* @__PURE__ */ getContext();
  var NO_SUBSCRIPTION_ARRAY = [null, null];
  var stringifyComponent = (Comp) => {
    try {
      return JSON.stringify(Comp);
    } catch (err) {
      return String(Comp);
    }
  };
  function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
    useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies);
  }
  function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {
    lastWrapperProps.current = wrapperProps;
    renderIsScheduled.current = false;
    if (childPropsFromStoreUpdate.current) {
      childPropsFromStoreUpdate.current = null;
      notifyNestedSubs();
    }
  }
  function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {
    if (!shouldHandleStateChanges) return () => {
    };
    let didUnsubscribe = false;
    let lastThrownError = null;
    const checkForUpdates = () => {
      if (didUnsubscribe || !isMounted.current) {
        return;
      }
      const latestStoreState = store.getState();
      let newChildProps, error;
      try {
        newChildProps = childPropsSelector(
          latestStoreState,
          lastWrapperProps.current
        );
      } catch (e) {
        error = e;
        lastThrownError = e;
      }
      if (!error) {
        lastThrownError = null;
      }
      if (newChildProps === lastChildProps.current) {
        if (!renderIsScheduled.current) {
          notifyNestedSubs();
        }
      } else {
        lastChildProps.current = newChildProps;
        childPropsFromStoreUpdate.current = newChildProps;
        renderIsScheduled.current = true;
        additionalSubscribeListener();
      }
    };
    subscription.onStateChange = checkForUpdates;
    subscription.trySubscribe();
    checkForUpdates();
    const unsubscribeWrapper = () => {
      didUnsubscribe = true;
      subscription.tryUnsubscribe();
      subscription.onStateChange = null;
      if (lastThrownError) {
        throw lastThrownError;
      }
    };
    return unsubscribeWrapper;
  }
  function strictEqual(a2, b) {
    return a2 === b;
  }
  var hasWarnedAboutDeprecatedPureOption = false;
  function connect(mapStateToProps, mapDispatchToProps, mergeProps, {
    // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.
    // @ts-ignore
    pure,
    areStatesEqual = strictEqual,
    areOwnPropsEqual = shallowEqual,
    areStatePropsEqual = shallowEqual,
    areMergedPropsEqual = shallowEqual,
    // use React's forwardRef to expose a ref of the wrapped component
    forwardRef = false,
    // the context consumer to use
    context = ReactReduxContext
  } = {}) {
    if (true) {
      if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {
        hasWarnedAboutDeprecatedPureOption = true;
        warning(
          'The `pure` option has been removed. `connect` is now always a "pure/memoized" component'
        );
      }
    }
    const Context = context;
    const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);
    const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);
    const initMergeProps = mergePropsFactory(mergeProps);
    const shouldHandleStateChanges = Boolean(mapStateToProps);
    const wrapWithConnect = (WrappedComponent) => {
      if (true) {
        const isValid = /* @__PURE__ */ isValidElementType(WrappedComponent);
        if (!isValid)
          throw new Error(
            `You must pass a component to the function returned by connect. Instead received ${stringifyComponent(
              WrappedComponent
            )}`
          );
      }
      const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
      const displayName = `Connect(${wrappedComponentName})`;
      const selectorFactoryOptions = {
        shouldHandleStateChanges,
        displayName,
        wrappedComponentName,
        WrappedComponent,
        // @ts-ignore
        initMapStateToProps,
        initMapDispatchToProps,
        initMergeProps,
        areStatesEqual,
        areStatePropsEqual,
        areOwnPropsEqual,
        areMergedPropsEqual
      };
      function ConnectFunction(props) {
        const [propsContext, reactReduxForwardedRef, wrapperProps] = React__namespace.useMemo(() => {
          const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;
          return [props.context, reactReduxForwardedRef2, wrapperProps2];
        }, [props]);
        const ContextToUse = React__namespace.useMemo(() => {
          let ResultContext = Context;
          if (propsContext == null ? void 0 : propsContext.Consumer) {
            if (true) {
              const isValid = /* @__PURE__ */ isContextConsumer(
                // @ts-ignore
                /* @__PURE__ */ React__namespace.createElement(propsContext.Consumer, null)
              );
              if (!isValid) {
                throw new Error(
                  "You must pass a valid React context consumer as `props.context`"
                );
              }
              ResultContext = propsContext;
            }
          }
          return ResultContext;
        }, [propsContext, Context]);
        const contextValue = React__namespace.useContext(ContextToUse);
        const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
        const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
        if (!didStoreComeFromProps && !didStoreComeFromContext) {
          throw new Error(
            `Could not find "store" in the context of "${displayName}". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`
          );
        }
        const store = didStoreComeFromProps ? props.store : contextValue.store;
        const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;
        const childPropsSelector = React__namespace.useMemo(() => {
          return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);
        }, [store]);
        const [subscription, notifyNestedSubs] = React__namespace.useMemo(() => {
          if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;
          const subscription2 = createSubscription(
            store,
            didStoreComeFromProps ? void 0 : contextValue.subscription
          );
          const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
          return [subscription2, notifyNestedSubs2];
        }, [store, didStoreComeFromProps, contextValue]);
        const overriddenContextValue = React__namespace.useMemo(() => {
          if (didStoreComeFromProps) {
            return contextValue;
          }
          return {
            ...contextValue,
            subscription
          };
        }, [didStoreComeFromProps, contextValue, subscription]);
        const lastChildProps = React__namespace.useRef(void 0);
        const lastWrapperProps = React__namespace.useRef(wrapperProps);
        const childPropsFromStoreUpdate = React__namespace.useRef(void 0);
        const renderIsScheduled = React__namespace.useRef(false);
        const isMounted = React__namespace.useRef(false);
        const latestSubscriptionCallbackError = React__namespace.useRef(
          void 0
        );
        useIsomorphicLayoutEffect(() => {
          isMounted.current = true;
          return () => {
            isMounted.current = false;
          };
        }, []);
        const actualChildPropsSelector = React__namespace.useMemo(() => {
          const selector = () => {
            if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
              return childPropsFromStoreUpdate.current;
            }
            return childPropsSelector(store.getState(), wrapperProps);
          };
          return selector;
        }, [store, wrapperProps]);
        const subscribeForReact = React__namespace.useMemo(() => {
          const subscribe = (reactListener) => {
            if (!subscription) {
              return () => {
              };
            }
            return subscribeUpdates(
              shouldHandleStateChanges,
              store,
              subscription,
              // @ts-ignore
              childPropsSelector,
              lastWrapperProps,
              lastChildProps,
              renderIsScheduled,
              isMounted,
              childPropsFromStoreUpdate,
              notifyNestedSubs,
              reactListener
            );
          };
          return subscribe;
        }, [subscription]);
        useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [
          lastWrapperProps,
          lastChildProps,
          renderIsScheduled,
          wrapperProps,
          childPropsFromStoreUpdate,
          notifyNestedSubs
        ]);
        let actualChildProps;
        try {
          actualChildProps = React__namespace.useSyncExternalStore(
            // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing
            subscribeForReact,
            // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,
            // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.
            actualChildPropsSelector,
            getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector
          );
        } catch (err) {
          if (latestSubscriptionCallbackError.current) {
            ;
            err.message += `
The error may be correlated with this previous error:
${latestSubscriptionCallbackError.current.stack}

`;
          }
          throw err;
        }
        useIsomorphicLayoutEffect(() => {
          latestSubscriptionCallbackError.current = void 0;
          childPropsFromStoreUpdate.current = void 0;
          lastChildProps.current = actualChildProps;
        });
        const renderedWrappedComponent = React__namespace.useMemo(() => {
          return (
            // @ts-ignore
            /* @__PURE__ */ React__namespace.createElement(
              WrappedComponent,
              {
                ...actualChildProps,
                ref: reactReduxForwardedRef
              }
            )
          );
        }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
        const renderedChild = React__namespace.useMemo(() => {
          if (shouldHandleStateChanges) {
            return /* @__PURE__ */ React__namespace.createElement(ContextToUse.Provider, { value: overriddenContextValue }, renderedWrappedComponent);
          }
          return renderedWrappedComponent;
        }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
        return renderedChild;
      }
      const _Connect = React__namespace.memo(ConnectFunction);
      const Connect = _Connect;
      Connect.WrappedComponent = WrappedComponent;
      Connect.displayName = ConnectFunction.displayName = displayName;
      if (forwardRef) {
        const _forwarded = React__namespace.forwardRef(
          function forwardConnectRef(props, ref) {
            return /* @__PURE__ */ React__namespace.createElement(Connect, { ...props, reactReduxForwardedRef: ref });
          }
        );
        const forwarded = _forwarded;
        forwarded.displayName = displayName;
        forwarded.WrappedComponent = WrappedComponent;
        return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);
      }
      return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);
    };
    return wrapWithConnect;
  }
  var connect_default = connect;
  function Provider(providerProps) {
    const { children, context, serverState, store } = providerProps;
    const contextValue = React__namespace.useMemo(() => {
      const subscription = createSubscription(store);
      const baseContextValue = {
        store,
        subscription,
        getServerState: serverState ? () => serverState : void 0
      };
      if (false) {
        return baseContextValue;
      } else {
        const { identityFunctionCheck = "once", stabilityCheck = "once" } = providerProps;
        return /* @__PURE__ */ Object.assign(baseContextValue, {
          stabilityCheck,
          identityFunctionCheck
        });
      }
    }, [store, serverState]);
    const previousState = React__namespace.useMemo(() => store.getState(), [store]);
    useIsomorphicLayoutEffect(() => {
      const { subscription } = contextValue;
      subscription.onStateChange = subscription.notifyNestedSubs;
      subscription.trySubscribe();
      if (previousState !== store.getState()) {
        subscription.notifyNestedSubs();
      }
      return () => {
        subscription.tryUnsubscribe();
        subscription.onStateChange = void 0;
      };
    }, [contextValue, previousState]);
    const Context = context || ReactReduxContext;
    return /* @__PURE__ */ React__namespace.createElement(Context.Provider, { value: contextValue }, children);
  }
  var Provider_default = Provider;
  function createReduxContextHook(context = ReactReduxContext) {
    return function useReduxContext2() {
      const contextValue = React__namespace.useContext(context);
      if (!contextValue) {
        throw new Error(
          "could not find react-redux context value; please ensure the component is wrapped in a <Provider>"
        );
      }
      return contextValue;
    };
  }
  var useReduxContext = /* @__PURE__ */ createReduxContextHook();
  function createStoreHook(context = ReactReduxContext) {
    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (
      // @ts-ignore
      createReduxContextHook(context)
    );
    const useStore2 = () => {
      const { store } = useReduxContext2();
      return store;
    };
    Object.assign(useStore2, {
      withTypes: () => useStore2
    });
    return useStore2;
  }
  var useStore = /* @__PURE__ */ createStoreHook();
  function createDispatchHook(context = ReactReduxContext) {
    const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
    const useDispatch2 = () => {
      const store = useStore2();
      return store.dispatch;
    };
    Object.assign(useDispatch2, {
      withTypes: () => useDispatch2
    });
    return useDispatch2;
  }
  var useDispatch = /* @__PURE__ */ createDispatchHook();
  var refEquality = (a2, b) => a2 === b;
  function createSelectorHook(context = ReactReduxContext) {
    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
    const useSelector2 = (selector, equalityFnOrOptions = {}) => {
      const { equalityFn = refEquality } = typeof equalityFnOrOptions === "function" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;
      if (true) {
        if (!selector) {
          throw new Error(`You must pass a selector to useSelector`);
        }
        if (typeof selector !== "function") {
          throw new Error(`You must pass a function as a selector to useSelector`);
        }
        if (typeof equalityFn !== "function") {
          throw new Error(
            `You must pass a function as an equality function to useSelector`
          );
        }
      }
      const reduxContext = useReduxContext2();
      const { store, subscription, getServerState } = reduxContext;
      const firstRun = React__namespace.useRef(true);
      const wrappedSelector = React__namespace.useCallback(
        {
          [selector.name](state) {
            const selected = selector(state);
            if (true) {
              const { devModeChecks = {} } = typeof equalityFnOrOptions === "function" ? {} : equalityFnOrOptions;
              const { identityFunctionCheck, stabilityCheck } = reduxContext;
              const {
                identityFunctionCheck: finalIdentityFunctionCheck,
                stabilityCheck: finalStabilityCheck
              } = {
                stabilityCheck,
                identityFunctionCheck,
                ...devModeChecks
              };
              if (finalStabilityCheck === "always" || finalStabilityCheck === "once" && firstRun.current) {
                const toCompare = selector(state);
                if (!equalityFn(selected, toCompare)) {
                  let stack = void 0;
                  try {
                    throw new Error();
                  } catch (e) {
                    ;
                    ({ stack } = e);
                  }
                  console.warn(
                    "Selector " + (selector.name || "unknown") + " returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization",
                    {
                      state,
                      selected,
                      selected2: toCompare,
                      stack
                    }
                  );
                }
              }
              if (finalIdentityFunctionCheck === "always" || finalIdentityFunctionCheck === "once" && firstRun.current) {
                if (selected === state) {
                  let stack = void 0;
                  try {
                    throw new Error();
                  } catch (e) {
                    ;
                    ({ stack } = e);
                  }
                  console.warn(
                    "Selector " + (selector.name || "unknown") + " returned the root state when called. This can lead to unnecessary rerenders.\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.",
                    { stack }
                  );
                }
              }
              if (firstRun.current) firstRun.current = false;
            }
            return selected;
          }
        }[selector.name],
        [selector]
      );
      const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(
        subscription.addNestedSub,
        store.getState,
        getServerState || store.getState,
        wrappedSelector,
        equalityFn
      );
      React__namespace.useDebugValue(selectedState);
      return selectedState;
    };
    Object.assign(useSelector2, {
      withTypes: () => useSelector2
    });
    return useSelector2;
  }
  var useSelector = /* @__PURE__ */ createSelectorHook();
  var batch = defaultNoopBatch;
  var pickChartPointer = (_state, chartPointer) => chartPointer;
  var selectActivePropsFromChartPointer = createSelector([pickChartPointer, selectChartLayout, selectPolarViewBox, selectTooltipAxisType, selectTooltipAxisRangeWithReverse, selectTooltipAxisTicks, selectOrderedTooltipTicks, selectChartOffsetInternal], combineActiveProps);
  var getChartPointer = (event) => {
    var rect = event.currentTarget.getBoundingClientRect();
    var scaleX = rect.width / event.currentTarget.offsetWidth;
    var scaleY = rect.height / event.currentTarget.offsetHeight;
    return {
      /*
       * Here it's important to use:
       * - event.clientX and event.clientY to get the mouse position relative to the viewport, including scroll.
       * - pageX and pageY are not used because they are relative to the whole document, and ignore scroll.
       * - rect.left and rect.top are used to get the position of the chart relative to the viewport.
       * - offsetX and offsetY are not used because they are relative to the offset parent
       *  which may or may not be the same as the clientX and clientY, depending on the position of the chart in the DOM
       *  and surrounding element styles. CSS position: relative, absolute, fixed, will change the offset parent.
       * - scaleX and scaleY are necessary for when the chart element is scaled using CSS `transform: scale(N)`.
       */
      chartX: Math.round((event.clientX - rect.left) / scaleX),
      chartY: Math.round((event.clientY - rect.top) / scaleY)
    };
  };
  var mouseClickAction = createAction("mouseClick");
  var mouseClickMiddleware = createListenerMiddleware();
  mouseClickMiddleware.startListening({
    actionCreator: mouseClickAction,
    effect: (action, listenerApi) => {
      var mousePointer = action.payload;
      var activeProps = selectActivePropsFromChartPointer(listenerApi.getState(), getChartPointer(mousePointer));
      if ((activeProps === null || activeProps === void 0 ? void 0 : activeProps.activeIndex) != null) {
        listenerApi.dispatch(setMouseClickAxisIndex({
          activeIndex: activeProps.activeIndex,
          activeDataKey: void 0,
          activeCoordinate: activeProps.activeCoordinate
        }));
      }
    }
  });
  var mouseMoveAction = createAction("mouseMove");
  var mouseMoveMiddleware = createListenerMiddleware();
  mouseMoveMiddleware.startListening({
    actionCreator: mouseMoveAction,
    effect: (action, listenerApi) => {
      var mousePointer = action.payload;
      var state = listenerApi.getState();
      var tooltipEventType = selectTooltipEventType$1(state, state.tooltip.settings.shared);
      var activeProps = selectActivePropsFromChartPointer(state, getChartPointer(mousePointer));
      if (tooltipEventType === "axis") {
        if ((activeProps === null || activeProps === void 0 ? void 0 : activeProps.activeIndex) != null) {
          listenerApi.dispatch(setMouseOverAxisIndex({
            activeIndex: activeProps.activeIndex,
            activeDataKey: void 0,
            activeCoordinate: activeProps.activeCoordinate
          }));
        } else {
          listenerApi.dispatch(mouseLeaveChart());
        }
      }
    }
  });
  function reduxDevtoolsJsonStringifyReplacer(_key, value) {
    if (value instanceof HTMLElement) {
      return "HTMLElement <".concat(value.tagName, ' class="').concat(value.className, '">');
    }
    if (value === window) {
      return "global.window";
    }
    return value;
  }
  var initialState = {
    accessibilityLayer: true,
    barCategoryGap: "10%",
    barGap: 4,
    barSize: void 0,
    className: void 0,
    maxBarSize: void 0,
    stackOffset: "none",
    syncId: void 0,
    syncMethod: "index"
  };
  var rootPropsSlice = createSlice({
    name: "rootProps",
    initialState,
    reducers: {
      updateOptions: (state, action) => {
        var _action$payload$barGa;
        state.accessibilityLayer = action.payload.accessibilityLayer;
        state.barCategoryGap = action.payload.barCategoryGap;
        state.barGap = (_action$payload$barGa = action.payload.barGap) !== null && _action$payload$barGa !== void 0 ? _action$payload$barGa : initialState.barGap;
        state.barSize = action.payload.barSize;
        state.maxBarSize = action.payload.maxBarSize;
        state.stackOffset = action.payload.stackOffset;
        state.syncId = action.payload.syncId;
        state.syncMethod = action.payload.syncMethod;
        state.className = action.payload.className;
      }
    }
  });
  var rootPropsReducer = rootPropsSlice.reducer;
  var {
    updateOptions
  } = rootPropsSlice.actions;
  var polarOptionsSlice = createSlice({
    name: "polarOptions",
    initialState: null,
    reducers: {
      updatePolarOptions: (_state, action) => {
        return action.payload;
      }
    }
  });
  var {
    updatePolarOptions
  } = polarOptionsSlice.actions;
  var polarOptionsReducer = polarOptionsSlice.reducer;
  var keyDownAction = createAction("keyDown");
  var focusAction = createAction("focus");
  var keyboardEventsMiddleware = createListenerMiddleware();
  keyboardEventsMiddleware.startListening({
    actionCreator: keyDownAction,
    effect: (action, listenerApi) => {
      var state = listenerApi.getState();
      var accessibilityLayerIsActive = state.rootProps.accessibilityLayer !== false;
      if (!accessibilityLayerIsActive) {
        return;
      }
      var {
        keyboardInteraction
      } = state.tooltip;
      var key = action.payload;
      if (key !== "ArrowRight" && key !== "ArrowLeft" && key !== "Enter") {
        return;
      }
      var currentIndex = Number(combineActiveTooltipIndex(keyboardInteraction, selectTooltipDisplayedData(state)));
      var tooltipTicks = selectTooltipAxisTicks(state);
      if (key === "Enter") {
        var _coordinate = selectCoordinateForDefaultIndex(state, "axis", "hover", String(keyboardInteraction.index));
        listenerApi.dispatch(setKeyboardInteraction({
          active: !keyboardInteraction.active,
          activeIndex: keyboardInteraction.index,
          activeDataKey: keyboardInteraction.dataKey,
          activeCoordinate: _coordinate
        }));
        return;
      }
      var direction = selectChartDirection(state);
      var directionMultiplier = direction === "left-to-right" ? 1 : -1;
      var movement = key === "ArrowRight" ? 1 : -1;
      var nextIndex = currentIndex + movement * directionMultiplier;
      if (tooltipTicks == null || nextIndex >= tooltipTicks.length || nextIndex < 0) {
        return;
      }
      var coordinate = selectCoordinateForDefaultIndex(state, "axis", "hover", String(nextIndex));
      listenerApi.dispatch(setKeyboardInteraction({
        active: true,
        activeIndex: nextIndex.toString(),
        activeDataKey: void 0,
        activeCoordinate: coordinate
      }));
    }
  });
  keyboardEventsMiddleware.startListening({
    actionCreator: focusAction,
    effect: (_action, listenerApi) => {
      var state = listenerApi.getState();
      var accessibilityLayerIsActive = state.rootProps.accessibilityLayer !== false;
      if (!accessibilityLayerIsActive) {
        return;
      }
      var {
        keyboardInteraction
      } = state.tooltip;
      if (keyboardInteraction.active) {
        return;
      }
      if (keyboardInteraction.index == null) {
        var nextIndex = "0";
        var coordinate = selectCoordinateForDefaultIndex(state, "axis", "hover", String(nextIndex));
        listenerApi.dispatch(setKeyboardInteraction({
          activeDataKey: void 0,
          active: true,
          activeIndex: nextIndex,
          activeCoordinate: coordinate
        }));
      }
    }
  });
  var externalEventAction = createAction("externalEvent");
  var externalEventsMiddleware = createListenerMiddleware();
  externalEventsMiddleware.startListening({
    actionCreator: externalEventAction,
    effect: (action, listenerApi) => {
      if (action.payload.handler == null) {
        return;
      }
      var state = listenerApi.getState();
      var nextState = {
        activeCoordinate: selectActiveTooltipCoordinate(state),
        activeDataKey: selectActiveTooltipDataKey(state),
        activeIndex: selectActiveTooltipIndex(state),
        activeLabel: selectActiveLabel$1(state),
        activeTooltipIndex: selectActiveTooltipIndex(state),
        isTooltipActive: selectIsTooltipActive$1(state)
      };
      action.payload.handler(nextState, action.payload.reactEvent);
    }
  });
  var selectAllTooltipPayloadConfiguration = createSelector([selectTooltipState], (tooltipState) => tooltipState.tooltipItemPayloads);
  var selectTooltipCoordinate = createSelector([selectAllTooltipPayloadConfiguration, selectTooltipPayloadSearcher, (_state, tooltipIndex, _dataKey) => tooltipIndex, (_state, _tooltipIndex, dataKey) => dataKey], (allTooltipConfigurations, tooltipPayloadSearcher, tooltipIndex, dataKey) => {
    var mostRelevantTooltipConfiguration = allTooltipConfigurations.find((tooltipConfiguration) => {
      return tooltipConfiguration.settings.dataKey === dataKey;
    });
    if (mostRelevantTooltipConfiguration == null) {
      return void 0;
    }
    var {
      positions
    } = mostRelevantTooltipConfiguration;
    if (positions == null) {
      return void 0;
    }
    var maybePosition = tooltipPayloadSearcher(positions, tooltipIndex);
    return maybePosition;
  });
  var touchEventAction = createAction("touchMove");
  var touchEventMiddleware = createListenerMiddleware();
  touchEventMiddleware.startListening({
    actionCreator: touchEventAction,
    effect: (action, listenerApi) => {
      var touchEvent = action.payload;
      var state = listenerApi.getState();
      var tooltipEventType = selectTooltipEventType$1(state, state.tooltip.settings.shared);
      if (tooltipEventType === "axis") {
        var activeProps = selectActivePropsFromChartPointer(state, getChartPointer({
          clientX: touchEvent.touches[0].clientX,
          clientY: touchEvent.touches[0].clientY,
          currentTarget: touchEvent.currentTarget
        }));
        if ((activeProps === null || activeProps === void 0 ? void 0 : activeProps.activeIndex) != null) {
          listenerApi.dispatch(setMouseOverAxisIndex({
            activeIndex: activeProps.activeIndex,
            activeDataKey: void 0,
            activeCoordinate: activeProps.activeCoordinate
          }));
        }
      } else if (tooltipEventType === "item") {
        var _target$getAttribute;
        var touch = touchEvent.touches[0];
        var target = document.elementFromPoint(touch.clientX, touch.clientY);
        if (!target || !target.getAttribute) {
          return;
        }
        var itemIndex = target.getAttribute(DATA_ITEM_INDEX_ATTRIBUTE_NAME);
        var dataKey = (_target$getAttribute = target.getAttribute(DATA_ITEM_DATAKEY_ATTRIBUTE_NAME)) !== null && _target$getAttribute !== void 0 ? _target$getAttribute : void 0;
        var coordinate = selectTooltipCoordinate(listenerApi.getState(), itemIndex, dataKey);
        listenerApi.dispatch(setActiveMouseOverItemIndex({
          activeDataKey: dataKey,
          activeIndex: itemIndex,
          activeCoordinate: coordinate
        }));
      }
    }
  });
  var rootReducer = combineReducers({
    brush: brushReducer,
    cartesianAxis: cartesianAxisReducer,
    chartData: chartDataReducer,
    errorBars: errorBarReducer,
    graphicalItems: graphicalItemsReducer,
    layout: chartLayoutReducer,
    legend: legendReducer,
    options: optionsReducer,
    polarAxis: polarAxisReducer,
    polarOptions: polarOptionsReducer,
    referenceElements: referenceElementsReducer,
    rootProps: rootPropsReducer,
    tooltip: tooltipReducer
  });
  var createRechartsStore = function createRechartsStore2(preloadedState2) {
    var chartName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Chart";
    return configureStore({
      reducer: rootReducer,
      // redux-toolkit v1 types are unhappy with the preloadedState type. Remove the `as any` when bumping to v2
      preloadedState: preloadedState2,
      // @ts-expect-error redux-toolkit v1 types are unhappy with the middleware array. Remove this comment when bumping to v2
      middleware: (getDefaultMiddleware) => getDefaultMiddleware({
        serializableCheck: false
      }).concat([mouseClickMiddleware.middleware, mouseMoveMiddleware.middleware, keyboardEventsMiddleware.middleware, externalEventsMiddleware.middleware, touchEventMiddleware.middleware]),
      devTools: {
        serialize: {
          replacer: reduxDevtoolsJsonStringifyReplacer
        },
        name: "recharts-".concat(chartName)
      }
    });
  };
  function RechartsStoreProvider(_ref2) {
    var {
      preloadedState: preloadedState2,
      children,
      reduxStoreName
    } = _ref2;
    var isPanorama = useIsPanorama();
    var storeRef = React.useRef(null);
    if (isPanorama) {
      return children;
    }
    if (storeRef.current == null) {
      storeRef.current = createRechartsStore(preloadedState2, reduxStoreName);
    }
    var nonNullContext = RechartsReduxContext;
    return /* @__PURE__ */ React__namespace.createElement(Provider_default, {
      context: nonNullContext,
      store: storeRef.current
    }, children);
  }
  function ReportMainChartProps(_ref2) {
    var {
      layout,
      width,
      height,
      margin
    } = _ref2;
    var dispatch = useAppDispatch();
    var isPanorama = useIsPanorama();
    React.useEffect(() => {
      if (!isPanorama) {
        dispatch(setLayout(layout));
        dispatch(setChartSize({
          width,
          height
        }));
        dispatch(setMargin(margin));
      }
    }, [dispatch, isPanorama, layout, width, height, margin]);
    return null;
  }
  function ReportChartProps(props) {
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(updateOptions(props));
    }, [dispatch, props]);
    return null;
  }
  var _excluded$6 = ["children"];
  function _objectWithoutProperties$6(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$6(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$6(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function _extends$7() {
    return _extends$7 = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$7.apply(null, arguments);
  }
  var FULL_WIDTH_AND_HEIGHT = {
    width: "100%",
    height: "100%"
  };
  var MainChartSurface = /* @__PURE__ */ React.forwardRef((props, ref) => {
    var width = useChartWidth();
    var height = useChartHeight();
    var hasAccessibilityLayer = useAccessibilityLayer();
    if (!isPositiveNumber(width) || !isPositiveNumber(height)) {
      return null;
    }
    var {
      children,
      otherAttributes,
      title,
      desc
    } = props;
    var tabIndex, role;
    if (typeof otherAttributes.tabIndex === "number") {
      tabIndex = otherAttributes.tabIndex;
    } else {
      tabIndex = hasAccessibilityLayer ? 0 : void 0;
    }
    if (typeof otherAttributes.role === "string") {
      role = otherAttributes.role;
    } else {
      role = hasAccessibilityLayer ? "application" : void 0;
    }
    return /* @__PURE__ */ React__namespace.createElement(Surface, _extends$7({}, otherAttributes, {
      title,
      desc,
      role,
      tabIndex,
      width,
      height,
      style: FULL_WIDTH_AND_HEIGHT,
      ref
    }), children);
  });
  var BrushPanoramaSurface = (_ref2) => {
    var {
      children
    } = _ref2;
    var brushDimensions = useAppSelector(selectBrushDimensions);
    if (!brushDimensions) {
      return null;
    }
    var {
      width,
      height,
      y: y2,
      x: x2
    } = brushDimensions;
    return /* @__PURE__ */ React__namespace.createElement(Surface, {
      width,
      height,
      x: x2,
      y: y2
    }, children);
  };
  var RootSurface = /* @__PURE__ */ React.forwardRef((_ref2, ref) => {
    var {
      children
    } = _ref2, rest2 = _objectWithoutProperties$6(_ref2, _excluded$6);
    var isPanorama = useIsPanorama();
    if (isPanorama) {
      return /* @__PURE__ */ React__namespace.createElement(BrushPanoramaSurface, null, children);
    }
    return /* @__PURE__ */ React__namespace.createElement(MainChartSurface, _extends$7({
      ref
    }, rest2), children);
  });
  function useReportScale() {
    var dispatch = useAppDispatch();
    var [ref, setRef] = React.useState(null);
    var scale = useAppSelector(selectContainerScale);
    React.useEffect(() => {
      if (ref == null) {
        return;
      }
      var rect = ref.getBoundingClientRect();
      var newScale = rect.width / ref.offsetWidth;
      if (isWellBehavedNumber(newScale) && newScale !== scale) {
        dispatch(setScale(newScale));
      }
    }, [ref, dispatch, scale]);
    return setRef;
  }
  function ownKeys$6(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$6(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$6(Object(t), true).forEach(function(r3) {
        _defineProperty$6(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$6(e, r2, t) {
    return (r2 = _toPropertyKey$6(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$6(t) {
    var i = _toPrimitive$6(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$6(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var RechartsWrapper = /* @__PURE__ */ React.forwardRef((_ref2, ref) => {
    var {
      children,
      className,
      height,
      onClick,
      onContextMenu,
      onDoubleClick,
      onMouseDown,
      onMouseEnter,
      onMouseLeave,
      onMouseMove,
      onMouseUp,
      onTouchEnd,
      onTouchMove,
      onTouchStart,
      style,
      width
    } = _ref2;
    var dispatch = useAppDispatch();
    var [tooltipPortal, setTooltipPortal] = React.useState(null);
    var [legendPortal, setLegendPortal] = React.useState(null);
    useSynchronisedEventsFromOtherCharts();
    var setScaleRef = useReportScale();
    var innerRef = React.useCallback((node) => {
      setScaleRef(node);
      if (typeof ref === "function") {
        ref(node);
      }
      setTooltipPortal(node);
      setLegendPortal(node);
    }, [setScaleRef, ref, setTooltipPortal, setLegendPortal]);
    var myOnClick = React.useCallback((e) => {
      dispatch(mouseClickAction(e));
      dispatch(externalEventAction({
        handler: onClick,
        reactEvent: e
      }));
    }, [dispatch, onClick]);
    var myOnMouseEnter = React.useCallback((e) => {
      dispatch(mouseMoveAction(e));
      dispatch(externalEventAction({
        handler: onMouseEnter,
        reactEvent: e
      }));
    }, [dispatch, onMouseEnter]);
    var myOnMouseLeave = React.useCallback((e) => {
      dispatch(mouseLeaveChart());
      dispatch(externalEventAction({
        handler: onMouseLeave,
        reactEvent: e
      }));
    }, [dispatch, onMouseLeave]);
    var myOnMouseMove = React.useCallback((e) => {
      dispatch(mouseMoveAction(e));
      dispatch(externalEventAction({
        handler: onMouseMove,
        reactEvent: e
      }));
    }, [dispatch, onMouseMove]);
    var onFocus = React.useCallback(() => {
      dispatch(focusAction());
    }, [dispatch]);
    var onKeyDown = React.useCallback((e) => {
      dispatch(keyDownAction(e.key));
    }, [dispatch]);
    var myOnContextMenu = React.useCallback((e) => {
      dispatch(externalEventAction({
        handler: onContextMenu,
        reactEvent: e
      }));
    }, [dispatch, onContextMenu]);
    var myOnDoubleClick = React.useCallback((e) => {
      dispatch(externalEventAction({
        handler: onDoubleClick,
        reactEvent: e
      }));
    }, [dispatch, onDoubleClick]);
    var myOnMouseDown = React.useCallback((e) => {
      dispatch(externalEventAction({
        handler: onMouseDown,
        reactEvent: e
      }));
    }, [dispatch, onMouseDown]);
    var myOnMouseUp = React.useCallback((e) => {
      dispatch(externalEventAction({
        handler: onMouseUp,
        reactEvent: e
      }));
    }, [dispatch, onMouseUp]);
    var myOnTouchStart = React.useCallback((e) => {
      dispatch(externalEventAction({
        handler: onTouchStart,
        reactEvent: e
      }));
    }, [dispatch, onTouchStart]);
    var myOnTouchMove = React.useCallback((e) => {
      dispatch(touchEventAction(e));
      dispatch(externalEventAction({
        handler: onTouchMove,
        reactEvent: e
      }));
    }, [dispatch, onTouchMove]);
    var myOnTouchEnd = React.useCallback((e) => {
      dispatch(externalEventAction({
        handler: onTouchEnd,
        reactEvent: e
      }));
    }, [dispatch, onTouchEnd]);
    return /* @__PURE__ */ React__namespace.createElement(TooltipPortalContext.Provider, {
      value: tooltipPortal
    }, /* @__PURE__ */ React__namespace.createElement(LegendPortalContext.Provider, {
      value: legendPortal
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      className: clsx("recharts-wrapper", className),
      style: _objectSpread$6({
        position: "relative",
        cursor: "default",
        width,
        height
      }, style),
      onClick: myOnClick,
      onContextMenu: myOnContextMenu,
      onDoubleClick: myOnDoubleClick,
      onFocus,
      onKeyDown,
      onMouseDown: myOnMouseDown,
      onMouseEnter: myOnMouseEnter,
      onMouseLeave: myOnMouseLeave,
      onMouseMove: myOnMouseMove,
      onMouseUp: myOnMouseUp,
      onTouchEnd: myOnTouchEnd,
      onTouchMove: myOnTouchMove,
      onTouchStart: myOnTouchStart,
      ref: innerRef
    }, children)));
  });
  var _excluded$5 = ["children", "className", "width", "height", "style", "compact", "title", "desc"];
  function _objectWithoutProperties$5(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$5(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$5(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var CategoricalChart = /* @__PURE__ */ React.forwardRef((props, ref) => {
    var {
      children,
      className,
      width,
      height,
      style,
      compact: compact2,
      title,
      desc
    } = props, others = _objectWithoutProperties$5(props, _excluded$5);
    var attrs = svgPropertiesNoEvents(others);
    if (compact2) {
      return /* @__PURE__ */ React__namespace.createElement(RootSurface, {
        otherAttributes: attrs,
        title,
        desc
      }, children);
    }
    return /* @__PURE__ */ React__namespace.createElement(RechartsWrapper, {
      className,
      style,
      width,
      height,
      onClick: props.onClick,
      onMouseLeave: props.onMouseLeave,
      onMouseEnter: props.onMouseEnter,
      onMouseMove: props.onMouseMove,
      onMouseDown: props.onMouseDown,
      onMouseUp: props.onMouseUp,
      onContextMenu: props.onContextMenu,
      onDoubleClick: props.onDoubleClick,
      onTouchStart: props.onTouchStart,
      onTouchMove: props.onTouchMove,
      onTouchEnd: props.onTouchEnd
    }, /* @__PURE__ */ React__namespace.createElement(RootSurface, {
      otherAttributes: attrs,
      title,
      desc,
      ref
    }, /* @__PURE__ */ React__namespace.createElement(ClipPathProvider, null, children)));
  });
  var _excluded$4 = ["width", "height"];
  function _extends$6() {
    return _extends$6 = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$6.apply(null, arguments);
  }
  function _objectWithoutProperties$4(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$4(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$4(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var defaultMargin$1 = {
    top: 5,
    right: 5,
    bottom: 5,
    left: 5
  };
  var defaultProps$4 = {
    accessibilityLayer: true,
    layout: "horizontal",
    stackOffset: "none",
    barCategoryGap: "10%",
    barGap: 4,
    margin: defaultMargin$1,
    reverseStackOrder: false,
    syncMethod: "index"
  };
  var CartesianChart = /* @__PURE__ */ React.forwardRef(function CartesianChart2(props, ref) {
    var _categoricalChartProp;
    var rootChartProps = resolveDefaultProps(props.categoricalChartProps, defaultProps$4);
    var {
      width,
      height
    } = rootChartProps, otherCategoricalProps = _objectWithoutProperties$4(rootChartProps, _excluded$4);
    if (!isPositiveNumber(width) || !isPositiveNumber(height)) {
      return null;
    }
    var {
      chartName,
      defaultTooltipEventType,
      validateTooltipEventTypes,
      tooltipPayloadSearcher,
      categoricalChartProps
    } = props;
    var options2 = {
      chartName,
      defaultTooltipEventType,
      validateTooltipEventTypes,
      tooltipPayloadSearcher,
      eventEmitter: void 0
    };
    return /* @__PURE__ */ React__namespace.createElement(RechartsStoreProvider, {
      preloadedState: {
        options: options2
      },
      reduxStoreName: (_categoricalChartProp = categoricalChartProps.id) !== null && _categoricalChartProp !== void 0 ? _categoricalChartProp : chartName
    }, /* @__PURE__ */ React__namespace.createElement(ChartDataContextProvider, {
      chartData: categoricalChartProps.data
    }), /* @__PURE__ */ React__namespace.createElement(ReportMainChartProps, {
      width,
      height,
      layout: rootChartProps.layout,
      margin: rootChartProps.margin
    }), /* @__PURE__ */ React__namespace.createElement(ReportChartProps, {
      accessibilityLayer: rootChartProps.accessibilityLayer,
      barCategoryGap: rootChartProps.barCategoryGap,
      maxBarSize: rootChartProps.maxBarSize,
      stackOffset: rootChartProps.stackOffset,
      barGap: rootChartProps.barGap,
      barSize: rootChartProps.barSize,
      syncId: rootChartProps.syncId,
      syncMethod: rootChartProps.syncMethod,
      className: rootChartProps.className
    }), /* @__PURE__ */ React__namespace.createElement(CategoricalChart, _extends$6({}, otherCategoricalProps, {
      width,
      height,
      ref
    })));
  });
  var allowedTooltipTypes$8 = ["axis"];
  var LineChart = /* @__PURE__ */ React.forwardRef((props, ref) => {
    return /* @__PURE__ */ React__namespace.createElement(CartesianChart, {
      chartName: "LineChart",
      defaultTooltipEventType: "axis",
      validateTooltipEventTypes: allowedTooltipTypes$8,
      tooltipPayloadSearcher: arrayTooltipSearcher,
      categoricalChartProps: props,
      ref
    });
  });
  var allowedTooltipTypes$7 = ["axis", "item"];
  var BarChart = /* @__PURE__ */ React.forwardRef((props, ref) => {
    return /* @__PURE__ */ React__namespace.createElement(CartesianChart, {
      chartName: "BarChart",
      defaultTooltipEventType: "axis",
      validateTooltipEventTypes: allowedTooltipTypes$7,
      tooltipPayloadSearcher: arrayTooltipSearcher,
      categoricalChartProps: props,
      ref
    });
  });
  function ReportPolarOptions(props) {
    var dispatch = useAppDispatch();
    React.useEffect(() => {
      dispatch(updatePolarOptions(props));
    }, [dispatch, props]);
    return null;
  }
  var _excluded$3 = ["width", "height", "layout"];
  function _extends$5() {
    return _extends$5 = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$5.apply(null, arguments);
  }
  function _objectWithoutProperties$3(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$3(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$3(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  var defaultMargin = {
    top: 5,
    right: 5,
    bottom: 5,
    left: 5
  };
  var defaultProps$3 = {
    accessibilityLayer: true,
    stackOffset: "none",
    barCategoryGap: "10%",
    barGap: 4,
    margin: defaultMargin,
    reverseStackOrder: false,
    syncMethod: "index",
    layout: "radial"
  };
  var PolarChart = /* @__PURE__ */ React.forwardRef(function PolarChart2(props, ref) {
    var _polarChartProps$id;
    var polarChartProps = resolveDefaultProps(props.categoricalChartProps, defaultProps$3);
    var {
      width,
      height,
      layout
    } = polarChartProps, otherCategoricalProps = _objectWithoutProperties$3(polarChartProps, _excluded$3);
    if (!isPositiveNumber(width) || !isPositiveNumber(height)) {
      return null;
    }
    var {
      chartName,
      defaultTooltipEventType,
      validateTooltipEventTypes,
      tooltipPayloadSearcher
    } = props;
    var options2 = {
      chartName,
      defaultTooltipEventType,
      validateTooltipEventTypes,
      tooltipPayloadSearcher,
      eventEmitter: void 0
    };
    return /* @__PURE__ */ React__namespace.createElement(RechartsStoreProvider, {
      preloadedState: {
        options: options2
      },
      reduxStoreName: (_polarChartProps$id = polarChartProps.id) !== null && _polarChartProps$id !== void 0 ? _polarChartProps$id : chartName
    }, /* @__PURE__ */ React__namespace.createElement(ChartDataContextProvider, {
      chartData: polarChartProps.data
    }), /* @__PURE__ */ React__namespace.createElement(ReportMainChartProps, {
      width,
      height,
      layout,
      margin: polarChartProps.margin
    }), /* @__PURE__ */ React__namespace.createElement(ReportChartProps, {
      accessibilityLayer: polarChartProps.accessibilityLayer,
      barCategoryGap: polarChartProps.barCategoryGap,
      maxBarSize: polarChartProps.maxBarSize,
      stackOffset: polarChartProps.stackOffset,
      barGap: polarChartProps.barGap,
      barSize: polarChartProps.barSize,
      syncId: polarChartProps.syncId,
      syncMethod: polarChartProps.syncMethod,
      className: polarChartProps.className
    }), /* @__PURE__ */ React__namespace.createElement(ReportPolarOptions, {
      cx: polarChartProps.cx,
      cy: polarChartProps.cy,
      startAngle: polarChartProps.startAngle,
      endAngle: polarChartProps.endAngle,
      innerRadius: polarChartProps.innerRadius,
      outerRadius: polarChartProps.outerRadius
    }), /* @__PURE__ */ React__namespace.createElement(CategoricalChart, _extends$5({
      width,
      height
    }, otherCategoricalProps, {
      ref
    })));
  });
  var allowedTooltipTypes$6 = ["item"];
  var defaultProps$2 = {
    layout: "centric",
    startAngle: 0,
    endAngle: 360,
    cx: "50%",
    cy: "50%",
    innerRadius: 0,
    outerRadius: "80%"
  };
  var PieChart = /* @__PURE__ */ React.forwardRef((props, ref) => {
    var propsWithDefaults = resolveDefaultProps(props, defaultProps$2);
    return /* @__PURE__ */ React__namespace.createElement(PolarChart, {
      chartName: "PieChart",
      defaultTooltipEventType: "item",
      validateTooltipEventTypes: allowedTooltipTypes$6,
      tooltipPayloadSearcher: arrayTooltipSearcher,
      categoricalChartProps: propsWithDefaults,
      ref
    });
  });
  var omit$3 = {};
  var unset$1 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const get2 = get$4;
    const isUnsafeProperty2 = isUnsafeProperty$2;
    const isDeepKey2 = isDeepKey$1;
    const toKey2 = toKey$1;
    const toPath2 = toPath$1;
    function unset2(obj, path2) {
      if (obj == null) {
        return true;
      }
      switch (typeof path2) {
        case "symbol":
        case "number":
        case "object": {
          if (Array.isArray(path2)) {
            return unsetWithPath(obj, path2);
          }
          if (typeof path2 === "number") {
            path2 = toKey2.toKey(path2);
          } else if (typeof path2 === "object") {
            if (Object.is(path2 == null ? void 0 : path2.valueOf(), -0)) {
              path2 = "-0";
            } else {
              path2 = String(path2);
            }
          }
          if (isUnsafeProperty2.isUnsafeProperty(path2)) {
            return false;
          }
          if ((obj == null ? void 0 : obj[path2]) === void 0) {
            return true;
          }
          try {
            delete obj[path2];
            return true;
          } catch {
            return false;
          }
        }
        case "string": {
          if ((obj == null ? void 0 : obj[path2]) === void 0 && isDeepKey2.isDeepKey(path2)) {
            return unsetWithPath(obj, toPath2.toPath(path2));
          }
          if (isUnsafeProperty2.isUnsafeProperty(path2)) {
            return false;
          }
          try {
            delete obj[path2];
            return true;
          } catch {
            return false;
          }
        }
      }
    }
    function unsetWithPath(obj, path2) {
      const parent = get2.get(obj, path2.slice(0, -1), obj);
      const lastKey = path2[path2.length - 1];
      if ((parent == null ? void 0 : parent[lastKey]) === void 0) {
        return true;
      }
      if (isUnsafeProperty2.isUnsafeProperty(lastKey)) {
        return false;
      }
      try {
        delete parent[lastKey];
        return true;
      } catch {
        return false;
      }
    }
    exports3.unset = unset2;
  })(unset$1);
  const unset = /* @__PURE__ */ getDefaultExportFromCjs(unset$1);
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const unset2 = unset$1;
    const cloneDeep2 = cloneDeep$4;
    function omit2(obj, ...keysArr) {
      if (obj == null) {
        return {};
      }
      const result = cloneDeep2.cloneDeep(obj);
      for (let i = 0; i < keysArr.length; i++) {
        let keys = keysArr[i];
        switch (typeof keys) {
          case "object": {
            if (!Array.isArray(keys)) {
              keys = Array.from(keys);
            }
            for (let j = 0; j < keys.length; j++) {
              const key = keys[j];
              unset2.unset(result, key);
            }
            break;
          }
          case "string":
          case "symbol":
          case "number": {
            unset2.unset(result, keys);
            break;
          }
        }
      }
      return result;
    }
    exports3.omit = omit2;
  })(omit$3);
  const omit$2 = /* @__PURE__ */ getDefaultExportFromCjs(omit$3);
  var omit = omit$3.omit;
  const omit$1 = /* @__PURE__ */ getDefaultExportFromCjs(omit);
  var _excluded$2 = ["width", "height", "className", "style", "children", "type"];
  function _objectWithoutProperties$2(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$2(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$2(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function _extends$4() {
    return _extends$4 = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$4.apply(null, arguments);
  }
  function ownKeys$5(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$5(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$5(Object(t), true).forEach(function(r3) {
        _defineProperty$5(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$5(e, r2, t) {
    return (r2 = _toPropertyKey$5(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$5(t) {
    var i = _toPrimitive$5(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$5(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var NODE_VALUE_KEY = "value";
  var treemapPayloadSearcher = (data, activeIndex) => {
    return get$2(data, activeIndex);
  };
  var addToTreemapNodeIndex = function addToTreemapNodeIndex2(indexInChildrenArr) {
    var activeTooltipIndexSoFar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return "".concat(activeTooltipIndexSoFar, "children[").concat(indexInChildrenArr, "]");
  };
  var options$1 = {
    chartName: "Treemap",
    defaultTooltipEventType: "item",
    validateTooltipEventTypes: ["item"],
    tooltipPayloadSearcher: treemapPayloadSearcher,
    eventEmitter: void 0
  };
  var computeNode = (_ref2) => {
    var {
      depth,
      node,
      index: index2,
      dataKey,
      nameKey,
      nestedActiveTooltipIndex
    } = _ref2;
    var currentTooltipIndex = depth === 0 ? "" : addToTreemapNodeIndex(index2, nestedActiveTooltipIndex);
    var {
      children
    } = node;
    var childDepth = depth + 1;
    var computedChildren = children && children.length ? children.map((child, i) => computeNode({
      depth: childDepth,
      node: child,
      index: i,
      dataKey,
      nameKey,
      nestedActiveTooltipIndex: currentTooltipIndex
    })) : null;
    var nodeValue;
    if (children && children.length) {
      nodeValue = computedChildren.reduce((result, child) => result + child[NODE_VALUE_KEY], 0);
    } else {
      nodeValue = isNan(node[dataKey]) || node[dataKey] <= 0 ? 0 : node[dataKey];
    }
    return _objectSpread$5(_objectSpread$5({}, node), {}, {
      children: computedChildren,
      // @ts-expect-error getValueByDataKey does not validate the output type
      name: getValueByDataKey(node, nameKey, ""),
      [NODE_VALUE_KEY]: nodeValue,
      depth,
      index: index2,
      tooltipIndex: currentTooltipIndex
    });
  };
  var filterRect = (node) => ({
    x: node.x,
    y: node.y,
    width: node.width,
    height: node.height
  });
  var getAreaOfChildren = (children, areaValueRatio) => {
    var ratio = areaValueRatio < 0 ? 0 : areaValueRatio;
    return children.map((child) => {
      var area = child[NODE_VALUE_KEY] * ratio;
      return _objectSpread$5(_objectSpread$5({}, child), {}, {
        area: isNan(area) || area <= 0 ? 0 : area
      });
    });
  };
  var getWorstScore = (row, parentSize, aspectRatio) => {
    var parentArea = parentSize * parentSize;
    var rowArea = row.area * row.area;
    var {
      min: min2,
      max: max2
    } = row.reduce((result, child) => ({
      min: Math.min(result.min, child.area),
      max: Math.max(result.max, child.area)
    }), {
      min: Infinity,
      max: 0
    });
    return rowArea ? Math.max(parentArea * max2 * aspectRatio / rowArea, rowArea / (parentArea * min2 * aspectRatio)) : Infinity;
  };
  var horizontalPosition = (row, parentSize, parentRect, isFlush) => {
    var rowHeight = parentSize ? Math.round(row.area / parentSize) : 0;
    if (isFlush || rowHeight > parentRect.height) {
      rowHeight = parentRect.height;
    }
    var curX = parentRect.x;
    var child;
    for (var i = 0, len = row.length; i < len; i++) {
      child = row[i];
      child.x = curX;
      child.y = parentRect.y;
      child.height = rowHeight;
      child.width = Math.min(rowHeight ? Math.round(child.area / rowHeight) : 0, parentRect.x + parentRect.width - curX);
      curX += child.width;
    }
    child.width += parentRect.x + parentRect.width - curX;
    return _objectSpread$5(_objectSpread$5({}, parentRect), {}, {
      y: parentRect.y + rowHeight,
      height: parentRect.height - rowHeight
    });
  };
  var verticalPosition = (row, parentSize, parentRect, isFlush) => {
    var rowWidth = parentSize ? Math.round(row.area / parentSize) : 0;
    if (isFlush || rowWidth > parentRect.width) {
      rowWidth = parentRect.width;
    }
    var curY = parentRect.y;
    var child;
    for (var i = 0, len = row.length; i < len; i++) {
      child = row[i];
      child.x = parentRect.x;
      child.y = curY;
      child.width = rowWidth;
      child.height = Math.min(rowWidth ? Math.round(child.area / rowWidth) : 0, parentRect.y + parentRect.height - curY);
      curY += child.height;
    }
    if (child) {
      child.height += parentRect.y + parentRect.height - curY;
    }
    return _objectSpread$5(_objectSpread$5({}, parentRect), {}, {
      x: parentRect.x + rowWidth,
      width: parentRect.width - rowWidth
    });
  };
  var position = (row, parentSize, parentRect, isFlush) => {
    if (parentSize === parentRect.width) {
      return horizontalPosition(row, parentSize, parentRect, isFlush);
    }
    return verticalPosition(row, parentSize, parentRect, isFlush);
  };
  var squarify = (node, aspectRatio) => {
    var {
      children
    } = node;
    if (children && children.length) {
      var rect = filterRect(node);
      var row = [];
      var best = Infinity;
      var child, score;
      var size = Math.min(rect.width, rect.height);
      var scaleChildren = getAreaOfChildren(children, rect.width * rect.height / node[NODE_VALUE_KEY]);
      var tempChildren = scaleChildren.slice();
      row.area = 0;
      while (tempChildren.length > 0) {
        row.push(child = tempChildren[0]);
        row.area += child.area;
        score = getWorstScore(row, size, aspectRatio);
        if (score <= best) {
          tempChildren.shift();
          best = score;
        } else {
          row.area -= row.pop().area;
          rect = position(row, size, rect, false);
          size = Math.min(rect.width, rect.height);
          row.length = row.area = 0;
          best = Infinity;
        }
      }
      if (row.length) {
        rect = position(row, size, rect, true);
        row.length = row.area = 0;
      }
      return _objectSpread$5(_objectSpread$5({}, node), {}, {
        children: scaleChildren.map((c2) => squarify(c2, aspectRatio))
      });
    }
    return node;
  };
  var defaultState = {
    isAnimationFinished: false,
    formatRoot: null,
    currentRoot: null,
    nestIndex: []
  };
  function ContentItem(_ref2) {
    var {
      content,
      nodeProps,
      type,
      colorPanel,
      onMouseEnter,
      onMouseLeave,
      onClick
    } = _ref2;
    if (/* @__PURE__ */ React__namespace.isValidElement(content)) {
      return /* @__PURE__ */ React__namespace.createElement(Layer, {
        onMouseEnter,
        onMouseLeave,
        onClick
      }, /* @__PURE__ */ React__namespace.cloneElement(content, nodeProps));
    }
    if (typeof content === "function") {
      return /* @__PURE__ */ React__namespace.createElement(Layer, {
        onMouseEnter,
        onMouseLeave,
        onClick
      }, content(nodeProps));
    }
    var {
      x: x2,
      y: y2,
      width,
      height,
      index: index2
    } = nodeProps;
    var arrow = null;
    if (width > 10 && height > 10 && nodeProps.children && type === "nest") {
      arrow = /* @__PURE__ */ React__namespace.createElement(Polygon, {
        points: [{
          x: x2 + 2,
          y: y2 + height / 2
        }, {
          x: x2 + 6,
          y: y2 + height / 2 + 3
        }, {
          x: x2 + 2,
          y: y2 + height / 2 + 6
        }]
      });
    }
    var text = null;
    var nameSize = getStringSize(nodeProps.name);
    if (width > 20 && height > 20 && nameSize.width < width && nameSize.height < height) {
      text = /* @__PURE__ */ React__namespace.createElement("text", {
        x: x2 + 8,
        y: y2 + height / 2 + 7,
        fontSize: 14
      }, nodeProps.name);
    }
    var colors = colorPanel || COLOR_PANEL;
    return /* @__PURE__ */ React__namespace.createElement("g", null, /* @__PURE__ */ React__namespace.createElement(Rectangle, _extends$4({
      fill: nodeProps.depth < 2 ? colors[index2 % colors.length] : "rgba(255,255,255,0)",
      stroke: "#fff"
    }, omit$1(nodeProps, ["children"]), {
      onMouseEnter,
      onMouseLeave,
      onClick,
      "data-recharts-item-index": nodeProps.tooltipIndex
    })), arrow, text);
  }
  function ContentItemWithEvents(props) {
    var dispatch = useAppDispatch();
    var activeCoordinate = props.nodeProps ? {
      x: props.nodeProps.x + props.nodeProps.width / 2,
      y: props.nodeProps.y + props.nodeProps.height / 2
    } : null;
    var onMouseEnter = () => {
      dispatch(setActiveMouseOverItemIndex({
        activeIndex: props.nodeProps.tooltipIndex,
        activeDataKey: props.dataKey,
        activeCoordinate
      }));
    };
    var onMouseLeave = () => {
    };
    var onClick = () => {
      dispatch(setActiveClickItemIndex({
        activeIndex: props.nodeProps.tooltipIndex,
        activeDataKey: props.dataKey,
        activeCoordinate
      }));
    };
    return /* @__PURE__ */ React__namespace.createElement(ContentItem, _extends$4({}, props, {
      onMouseEnter,
      onMouseLeave,
      onClick
    }));
  }
  function getTooltipEntrySettings$3(_ref3) {
    var {
      props,
      currentRoot
    } = _ref3;
    var {
      dataKey,
      nameKey,
      stroke,
      fill: fill2
    } = props;
    return {
      dataDefinedOnItem: currentRoot,
      positions: void 0,
      // TODO I think Treemap has the capability of computing positions and supporting defaultIndex? Except it doesn't yet
      settings: {
        stroke,
        strokeWidth: void 0,
        fill: fill2,
        dataKey,
        nameKey,
        name: void 0,
        // Each TreemapNode has its own name
        hide: false,
        type: void 0,
        color: fill2,
        unit: ""
      }
    };
  }
  var defaultTreemapMargin = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  class TreemapWithState extends React.PureComponent {
    constructor() {
      super(...arguments);
      _defineProperty$5(this, "state", _objectSpread$5({}, defaultState));
      _defineProperty$5(this, "handleAnimationEnd", () => {
        var {
          onAnimationEnd
        } = this.props;
        this.setState({
          isAnimationFinished: true
        });
        if (typeof onAnimationEnd === "function") {
          onAnimationEnd();
        }
      });
      _defineProperty$5(this, "handleAnimationStart", () => {
        var {
          onAnimationStart
        } = this.props;
        this.setState({
          isAnimationFinished: false
        });
        if (typeof onAnimationStart === "function") {
          onAnimationStart();
        }
      });
      _defineProperty$5(this, "handleTouchMove", (_state, e) => {
        var touchEvent = e.touches[0];
        var target = document.elementFromPoint(touchEvent.clientX, touchEvent.clientY);
        if (!target || !target.getAttribute) {
          return;
        }
        var itemIndex = target.getAttribute("data-recharts-item-index");
        var activeNode = treemapPayloadSearcher(this.state.formatRoot, itemIndex);
        if (!activeNode) {
          return;
        }
        var {
          dataKey,
          dispatch
        } = this.props;
        var activeCoordinate = {
          x: activeNode.x + activeNode.width / 2,
          y: activeNode.y + activeNode.height / 2
        };
        dispatch(setActiveMouseOverItemIndex({
          activeIndex: itemIndex,
          activeDataKey: dataKey,
          activeCoordinate
        }));
      });
    }
    static getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.data !== prevState.prevData || nextProps.type !== prevState.prevType || nextProps.width !== prevState.prevWidth || nextProps.height !== prevState.prevHeight || nextProps.dataKey !== prevState.prevDataKey || nextProps.aspectRatio !== prevState.prevAspectRatio) {
        var root = computeNode({
          depth: 0,
          // @ts-expect-error missing properties
          node: {
            children: nextProps.data,
            x: 0,
            y: 0,
            width: nextProps.width,
            height: nextProps.height
          },
          index: 0,
          dataKey: nextProps.dataKey,
          nameKey: nextProps.nameKey
        });
        var formatRoot = squarify(root, nextProps.aspectRatio);
        return _objectSpread$5(_objectSpread$5({}, prevState), {}, {
          formatRoot,
          currentRoot: root,
          nestIndex: [root],
          prevAspectRatio: nextProps.aspectRatio,
          prevData: nextProps.data,
          prevWidth: nextProps.width,
          prevHeight: nextProps.height,
          prevDataKey: nextProps.dataKey,
          prevType: nextProps.type
        });
      }
      return null;
    }
    handleMouseEnter(node, e) {
      e.persist();
      var {
        onMouseEnter
      } = this.props;
      if (onMouseEnter) {
        onMouseEnter(node, e);
      }
    }
    handleMouseLeave(node, e) {
      e.persist();
      var {
        onMouseLeave
      } = this.props;
      if (onMouseLeave) {
        onMouseLeave(node, e);
      }
    }
    handleClick(node) {
      var {
        onClick,
        type
      } = this.props;
      if (type === "nest" && node.children) {
        var {
          width,
          height,
          dataKey,
          nameKey,
          aspectRatio
        } = this.props;
        var root = computeNode({
          depth: 0,
          node: _objectSpread$5(_objectSpread$5({}, node), {}, {
            x: 0,
            y: 0,
            width,
            height
          }),
          index: 0,
          dataKey,
          nameKey,
          // with Treemap nesting, should this continue nesting the index or start from empty string?
          nestedActiveTooltipIndex: node.tooltipIndex
        });
        var formatRoot = squarify(root, aspectRatio);
        var {
          nestIndex
        } = this.state;
        nestIndex.push(node);
        this.setState({
          formatRoot,
          currentRoot: root,
          nestIndex
        });
      }
      if (onClick) {
        onClick(node);
      }
    }
    handleNestIndex(node, i) {
      var {
        nestIndex
      } = this.state;
      var {
        width,
        height,
        dataKey,
        nameKey,
        aspectRatio
      } = this.props;
      var root = computeNode({
        depth: 0,
        node: _objectSpread$5(_objectSpread$5({}, node), {}, {
          x: 0,
          y: 0,
          width,
          height
        }),
        index: 0,
        dataKey,
        nameKey,
        // with Treemap nesting, should this continue nesting the index or start from empty string?
        nestedActiveTooltipIndex: node.tooltipIndex
      });
      var formatRoot = squarify(root, aspectRatio);
      nestIndex = nestIndex.slice(0, i + 1);
      this.setState({
        formatRoot,
        currentRoot: node,
        nestIndex
      });
    }
    renderItem(content, nodeProps, isLeaf) {
      var {
        isAnimationActive,
        animationBegin,
        animationDuration,
        animationEasing,
        isUpdateAnimationActive,
        type,
        colorPanel,
        dataKey
      } = this.props;
      var {
        isAnimationFinished
      } = this.state;
      var {
        width,
        height,
        x: x2,
        y: y2,
        depth
      } = nodeProps;
      var translateX = parseInt("".concat((Math.random() * 2 - 1) * width), 10);
      var event = {};
      if (isLeaf || type === "nest") {
        event = {
          onMouseEnter: this.handleMouseEnter.bind(this, nodeProps),
          onMouseLeave: this.handleMouseLeave.bind(this, nodeProps),
          onClick: this.handleClick.bind(this, nodeProps)
        };
      }
      if (!isAnimationActive) {
        return /* @__PURE__ */ React__namespace.createElement(Layer, event, /* @__PURE__ */ React__namespace.createElement(ContentItemWithEvents, {
          content,
          dataKey,
          nodeProps: _objectSpread$5(_objectSpread$5({}, nodeProps), {}, {
            isAnimationActive: false,
            isUpdateAnimationActive: false,
            width,
            height,
            x: x2,
            y: y2
          }),
          type,
          colorPanel
        }));
      }
      return /* @__PURE__ */ React__namespace.createElement(CSSTransitionAnimate, {
        from: "translate(".concat(translateX, "px, ").concat(translateX, "px)"),
        to: "translate(0, 0)",
        attributeName: "transform",
        begin: animationBegin,
        easing: animationEasing,
        isActive: isAnimationActive,
        duration: animationDuration,
        onAnimationStart: this.handleAnimationStart,
        onAnimationEnd: this.handleAnimationEnd
      }, (style) => /* @__PURE__ */ React__namespace.createElement(Layer, _extends$4({}, event, {
        style
      }), depth > 2 && !isAnimationFinished ? null : /* @__PURE__ */ React__namespace.createElement(ContentItemWithEvents, {
        content,
        dataKey,
        nodeProps: _objectSpread$5(_objectSpread$5({}, nodeProps), {}, {
          isAnimationActive,
          isUpdateAnimationActive: !isUpdateAnimationActive,
          width,
          height,
          x: x2,
          y: y2
        }),
        type,
        colorPanel
      })));
    }
    renderNode(root, node) {
      var {
        content,
        type
      } = this.props;
      var nodeProps = _objectSpread$5(_objectSpread$5(_objectSpread$5({}, svgPropertiesNoEvents(this.props)), node), {}, {
        root
      });
      var isLeaf = !node.children || !node.children.length;
      var {
        currentRoot
      } = this.state;
      var isCurrentRootChild = (currentRoot.children || []).filter((item) => item.depth === node.depth && item.name === node.name);
      if (!isCurrentRootChild.length && root.depth && type === "nest") {
        return null;
      }
      return /* @__PURE__ */ React__namespace.createElement(Layer, {
        key: "recharts-treemap-node-".concat(nodeProps.x, "-").concat(nodeProps.y, "-").concat(nodeProps.name),
        className: "recharts-treemap-depth-".concat(node.depth)
      }, this.renderItem(content, nodeProps, isLeaf), node.children && node.children.length ? node.children.map((child) => this.renderNode(node, child)) : null);
    }
    renderAllNodes() {
      var {
        formatRoot
      } = this.state;
      if (!formatRoot) {
        return null;
      }
      return this.renderNode(formatRoot, formatRoot);
    }
    // render nest treemap
    renderNestIndex() {
      var {
        nameKey,
        nestIndexContent
      } = this.props;
      var {
        nestIndex
      } = this.state;
      return /* @__PURE__ */ React__namespace.createElement("div", {
        className: "recharts-treemap-nest-index-wrapper",
        style: {
          marginTop: "8px",
          textAlign: "center"
        }
      }, nestIndex.map((item, i) => {
        var name = get$2(item, nameKey, "root");
        var content = null;
        if (/* @__PURE__ */ React__namespace.isValidElement(nestIndexContent)) {
          content = /* @__PURE__ */ React__namespace.cloneElement(nestIndexContent, item, i);
        }
        if (typeof nestIndexContent === "function") {
          content = nestIndexContent(item, i);
        } else {
          content = name;
        }
        return (
          // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
          /* @__PURE__ */ React__namespace.createElement("div", {
            onClick: this.handleNestIndex.bind(this, item, i),
            key: "nest-index-".concat(uniqueId()),
            className: "recharts-treemap-nest-index-box",
            style: {
              cursor: "pointer",
              display: "inline-block",
              padding: "0 7px",
              background: "#000",
              color: "#fff",
              marginRight: "3px"
            }
          }, content)
        );
      }));
    }
    render() {
      var _this$props = this.props, {
        width,
        height,
        className,
        style,
        children,
        type
      } = _this$props, others = _objectWithoutProperties$2(_this$props, _excluded$2);
      var attrs = svgPropertiesNoEvents(others);
      return /* @__PURE__ */ React__namespace.createElement(TooltipPortalContext.Provider, {
        value: this.state.tooltipPortal
      }, /* @__PURE__ */ React__namespace.createElement(SetTooltipEntrySettings, {
        fn: getTooltipEntrySettings$3,
        args: {
          props: this.props,
          currentRoot: this.state.currentRoot
        }
      }), /* @__PURE__ */ React__namespace.createElement(RechartsWrapper, {
        className,
        style,
        width,
        height,
        ref: (node) => {
          if (this.state.tooltipPortal == null) {
            this.setState({
              tooltipPortal: node
            });
          }
        },
        onMouseEnter: void 0,
        onMouseLeave: void 0,
        onClick: void 0,
        onMouseMove: void 0,
        onMouseDown: void 0,
        onMouseUp: void 0,
        onContextMenu: void 0,
        onDoubleClick: void 0,
        onTouchStart: void 0,
        onTouchMove: this.handleTouchMove,
        onTouchEnd: void 0
      }, /* @__PURE__ */ React__namespace.createElement(Surface, _extends$4({}, attrs, {
        width,
        height: type === "nest" ? height - 30 : height
      }), this.renderAllNodes(), children), type === "nest" && this.renderNestIndex()));
    }
  }
  _defineProperty$5(TreemapWithState, "displayName", "Treemap");
  _defineProperty$5(TreemapWithState, "defaultProps", {
    aspectRatio: 0.5 * (1 + Math.sqrt(5)),
    dataKey: "value",
    nameKey: "name",
    type: "flat",
    isAnimationActive: !Global.isSsr,
    isUpdateAnimationActive: !Global.isSsr,
    animationBegin: 0,
    animationDuration: 1500,
    animationEasing: "linear"
  });
  function TreemapDispatchInject(props) {
    var dispatch = useAppDispatch();
    return /* @__PURE__ */ React__namespace.createElement(TreemapWithState, _extends$4({}, props, {
      dispatch
    }));
  }
  function Treemap(props) {
    var _props$className;
    var {
      width,
      height
    } = props;
    if (!isPositiveNumber(width) || !isPositiveNumber(height)) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(RechartsStoreProvider, {
      preloadedState: {
        options: options$1
      },
      reduxStoreName: (_props$className = props.className) !== null && _props$className !== void 0 ? _props$className : "Treemap"
    }, /* @__PURE__ */ React__namespace.createElement(ReportChartSize, {
      width,
      height
    }), /* @__PURE__ */ React__namespace.createElement(ReportChartMargin, {
      margin: defaultTreemapMargin
    }), /* @__PURE__ */ React__namespace.createElement(TreemapDispatchInject, props));
  }
  var sumBy$3 = {};
  (function(exports3) {
    "use strict";
    Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
    const iteratee2 = iteratee$1;
    function sumBy2(array2, iteratee$12) {
      if (!array2 || !array2.length) {
        return 0;
      }
      if (iteratee$12 != null) {
        iteratee$12 = iteratee2.iteratee(iteratee$12);
      }
      let result = void 0;
      for (let i = 0; i < array2.length; i++) {
        const current2 = iteratee$12 ? iteratee$12(array2[i]) : array2[i];
        if (current2 !== void 0) {
          if (result === void 0) {
            result = current2;
          } else {
            result += current2;
          }
        }
      }
      return result;
    }
    exports3.sumBy = sumBy2;
  })(sumBy$3);
  const sumBy$2 = /* @__PURE__ */ getDefaultExportFromCjs(sumBy$3);
  var sumBy = sumBy$3.sumBy;
  const sumBy$1 = /* @__PURE__ */ getDefaultExportFromCjs(sumBy);
  var _excluded$1 = ["sourceX", "sourceY", "sourceControlX", "targetX", "targetY", "targetControlX", "linkWidth"], _excluded2$1 = ["width", "height", "className", "style", "children"];
  function _extends$3() {
    return _extends$3 = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$3.apply(null, arguments);
  }
  function _objectWithoutProperties$1(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose$1(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose$1(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function ownKeys$4(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$4(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$4(Object(t), true).forEach(function(r3) {
        _defineProperty$4(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$4(e, r2, t) {
    return (r2 = _toPropertyKey$4(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$4(t) {
    var i = _toPrimitive$4(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$4(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var interpolationGenerator = (a2, b) => {
    var ka2 = +a2;
    var kb = b - ka2;
    return (t) => ka2 + kb * t;
  };
  var centerY = (node) => node.y + node.dy / 2;
  var getValue = (entry) => entry && entry.value || 0;
  var getSumOfIds = (links, ids) => ids.reduce((result, id) => result + getValue(links[id]), 0);
  var getSumWithWeightedSource = (tree, links, ids) => ids.reduce((result, id) => {
    var link2 = links[id];
    var sourceNode = tree[link2.source];
    return result + centerY(sourceNode) * getValue(links[id]);
  }, 0);
  var getSumWithWeightedTarget = (tree, links, ids) => ids.reduce((result, id) => {
    var link2 = links[id];
    var targetNode = tree[link2.target];
    return result + centerY(targetNode) * getValue(links[id]);
  }, 0);
  var ascendingY = (a2, b) => a2.y - b.y;
  var searchTargetsAndSources = (links, id) => {
    var sourceNodes = [];
    var sourceLinks = [];
    var targetNodes = [];
    var targetLinks = [];
    for (var i = 0, len = links.length; i < len; i++) {
      var link2 = links[i];
      if (link2.source === id) {
        targetNodes.push(link2.target);
        targetLinks.push(i);
      }
      if (link2.target === id) {
        sourceNodes.push(link2.source);
        sourceLinks.push(i);
      }
    }
    return {
      sourceNodes,
      sourceLinks,
      targetLinks,
      targetNodes
    };
  };
  var updateDepthOfTargets = (tree, curNode) => {
    var {
      targetNodes
    } = curNode;
    for (var i = 0, len = targetNodes.length; i < len; i++) {
      var target = tree[targetNodes[i]];
      if (target) {
        target.depth = Math.max(curNode.depth + 1, target.depth);
        updateDepthOfTargets(tree, target);
      }
    }
  };
  var getNodesTree = (_ref2, width, nodeWidth) => {
    var {
      nodes,
      links
    } = _ref2;
    var tree = nodes.map((entry, index2) => {
      var result = searchTargetsAndSources(links, index2);
      return _objectSpread$4(_objectSpread$4(_objectSpread$4({}, entry), result), {}, {
        value: Math.max(getSumOfIds(links, result.sourceLinks), getSumOfIds(links, result.targetLinks)),
        depth: 0
      });
    });
    for (var i = 0, len = tree.length; i < len; i++) {
      var node = tree[i];
      if (!node.sourceNodes.length) {
        updateDepthOfTargets(tree, node);
      }
    }
    var maxDepth = maxBy$2(tree, (entry) => entry.depth).depth;
    if (maxDepth >= 1) {
      var childWidth = (width - nodeWidth) / maxDepth;
      for (var _i = 0, _len = tree.length; _i < _len; _i++) {
        var _node = tree[_i];
        if (!_node.targetNodes.length) {
          _node.depth = maxDepth;
        }
        _node.x = _node.depth * childWidth;
        _node.dx = nodeWidth;
      }
    }
    return {
      tree,
      maxDepth
    };
  };
  var getDepthTree = (tree) => {
    var result = [];
    for (var i = 0, len = tree.length; i < len; i++) {
      var node = tree[i];
      if (!result[node.depth]) {
        result[node.depth] = [];
      }
      result[node.depth].push(node);
    }
    return result;
  };
  var updateYOfTree = (depthTree, height, nodePadding, links) => {
    var yRatio = Math.min(...depthTree.map((nodes) => (height - (nodes.length - 1) * nodePadding) / sumBy$1(nodes, getValue)));
    for (var d = 0, maxDepth = depthTree.length; d < maxDepth; d++) {
      for (var i = 0, len = depthTree[d].length; i < len; i++) {
        var node = depthTree[d][i];
        node.y = i;
        node.dy = node.value * yRatio;
      }
    }
    return links.map((link2) => _objectSpread$4(_objectSpread$4({}, link2), {}, {
      dy: getValue(link2) * yRatio
    }));
  };
  var resolveCollisions = function resolveCollisions2(depthTree, height, nodePadding) {
    var sort2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    for (var i = 0, len = depthTree.length; i < len; i++) {
      var nodes = depthTree[i];
      var n = nodes.length;
      if (sort2) {
        nodes.sort(ascendingY);
      }
      var y0 = 0;
      for (var j = 0; j < n; j++) {
        var node = nodes[j];
        var dy = y0 - node.y;
        if (dy > 0) {
          node.y += dy;
        }
        y0 = node.y + node.dy + nodePadding;
      }
      y0 = height + nodePadding;
      for (var _j = n - 1; _j >= 0; _j--) {
        var _node2 = nodes[_j];
        var _dy = _node2.y + _node2.dy + nodePadding - y0;
        if (_dy > 0) {
          _node2.y -= _dy;
          y0 = _node2.y;
        } else {
          break;
        }
      }
    }
  };
  var relaxLeftToRight = (tree, depthTree, links, alpha2) => {
    for (var i = 0, maxDepth = depthTree.length; i < maxDepth; i++) {
      var nodes = depthTree[i];
      for (var j = 0, len = nodes.length; j < len; j++) {
        var node = nodes[j];
        if (node.sourceLinks.length) {
          var sourceSum = getSumOfIds(links, node.sourceLinks);
          var weightedSum = getSumWithWeightedSource(tree, links, node.sourceLinks);
          var y2 = weightedSum / sourceSum;
          node.y += (y2 - centerY(node)) * alpha2;
        }
      }
    }
  };
  var relaxRightToLeft = (tree, depthTree, links, alpha2) => {
    for (var i = depthTree.length - 1; i >= 0; i--) {
      var nodes = depthTree[i];
      for (var j = 0, len = nodes.length; j < len; j++) {
        var node = nodes[j];
        if (node.targetLinks.length) {
          var targetSum = getSumOfIds(links, node.targetLinks);
          var weightedSum = getSumWithWeightedTarget(tree, links, node.targetLinks);
          var y2 = weightedSum / targetSum;
          node.y += (y2 - centerY(node)) * alpha2;
        }
      }
    }
  };
  var updateYOfLinks = (tree, links) => {
    for (var i = 0, len = tree.length; i < len; i++) {
      var node = tree[i];
      var sy = 0;
      var ty = 0;
      node.targetLinks.sort((a2, b) => tree[links[a2].target].y - tree[links[b].target].y);
      node.sourceLinks.sort((a2, b) => tree[links[a2].source].y - tree[links[b].source].y);
      for (var j = 0, tLen = node.targetLinks.length; j < tLen; j++) {
        var link2 = links[node.targetLinks[j]];
        if (link2) {
          link2.sy = sy;
          sy += link2.dy;
        }
      }
      for (var _j2 = 0, sLen = node.sourceLinks.length; _j2 < sLen; _j2++) {
        var _link = links[node.sourceLinks[_j2]];
        if (_link) {
          _link.ty = ty;
          ty += _link.dy;
        }
      }
    }
  };
  var computeData = (_ref2) => {
    var {
      data,
      width,
      height,
      iterations,
      nodeWidth,
      nodePadding,
      sort: sort2
    } = _ref2;
    var {
      links
    } = data;
    var {
      tree
    } = getNodesTree(data, width, nodeWidth);
    var depthTree = getDepthTree(tree);
    var newLinks = updateYOfTree(depthTree, height, nodePadding, links);
    resolveCollisions(depthTree, height, nodePadding, sort2);
    var alpha2 = 1;
    for (var i = 1; i <= iterations; i++) {
      relaxRightToLeft(tree, depthTree, newLinks, alpha2 *= 0.99);
      resolveCollisions(depthTree, height, nodePadding, sort2);
      relaxLeftToRight(tree, depthTree, newLinks, alpha2);
      resolveCollisions(depthTree, height, nodePadding, sort2);
    }
    updateYOfLinks(tree, newLinks);
    return {
      nodes: tree,
      links: newLinks
    };
  };
  var getCoordinateOfTooltip = (item, type) => {
    if (type === "node") {
      return {
        x: +item.x + +item.width / 2,
        y: +item.y + +item.height / 2
      };
    }
    return "sourceX" in item && {
      x: (item.sourceX + item.targetX) / 2,
      y: (item.sourceY + item.targetY) / 2
    };
  };
  var getPayloadOfTooltip = (item, type, nameKey) => {
    var {
      payload
    } = item;
    if (type === "node") {
      return {
        payload,
        name: getValueByDataKey(payload, nameKey, ""),
        value: getValueByDataKey(payload, "value")
      };
    }
    if ("source" in payload && payload.source && payload.target) {
      var sourceName = getValueByDataKey(payload.source, nameKey, "");
      var targetName = getValueByDataKey(payload.target, nameKey, "");
      return {
        payload,
        name: "".concat(sourceName, " - ").concat(targetName),
        value: getValueByDataKey(payload, "value")
      };
    }
    return null;
  };
  var sankeyPayloadSearcher = (_, activeIndex, computedData, nameKey) => {
    if (activeIndex == null || typeof activeIndex !== "string") {
      return void 0;
    }
    var splitIndex = activeIndex.split("-");
    var [targetType, index2] = splitIndex;
    var item = get$2(computedData, "".concat(targetType, "s[").concat(index2, "]"));
    if (item) {
      var payload = getPayloadOfTooltip(item, targetType, nameKey);
      return payload;
    }
    return void 0;
  };
  var options = {
    chartName: "Sankey",
    defaultTooltipEventType: "item",
    validateTooltipEventTypes: ["item"],
    tooltipPayloadSearcher: sankeyPayloadSearcher,
    eventEmitter: void 0
  };
  function getTooltipEntrySettings$2(props) {
    var {
      dataKey,
      nameKey,
      stroke,
      strokeWidth,
      fill: fill2,
      name,
      data
    } = props;
    return {
      dataDefinedOnItem: data,
      positions: void 0,
      settings: {
        stroke,
        strokeWidth,
        fill: fill2,
        dataKey,
        name,
        nameKey,
        color: fill2,
        unit: ""
        // Sankey does not have unit, why?
      }
    };
  }
  var defaultSankeyMargin = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  function renderLinkItem(option, props) {
    if (/* @__PURE__ */ React__namespace.isValidElement(option)) {
      return /* @__PURE__ */ React__namespace.cloneElement(option, props);
    }
    if (typeof option === "function") {
      return option(props);
    }
    var {
      sourceX,
      sourceY,
      sourceControlX,
      targetX,
      targetY,
      targetControlX,
      linkWidth
    } = props, others = _objectWithoutProperties$1(props, _excluded$1);
    return /* @__PURE__ */ React__namespace.createElement("path", _extends$3({
      className: "recharts-sankey-link",
      d: "\n          M".concat(sourceX, ",").concat(sourceY, "\n          C").concat(sourceControlX, ",").concat(sourceY, " ").concat(targetControlX, ",").concat(targetY, " ").concat(targetX, ",").concat(targetY, "\n        "),
      fill: "none",
      stroke: "#333",
      strokeWidth: linkWidth,
      strokeOpacity: "0.2"
    }, svgPropertiesNoEvents(others)));
  }
  var buildLinkProps = (_ref3) => {
    var {
      link: link2,
      nodes,
      left,
      top,
      i,
      linkContent,
      linkCurvature
    } = _ref3;
    var {
      sy: sourceRelativeY,
      ty: targetRelativeY,
      dy: linkWidth
    } = link2;
    var sourceNode = nodes[link2.source];
    var targetNode = nodes[link2.target];
    var sourceX = sourceNode.x + sourceNode.dx + left;
    var targetX = targetNode.x + left;
    var interpolationFunc = interpolationGenerator(sourceX, targetX);
    var sourceControlX = interpolationFunc(linkCurvature);
    var targetControlX = interpolationFunc(1 - linkCurvature);
    var sourceY = sourceNode.y + sourceRelativeY + linkWidth / 2 + top;
    var targetY = targetNode.y + targetRelativeY + linkWidth / 2 + top;
    var linkProps = _objectSpread$4({
      sourceX,
      targetX,
      sourceY,
      targetY,
      sourceControlX,
      targetControlX,
      sourceRelativeY,
      targetRelativeY,
      linkWidth,
      index: i,
      payload: _objectSpread$4(_objectSpread$4({}, link2), {}, {
        source: sourceNode,
        target: targetNode
      })
    }, filterProps(linkContent, false));
    return linkProps;
  };
  function SankeyLinkElement(_ref4) {
    var {
      props,
      i,
      linkContent,
      onMouseEnter: _onMouseEnter,
      onMouseLeave: _onMouseLeave,
      onClick: _onClick,
      dataKey
    } = _ref4;
    var activeCoordinate = getCoordinateOfTooltip(props, "link");
    var activeIndex = "link-".concat(i);
    var dispatch = useAppDispatch();
    var events = {
      onMouseEnter: (e) => {
        dispatch(setActiveMouseOverItemIndex({
          activeIndex,
          activeDataKey: dataKey,
          activeCoordinate
        }));
        _onMouseEnter(props, e);
      },
      onMouseLeave: (e) => {
        dispatch(mouseLeaveItem());
        _onMouseLeave(props, e);
      },
      onClick: (e) => {
        dispatch(setActiveClickItemIndex({
          activeIndex,
          activeDataKey: dataKey,
          activeCoordinate
        }));
        _onClick(props, e);
      }
    };
    return /* @__PURE__ */ React__namespace.createElement(Layer, events, renderLinkItem(linkContent, props));
  }
  function AllSankeyLinkElements(_ref5) {
    var {
      modifiedLinks,
      links,
      linkContent,
      onMouseEnter,
      onMouseLeave,
      onClick,
      dataKey
    } = _ref5;
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: "recharts-sankey-links",
      key: "recharts-sankey-links"
    }, links.map((link2, i) => {
      var linkProps = modifiedLinks[i];
      return /* @__PURE__ */ React__namespace.createElement(SankeyLinkElement, {
        key: "link-".concat(link2.source, "-").concat(link2.target, "-").concat(link2.value),
        props: linkProps,
        linkContent,
        i,
        onMouseEnter,
        onMouseLeave,
        onClick,
        dataKey
      });
    }));
  }
  function renderNodeItem(option, props) {
    if (/* @__PURE__ */ React__namespace.isValidElement(option)) {
      return /* @__PURE__ */ React__namespace.cloneElement(option, props);
    }
    if (typeof option === "function") {
      return option(props);
    }
    return (
      // @ts-expect-error recharts radius is not compatible with SVG radius
      /* @__PURE__ */ React__namespace.createElement(Rectangle, _extends$3({
        className: "recharts-sankey-node",
        fill: "#0088fe",
        fillOpacity: "0.8"
      }, svgPropertiesNoEvents(props)))
    );
  }
  var buildNodeProps = (_ref6) => {
    var {
      node,
      nodeContent,
      top,
      left,
      i
    } = _ref6;
    var {
      x: x2,
      y: y2,
      dx,
      dy
    } = node;
    var nodeProps = _objectSpread$4(_objectSpread$4({}, filterProps(nodeContent, false)), {}, {
      x: x2 + left,
      y: y2 + top,
      width: dx,
      height: dy,
      index: i,
      payload: node
    });
    return nodeProps;
  };
  function NodeElement(_ref7) {
    var {
      props,
      nodeContent,
      i,
      onMouseEnter: _onMouseEnter2,
      onMouseLeave: _onMouseLeave2,
      onClick: _onClick2,
      dataKey
    } = _ref7;
    var dispatch = useAppDispatch();
    var activeCoordinate = getCoordinateOfTooltip(props, "node");
    var activeIndex = "node-".concat(i);
    var events = {
      onMouseEnter: (e) => {
        dispatch(setActiveMouseOverItemIndex({
          activeIndex,
          activeDataKey: dataKey,
          activeCoordinate
        }));
        _onMouseEnter2(props, e);
      },
      onMouseLeave: (e) => {
        dispatch(mouseLeaveItem());
        _onMouseLeave2(props, e);
      },
      onClick: (e) => {
        dispatch(setActiveClickItemIndex({
          activeIndex,
          activeDataKey: dataKey,
          activeCoordinate
        }));
        _onClick2(props, e);
      }
    };
    return /* @__PURE__ */ React__namespace.createElement(Layer, events, renderNodeItem(nodeContent, props));
  }
  function AllNodeElements(_ref8) {
    var {
      modifiedNodes,
      nodeContent,
      onMouseEnter,
      onMouseLeave,
      onClick,
      dataKey
    } = _ref8;
    return /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: "recharts-sankey-nodes",
      key: "recharts-sankey-nodes"
    }, modifiedNodes.map((modifiedNode, i) => {
      return /* @__PURE__ */ React__namespace.createElement(NodeElement, {
        props: modifiedNode,
        nodeContent,
        i,
        onMouseEnter,
        onMouseLeave,
        onClick,
        dataKey
      });
    }));
  }
  class Sankey extends React.PureComponent {
    constructor() {
      super(...arguments);
      _defineProperty$4(this, "state", {
        nodes: [],
        links: [],
        modifiedLinks: [],
        modifiedNodes: []
      });
    }
    static getDerivedStateFromProps(nextProps, prevState) {
      var {
        data,
        width,
        height,
        margin,
        iterations,
        nodeWidth,
        nodePadding,
        sort: sort2,
        linkCurvature
      } = nextProps;
      if (data !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || !shallowEqual$1(margin, prevState.prevMargin) || iterations !== prevState.prevIterations || nodeWidth !== prevState.prevNodeWidth || nodePadding !== prevState.prevNodePadding || sort2 !== prevState.sort) {
        var contentWidth = width - (margin && margin.left || 0) - (margin && margin.right || 0);
        var contentHeight = height - (margin && margin.top || 0) - (margin && margin.bottom || 0);
        var {
          links,
          nodes
        } = computeData({
          data,
          width: contentWidth,
          height: contentHeight,
          iterations,
          nodeWidth,
          nodePadding,
          sort: sort2
        });
        var top = get$2(margin, "top") || 0;
        var left = get$2(margin, "left") || 0;
        var modifiedLinks = links.map((link2, i) => {
          return buildLinkProps({
            link: link2,
            nodes,
            i,
            top,
            left,
            linkContent: nextProps.link,
            linkCurvature
          });
        });
        var modifiedNodes = nodes.map((node, i) => {
          return buildNodeProps({
            node,
            nodeContent: nextProps.node,
            i,
            top,
            left
          });
        });
        return _objectSpread$4(_objectSpread$4({}, prevState), {}, {
          nodes,
          links,
          modifiedLinks,
          modifiedNodes,
          prevData: data,
          prevWidth: iterations,
          prevHeight: height,
          prevMargin: margin,
          prevNodePadding: nodePadding,
          prevNodeWidth: nodeWidth,
          prevIterations: iterations,
          prevSort: sort2
        });
      }
      return null;
    }
    handleMouseEnter(item, type, e) {
      var {
        onMouseEnter
      } = this.props;
      if (onMouseEnter) {
        onMouseEnter(item, type, e);
      }
    }
    handleMouseLeave(item, type, e) {
      var {
        onMouseLeave
      } = this.props;
      if (onMouseLeave) {
        onMouseLeave(item, type, e);
      }
    }
    handleClick(item, type, e) {
      var {
        onClick
      } = this.props;
      if (onClick) onClick(item, type, e);
    }
    render() {
      var _this$props = this.props, {
        width,
        height,
        className,
        style,
        children
      } = _this$props, others = _objectWithoutProperties$1(_this$props, _excluded2$1);
      if (!isPositiveNumber(width) || !isPositiveNumber(height)) {
        return null;
      }
      var {
        links,
        modifiedNodes,
        modifiedLinks
      } = this.state;
      var attrs = svgPropertiesNoEvents(others);
      return /* @__PURE__ */ React__namespace.createElement(RechartsStoreProvider, {
        preloadedState: {
          options
        },
        reduxStoreName: className !== null && className !== void 0 ? className : "Sankey"
      }, /* @__PURE__ */ React__namespace.createElement(SetTooltipEntrySettings, {
        fn: getTooltipEntrySettings$2,
        args: this.props
      }), /* @__PURE__ */ React__namespace.createElement(SetComputedData, {
        computedData: {
          links: modifiedLinks,
          nodes: modifiedNodes
        }
      }), /* @__PURE__ */ React__namespace.createElement(ReportChartSize, {
        width,
        height
      }), /* @__PURE__ */ React__namespace.createElement(ReportChartMargin, {
        margin: defaultSankeyMargin
      }), /* @__PURE__ */ React__namespace.createElement(TooltipPortalContext.Provider, {
        value: this.state.tooltipPortal
      }, /* @__PURE__ */ React__namespace.createElement(RechartsWrapper, {
        className,
        style,
        width,
        height,
        ref: (node) => {
          if (this.state.tooltipPortal == null) {
            this.setState({
              tooltipPortal: node
            });
          }
        },
        onMouseEnter: void 0,
        onMouseLeave: void 0,
        onClick: void 0,
        onMouseMove: void 0,
        onMouseDown: void 0,
        onMouseUp: void 0,
        onContextMenu: void 0,
        onDoubleClick: void 0,
        onTouchStart: void 0,
        onTouchMove: void 0,
        onTouchEnd: void 0
      }, /* @__PURE__ */ React__namespace.createElement(Surface, _extends$3({}, attrs, {
        width,
        height
      }), children, /* @__PURE__ */ React__namespace.createElement(AllSankeyLinkElements, {
        links,
        modifiedLinks,
        linkContent: this.props.link,
        dataKey: this.props.dataKey,
        onMouseEnter: (linkProps, e) => this.handleMouseEnter(linkProps, "link", e),
        onMouseLeave: (linkProps, e) => this.handleMouseLeave(linkProps, "link", e),
        onClick: (linkProps, e) => this.handleClick(linkProps, "link", e)
      }), /* @__PURE__ */ React__namespace.createElement(AllNodeElements, {
        modifiedNodes,
        nodeContent: this.props.node,
        dataKey: this.props.dataKey,
        onMouseEnter: (nodeProps, e) => this.handleMouseEnter(nodeProps, "node", e),
        onMouseLeave: (nodeProps, e) => this.handleMouseLeave(nodeProps, "node", e),
        onClick: (nodeProps, e) => this.handleClick(nodeProps, "node", e)
      })))));
    }
  }
  _defineProperty$4(Sankey, "displayName", "Sankey");
  _defineProperty$4(Sankey, "defaultProps", {
    nameKey: "name",
    dataKey: "value",
    nodePadding: 10,
    nodeWidth: 10,
    linkCurvature: 0.5,
    iterations: 32,
    margin: {
      top: 5,
      right: 5,
      bottom: 5,
      left: 5
    },
    sort: true
  });
  var allowedTooltipTypes$5 = ["axis"];
  var defaultProps$1 = {
    layout: "centric",
    startAngle: 90,
    endAngle: -270,
    cx: "50%",
    cy: "50%",
    innerRadius: 0,
    outerRadius: "80%"
  };
  var RadarChart = /* @__PURE__ */ React.forwardRef((props, ref) => {
    var propsWithDefaults = resolveDefaultProps(props, defaultProps$1);
    return /* @__PURE__ */ React__namespace.createElement(PolarChart, {
      chartName: "RadarChart",
      defaultTooltipEventType: "axis",
      validateTooltipEventTypes: allowedTooltipTypes$5,
      tooltipPayloadSearcher: arrayTooltipSearcher,
      categoricalChartProps: propsWithDefaults,
      ref
    });
  });
  var allowedTooltipTypes$4 = ["item"];
  var ScatterChart = /* @__PURE__ */ React.forwardRef((props, ref) => {
    return /* @__PURE__ */ React__namespace.createElement(CartesianChart, {
      chartName: "ScatterChart",
      defaultTooltipEventType: "item",
      validateTooltipEventTypes: allowedTooltipTypes$4,
      tooltipPayloadSearcher: arrayTooltipSearcher,
      categoricalChartProps: props,
      ref
    });
  });
  var allowedTooltipTypes$3 = ["axis"];
  var AreaChart = /* @__PURE__ */ React.forwardRef((props, ref) => {
    return /* @__PURE__ */ React__namespace.createElement(CartesianChart, {
      chartName: "AreaChart",
      defaultTooltipEventType: "axis",
      validateTooltipEventTypes: allowedTooltipTypes$3,
      tooltipPayloadSearcher: arrayTooltipSearcher,
      categoricalChartProps: props,
      ref
    });
  });
  var allowedTooltipTypes$2 = ["axis", "item"];
  var defaultProps = {
    layout: "radial",
    startAngle: 0,
    endAngle: 360,
    cx: "50%",
    cy: "50%",
    innerRadius: 0,
    outerRadius: "80%"
  };
  var RadialBarChart = /* @__PURE__ */ React.forwardRef((props, ref) => {
    var propsWithDefaults = resolveDefaultProps(props, defaultProps);
    return /* @__PURE__ */ React__namespace.createElement(PolarChart, {
      chartName: "RadialBarChart",
      defaultTooltipEventType: "axis",
      validateTooltipEventTypes: allowedTooltipTypes$2,
      tooltipPayloadSearcher: arrayTooltipSearcher,
      categoricalChartProps: propsWithDefaults,
      ref
    });
  });
  var allowedTooltipTypes$1 = ["axis"];
  var ComposedChart = /* @__PURE__ */ React.forwardRef((props, ref) => {
    return /* @__PURE__ */ React__namespace.createElement(CartesianChart, {
      chartName: "ComposedChart",
      defaultTooltipEventType: "axis",
      validateTooltipEventTypes: allowedTooltipTypes$1,
      tooltipPayloadSearcher: arrayTooltipSearcher,
      categoricalChartProps: props,
      ref
    });
  });
  function _extends$2() {
    return _extends$2 = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$2.apply(null, arguments);
  }
  function ownKeys$3(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$3(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$3(Object(t), true).forEach(function(r3) {
        _defineProperty$3(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$3(e, r2, t) {
    return (r2 = _toPropertyKey$3(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$3(t) {
    var i = _toPrimitive$3(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$3(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var defaultTextProps = {
    fontWeight: "bold",
    paintOrder: "stroke fill",
    fontSize: ".75rem",
    stroke: "#FFF",
    fill: "black",
    pointerEvents: "none"
  };
  function getMaxDepthOf(node) {
    if (!node.children || node.children.length === 0) return 1;
    var childDepths = node.children.map((d) => getMaxDepthOf(d));
    return 1 + Math.max(...childDepths);
  }
  function convertMapToRecord(map2) {
    var record = {};
    map2.forEach((value, key) => {
      record[key] = value;
    });
    return record;
  }
  function getTooltipEntrySettings$1(_ref2) {
    var {
      dataKey,
      nameKey,
      data,
      stroke,
      fill: fill2,
      positions
    } = _ref2;
    return {
      dataDefinedOnItem: data.children,
      // Redux store will not accept a Map because it's not serializable
      positions: convertMapToRecord(positions),
      // Sunburst does not support many of the properties as other charts do so there's plenty of defaults here
      settings: {
        stroke,
        strokeWidth: void 0,
        fill: fill2,
        nameKey,
        dataKey,
        // if there is a nameKey use it, otherwise make the name of the tooltip the dataKey itself
        name: nameKey ? void 0 : dataKey,
        hide: false,
        type: void 0,
        color: fill2,
        unit: ""
      }
    };
  }
  var defaultSunburstMargin = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  var payloadSearcher = (data, activeIndex) => {
    return get$2(data, activeIndex);
  };
  var addToSunburstNodeIndex = function addToSunburstNodeIndex2(indexInChildrenArr) {
    var activeTooltipIndexSoFar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return "".concat(activeTooltipIndexSoFar, "children[").concat(indexInChildrenArr, "]");
  };
  var preloadedState = {
    options: {
      validateTooltipEventTypes: ["item"],
      defaultTooltipEventType: "item",
      chartName: "Sunburst",
      tooltipPayloadSearcher: payloadSearcher,
      eventEmitter: void 0
    }
  };
  var SunburstChartImpl = (_ref2) => {
    var {
      className,
      data,
      children,
      width,
      height,
      padding = 2,
      dataKey = "value",
      nameKey = "name",
      ringPadding = 2,
      innerRadius = 50,
      fill: fill2 = "#333",
      stroke = "#FFF",
      textOptions = defaultTextProps,
      outerRadius = Math.min(width, height) / 2,
      cx = width / 2,
      cy = height / 2,
      startAngle = 0,
      endAngle = 360,
      onClick,
      onMouseEnter,
      onMouseLeave
    } = _ref2;
    var dispatch = useAppDispatch();
    var rScale = linear([0, data[dataKey]], [0, endAngle]);
    var treeDepth = getMaxDepthOf(data);
    var thickness = (outerRadius - innerRadius) / treeDepth;
    var sectors = [];
    var positions = /* @__PURE__ */ new Map([]);
    var [tooltipPortal, setTooltipPortal] = React.useState(null);
    function handleMouseEnter(node, e) {
      if (onMouseEnter) onMouseEnter(node, e);
      dispatch(setActiveMouseOverItemIndex({
        activeIndex: node.tooltipIndex,
        activeDataKey: dataKey,
        activeCoordinate: positions.get(node.name)
      }));
    }
    function handleMouseLeave(node, e) {
      if (onMouseLeave) onMouseLeave(node, e);
      dispatch(mouseLeaveItem());
    }
    function handleClick(node) {
      if (onClick) onClick(node);
      dispatch(setActiveClickItemIndex({
        activeIndex: node.tooltipIndex,
        activeDataKey: dataKey,
        activeCoordinate: positions.get(node.name)
      }));
    }
    function drawArcs(childNodes, options2) {
      var depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var {
        radius,
        innerR,
        initialAngle,
        childColor,
        nestedActiveTooltipIndex
      } = options2;
      var currentAngle = initialAngle;
      if (!childNodes) return;
      childNodes.forEach((d, i) => {
        var _ref3, _d$fill;
        var currentTooltipIndex = depth === 1 ? "[".concat(i, "]") : addToSunburstNodeIndex(i, nestedActiveTooltipIndex);
        var nodeWithIndex = _objectSpread$3(_objectSpread$3({}, d), {}, {
          tooltipIndex: currentTooltipIndex
        });
        var arcLength = rScale(d[dataKey]);
        var start = currentAngle;
        var fillColor = (_ref3 = (_d$fill = d === null || d === void 0 ? void 0 : d.fill) !== null && _d$fill !== void 0 ? _d$fill : childColor) !== null && _ref3 !== void 0 ? _ref3 : fill2;
        var {
          x: textX,
          y: textY
        } = polarToCartesian(0, 0, innerR + radius / 2, -(start + arcLength - arcLength / 2));
        currentAngle += arcLength;
        sectors.push(
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ React__namespace.createElement("g", {
            key: "sunburst-sector-".concat(d.name, "-").concat(i)
          }, /* @__PURE__ */ React__namespace.createElement(Sector, {
            onClick: () => handleClick(nodeWithIndex),
            onMouseEnter: (e) => handleMouseEnter(nodeWithIndex, e),
            onMouseLeave: (e) => handleMouseLeave(nodeWithIndex, e),
            fill: fillColor,
            stroke,
            strokeWidth: padding,
            startAngle: start,
            endAngle: start + arcLength,
            innerRadius: innerR,
            outerRadius: innerR + radius,
            cx,
            cy
          }), /* @__PURE__ */ React__namespace.createElement(Text, _extends$2({}, textOptions, {
            alignmentBaseline: "middle",
            textAnchor: "middle",
            x: textX + cx,
            y: cy - textY
          }), d[dataKey]))
        );
        var {
          x: tooltipX,
          y: tooltipY
        } = polarToCartesian(cx, cy, innerR + radius / 2, start);
        positions.set(d.name, {
          x: tooltipX,
          y: tooltipY
        });
        return drawArcs(d.children, {
          radius,
          innerR: innerR + radius + ringPadding,
          initialAngle: start,
          childColor: fillColor,
          nestedActiveTooltipIndex: currentTooltipIndex
        }, depth + 1);
      });
    }
    drawArcs(data.children, {
      radius: thickness,
      innerR: innerRadius,
      initialAngle: startAngle
    });
    var layerClass = clsx("recharts-sunburst", className);
    return /* @__PURE__ */ React__namespace.createElement(TooltipPortalContext.Provider, {
      value: tooltipPortal
    }, /* @__PURE__ */ React__namespace.createElement(RechartsWrapper, {
      className,
      width,
      height,
      ref: (node) => {
        if (tooltipPortal == null && node != null) {
          setTooltipPortal(node);
        }
      },
      onMouseEnter: void 0,
      onMouseLeave: void 0,
      onClick: void 0,
      onMouseMove: void 0,
      onMouseDown: void 0,
      onMouseUp: void 0,
      onContextMenu: void 0,
      onDoubleClick: void 0,
      onTouchStart: void 0,
      onTouchMove: void 0,
      onTouchEnd: void 0
    }, /* @__PURE__ */ React__namespace.createElement(Surface, {
      width,
      height
    }, /* @__PURE__ */ React__namespace.createElement(Layer, {
      className: layerClass
    }, sectors), /* @__PURE__ */ React__namespace.createElement(SetTooltipEntrySettings, {
      fn: getTooltipEntrySettings$1,
      args: {
        dataKey,
        data,
        stroke,
        fill: fill2,
        nameKey,
        positions
      }
    }), children)));
  };
  var SunburstChart = (props) => {
    var _props$className;
    return /* @__PURE__ */ React__namespace.createElement(RechartsStoreProvider, {
      preloadedState,
      reduxStoreName: (_props$className = props.className) !== null && _props$className !== void 0 ? _props$className : "SunburstChart"
    }, /* @__PURE__ */ React__namespace.createElement(ReportChartSize, {
      width: props.width,
      height: props.height
    }), /* @__PURE__ */ React__namespace.createElement(ReportChartMargin, {
      margin: defaultSunburstMargin
    }), /* @__PURE__ */ React__namespace.createElement(SunburstChartImpl, props));
  };
  function _extends$1() {
    return _extends$1 = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends$1.apply(null, arguments);
  }
  function ownKeys$2(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$2(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$2(Object(t), true).forEach(function(r3) {
        _defineProperty$2(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$2(e, r2, t) {
    return (r2 = _toPropertyKey$2(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$2(t) {
    var i = _toPrimitive$2(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$2(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function typeGuardTrapezoidProps(option, props) {
    var xValue = "".concat(props.x || option.x);
    var x2 = parseInt(xValue, 10);
    var yValue = "".concat(props.y || option.y);
    var y2 = parseInt(yValue, 10);
    var heightValue = "".concat((props === null || props === void 0 ? void 0 : props.height) || (option === null || option === void 0 ? void 0 : option.height));
    var height = parseInt(heightValue, 10);
    return _objectSpread$2(_objectSpread$2(_objectSpread$2({}, props), getPropsFromShapeOption(option)), {}, {
      height,
      x: x2,
      y: y2
    });
  }
  function FunnelTrapezoid(props) {
    return /* @__PURE__ */ React__namespace.createElement(Shape, _extends$1({
      shapeType: "trapezoid",
      propTransformer: typeGuardTrapezoidProps
    }, props));
  }
  function ownKeys$1(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$1(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$1(Object(t), true).forEach(function(r3) {
        _defineProperty$1(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty$1(e, r2, t) {
    return (r2 = _toPropertyKey$1(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey$1(t) {
    var i = _toPrimitive$1(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive$1(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  var pickFunnelSettings = (_state, funnelSettings) => funnelSettings;
  var selectFunnelTrapezoids = createSelector([selectChartOffsetInternal, pickFunnelSettings, selectChartDataAndAlwaysIgnoreIndexes], (offset, _ref2, _ref22) => {
    var {
      data,
      dataKey,
      nameKey,
      tooltipType,
      lastShapeType,
      reversed,
      customWidth,
      cells,
      presentationProps
    } = _ref2;
    var {
      chartData
    } = _ref22;
    var displayedData;
    if (data != null && data.length > 0) {
      displayedData = data;
    } else if (chartData != null && chartData.length > 0) {
      displayedData = chartData;
    }
    if (displayedData && displayedData.length) {
      displayedData = displayedData.map((entry, index2) => _objectSpread$1(_objectSpread$1(_objectSpread$1({
        payload: entry
      }, presentationProps), entry), cells && cells[index2] && cells[index2].props));
    } else if (cells && cells.length) {
      displayedData = cells.map((cell) => _objectSpread$1(_objectSpread$1({}, presentationProps), cell.props));
    } else {
      return {
        trapezoids: [],
        data: displayedData
      };
    }
    return computeFunnelTrapezoids({
      dataKey,
      nameKey,
      displayedData,
      tooltipType,
      lastShapeType,
      reversed,
      offset,
      customWidth
    });
  });
  var _excluded = ["onMouseEnter", "onClick", "onMouseLeave", "shape", "activeShape"], _excluded2 = ["stroke", "fill", "legendType", "hide", "isAnimationActive", "animationBegin", "animationDuration", "animationEasing", "nameKey", "lastShapeType"];
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
  function ownKeys(e, r2) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r2 && (o = o.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys(Object(t), true).forEach(function(r3) {
        _defineProperty(e, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e;
  }
  function _defineProperty(e, r2, t) {
    return (r2 = _toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, { value: t, enumerable: true, configurable: true, writable: true }) : e[r2] = t, e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive(t, r2) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t);
  }
  function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r2, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n.length; r2++) o = n[r2], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }
  function getTooltipEntrySettings(props) {
    var {
      dataKey,
      nameKey,
      stroke,
      strokeWidth,
      fill: fill2,
      name,
      hide,
      tooltipType,
      data
    } = props;
    return {
      dataDefinedOnItem: data,
      positions: props.trapezoids.map((_ref2) => {
        var {
          tooltipPosition
        } = _ref2;
        return tooltipPosition;
      }),
      settings: {
        stroke,
        strokeWidth,
        fill: fill2,
        dataKey,
        name,
        nameKey,
        hide,
        type: tooltipType,
        color: fill2,
        unit: ""
        // Funnel does not have unit, why?
      }
    };
  }
  function FunnelTrapezoids(props) {
    var {
      trapezoids,
      allOtherFunnelProps,
      showLabels
    } = props;
    var activeItemIndex = useAppSelector((state) => selectActiveIndex(state, "item", state.tooltip.settings.trigger, void 0));
    var {
      onMouseEnter: onMouseEnterFromProps,
      onClick: onItemClickFromProps,
      onMouseLeave: onMouseLeaveFromProps,
      shape,
      activeShape
    } = allOtherFunnelProps, restOfAllOtherProps = _objectWithoutProperties(allOtherFunnelProps, _excluded);
    var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, allOtherFunnelProps.dataKey);
    var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
    var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, allOtherFunnelProps.dataKey);
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, trapezoids.map((entry, i) => {
      var isActiveIndex = activeShape && activeItemIndex === String(i);
      var trapezoidOptions = isActiveIndex ? activeShape : shape;
      var trapezoidProps = _objectSpread(_objectSpread({}, entry), {}, {
        option: trapezoidOptions,
        isActive: isActiveIndex,
        stroke: entry.stroke
      });
      return /* @__PURE__ */ React__namespace.createElement(Layer, _extends({
        className: "recharts-funnel-trapezoid"
      }, adaptEventsOfChild(restOfAllOtherProps, entry, i), {
        // @ts-expect-error the types need a bit of attention
        onMouseEnter: onMouseEnterFromContext(entry, i),
        onMouseLeave: onMouseLeaveFromContext(entry, i),
        onClick: onClickFromContext(entry, i),
        key: "trapezoid-".concat(entry === null || entry === void 0 ? void 0 : entry.x, "-").concat(entry === null || entry === void 0 ? void 0 : entry.y, "-").concat(entry === null || entry === void 0 ? void 0 : entry.name, "-").concat(entry === null || entry === void 0 ? void 0 : entry.value)
      }), /* @__PURE__ */ React__namespace.createElement(FunnelTrapezoid, trapezoidProps));
    }), showLabels && LabelList.renderCallByParent(allOtherFunnelProps, trapezoids));
  }
  var latestId = 0;
  function useAnimationId(reference) {
    var idRef = React.useRef(latestId);
    var ref = React.useRef(reference);
    if (ref.current !== reference) {
      idRef.current += 1;
      latestId = idRef.current;
      ref.current = reference;
    }
    return idRef.current;
  }
  function TrapezoidsWithAnimation(_ref2) {
    var {
      previousTrapezoidsRef,
      props
    } = _ref2;
    var {
      trapezoids,
      isAnimationActive,
      animationBegin,
      animationDuration,
      animationEasing,
      onAnimationEnd,
      onAnimationStart
    } = props;
    var prevTrapezoids = previousTrapezoidsRef.current;
    var [isAnimating, setIsAnimating] = React.useState(true);
    var animationId = useAnimationId(trapezoids);
    var handleAnimationEnd = React.useCallback(() => {
      if (typeof onAnimationEnd === "function") {
        onAnimationEnd();
      }
      setIsAnimating(false);
    }, [onAnimationEnd]);
    var handleAnimationStart = React.useCallback(() => {
      if (typeof onAnimationStart === "function") {
        onAnimationStart();
      }
      setIsAnimating(true);
    }, [onAnimationStart]);
    return /* @__PURE__ */ React__namespace.createElement(JavascriptAnimate, {
      begin: animationBegin,
      duration: animationDuration,
      isActive: isAnimationActive,
      easing: animationEasing,
      key: animationId,
      onAnimationStart: handleAnimationStart,
      onAnimationEnd: handleAnimationEnd
    }, (t) => {
      var stepData = t === 1 ? trapezoids : trapezoids.map((entry, index2) => {
        var prev = prevTrapezoids && prevTrapezoids[index2];
        if (prev) {
          var _interpolatorX = interpolateNumber$2(prev.x, entry.x);
          var _interpolatorY = interpolateNumber$2(prev.y, entry.y);
          var _interpolatorUpperWidth = interpolateNumber$2(prev.upperWidth, entry.upperWidth);
          var _interpolatorLowerWidth = interpolateNumber$2(prev.lowerWidth, entry.lowerWidth);
          var _interpolatorHeight = interpolateNumber$2(prev.height, entry.height);
          return _objectSpread(_objectSpread({}, entry), {}, {
            x: _interpolatorX(t),
            y: _interpolatorY(t),
            upperWidth: _interpolatorUpperWidth(t),
            lowerWidth: _interpolatorLowerWidth(t),
            height: _interpolatorHeight(t)
          });
        }
        var interpolatorX = interpolateNumber$2(entry.x + entry.upperWidth / 2, entry.x);
        var interpolatorY = interpolateNumber$2(entry.y + entry.height / 2, entry.y);
        var interpolatorUpperWidth = interpolateNumber$2(0, entry.upperWidth);
        var interpolatorLowerWidth = interpolateNumber$2(0, entry.lowerWidth);
        var interpolatorHeight = interpolateNumber$2(0, entry.height);
        return _objectSpread(_objectSpread({}, entry), {}, {
          x: interpolatorX(t),
          y: interpolatorY(t),
          upperWidth: interpolatorUpperWidth(t),
          lowerWidth: interpolatorLowerWidth(t),
          height: interpolatorHeight(t)
        });
      });
      if (t > 0) {
        previousTrapezoidsRef.current = stepData;
      }
      return /* @__PURE__ */ React__namespace.createElement(Layer, null, /* @__PURE__ */ React__namespace.createElement(FunnelTrapezoids, {
        trapezoids: stepData,
        allOtherFunnelProps: props,
        showLabels: !isAnimating
      }));
    });
  }
  function RenderTrapezoids(props) {
    var {
      trapezoids,
      isAnimationActive
    } = props;
    var previousTrapezoidsRef = React.useRef(null);
    var prevTrapezoids = previousTrapezoidsRef.current;
    if (isAnimationActive && trapezoids && trapezoids.length && (!prevTrapezoids || prevTrapezoids !== trapezoids)) {
      return /* @__PURE__ */ React__namespace.createElement(TrapezoidsWithAnimation, {
        props,
        previousTrapezoidsRef
      });
    }
    return /* @__PURE__ */ React__namespace.createElement(FunnelTrapezoids, {
      trapezoids,
      allOtherFunnelProps: props,
      showLabels: true
    });
  }
  var getRealWidthHeight = (customWidth, offset) => {
    var {
      width,
      height,
      left,
      right,
      top,
      bottom
    } = offset;
    var realHeight = height;
    var realWidth = width;
    if (isNumber(customWidth)) {
      realWidth = customWidth;
    } else if (typeof customWidth === "string") {
      realWidth = realWidth * parseFloat(customWidth) / 100;
    }
    return {
      realWidth: realWidth - left - right - 50,
      realHeight: realHeight - bottom - top,
      offsetX: (width - realWidth) / 2,
      offsetY: (height - realHeight) / 2
    };
  };
  class FunnelWithState extends React.PureComponent {
    render() {
      var {
        className
      } = this.props;
      var layerClass = clsx("recharts-trapezoids", className);
      return /* @__PURE__ */ React__namespace.createElement(Layer, {
        className: layerClass
      }, /* @__PURE__ */ React__namespace.createElement(RenderTrapezoids, this.props));
    }
  }
  var defaultFunnelProps = {
    stroke: "#fff",
    fill: "#808080",
    legendType: "rect",
    hide: false,
    isAnimationActive: !Global.isSsr,
    animationBegin: 400,
    animationDuration: 1500,
    animationEasing: "ease",
    nameKey: "name",
    lastShapeType: "triangle"
  };
  function FunnelImpl(props) {
    var {
      height,
      width
    } = usePlotArea();
    var _resolveDefaultProps = resolveDefaultProps(props, defaultFunnelProps), {
      stroke,
      fill: fill2,
      legendType,
      hide,
      isAnimationActive,
      animationBegin,
      animationDuration,
      animationEasing,
      nameKey,
      lastShapeType
    } = _resolveDefaultProps, everythingElse = _objectWithoutProperties(_resolveDefaultProps, _excluded2);
    var presentationProps = svgPropertiesNoEvents(props);
    var cells = findAllByType(props.children, Cell);
    var funnelSettings = React.useMemo(() => ({
      dataKey: props.dataKey,
      nameKey,
      data: props.data,
      tooltipType: props.tooltipType,
      lastShapeType,
      reversed: props.reversed,
      customWidth: props.width,
      cells,
      presentationProps
    }), [props.dataKey, nameKey, props.data, props.tooltipType, lastShapeType, props.reversed, props.width, cells, presentationProps]);
    var {
      trapezoids
    } = useAppSelector((state) => selectFunnelTrapezoids(state, funnelSettings));
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(SetTooltipEntrySettings, {
      fn: getTooltipEntrySettings,
      args: _objectSpread(_objectSpread({}, props), {}, {
        trapezoids
      })
    }), hide ? null : /* @__PURE__ */ React__namespace.createElement(FunnelWithState, _extends({}, everythingElse, {
      stroke,
      fill: fill2,
      nameKey,
      lastShapeType,
      animationBegin,
      animationDuration,
      animationEasing,
      isAnimationActive,
      hide,
      legendType,
      height,
      width,
      trapezoids
    })));
  }
  function computeFunnelTrapezoids(_ref3) {
    var {
      dataKey,
      nameKey,
      displayedData,
      tooltipType,
      lastShapeType,
      reversed,
      offset,
      customWidth
    } = _ref3;
    var {
      left,
      top
    } = offset;
    var {
      realHeight,
      realWidth,
      offsetX,
      offsetY
    } = getRealWidthHeight(customWidth, offset);
    var maxValue = Math.max.apply(null, displayedData.map((entry) => getValueByDataKey(entry, dataKey, 0)));
    var len = displayedData.length;
    var rowHeight = realHeight / len;
    var parentViewBox = {
      x: offset.left,
      y: offset.top,
      width: offset.width,
      height: offset.height
    };
    var trapezoids = displayedData.map((entry, i) => {
      var rawVal = getValueByDataKey(entry, dataKey, 0);
      var name = getValueByDataKey(entry, nameKey, i);
      var val = rawVal;
      var nextVal;
      if (i !== len - 1) {
        nextVal = getValueByDataKey(displayedData[i + 1], dataKey, 0);
        if (nextVal instanceof Array) {
          [nextVal] = nextVal;
        }
      } else if (rawVal instanceof Array && rawVal.length === 2) {
        [val, nextVal] = rawVal;
      } else if (lastShapeType === "rectangle") {
        nextVal = val;
      } else {
        nextVal = 0;
      }
      var x2 = (maxValue - val) * realWidth / (2 * maxValue) + top + 25 + offsetX;
      var y2 = rowHeight * i + left + offsetY;
      var upperWidth = val / maxValue * realWidth;
      var lowerWidth = nextVal / maxValue * realWidth;
      var tooltipPayload = [{
        name,
        value: val,
        payload: entry,
        dataKey,
        type: tooltipType
      }];
      var tooltipPosition = {
        x: x2 + upperWidth / 2,
        y: y2 + rowHeight / 2
      };
      return _objectSpread(_objectSpread({
        x: x2,
        y: y2,
        width: Math.max(upperWidth, lowerWidth),
        upperWidth,
        lowerWidth,
        height: rowHeight,
        // @ts-expect-error getValueByDataKey does not validate the output type
        name,
        val,
        tooltipPayload,
        tooltipPosition
      }, omit$1(entry, ["width"])), {}, {
        payload: entry,
        parentViewBox,
        labelViewBox: {
          x: x2 + (upperWidth - lowerWidth) / 4,
          y: y2,
          width: Math.abs(upperWidth - lowerWidth) / 2 + Math.min(upperWidth, lowerWidth),
          height: rowHeight
        }
      });
    });
    if (reversed) {
      trapezoids = trapezoids.map((entry, index2) => {
        var newY = entry.y - index2 * rowHeight + (len - 1 - index2) * rowHeight;
        return _objectSpread(_objectSpread({}, entry), {}, {
          upperWidth: entry.lowerWidth,
          lowerWidth: entry.upperWidth,
          x: entry.x - (entry.lowerWidth - entry.upperWidth) / 2,
          y: entry.y - index2 * rowHeight + (len - 1 - index2) * rowHeight,
          tooltipPosition: _objectSpread(_objectSpread({}, entry.tooltipPosition), {}, {
            y: newY + rowHeight / 2
          }),
          labelViewBox: _objectSpread(_objectSpread({}, entry.labelViewBox), {}, {
            y: newY
          })
        });
      });
    }
    return {
      trapezoids,
      data: displayedData
    };
  }
  class Funnel extends React.PureComponent {
    render() {
      return /* @__PURE__ */ React__namespace.createElement(FunnelImpl, this.props);
    }
  }
  _defineProperty(Funnel, "displayName", "Funnel");
  _defineProperty(Funnel, "defaultProps", defaultFunnelProps);
  var allowedTooltipTypes = ["item"];
  var FunnelChart = /* @__PURE__ */ React.forwardRef((props, ref) => {
    return /* @__PURE__ */ React__namespace.createElement(CartesianChart, {
      chartName: "FunnelChart",
      defaultTooltipEventType: "item",
      validateTooltipEventTypes: allowedTooltipTypes,
      tooltipPayloadSearcher: arrayTooltipSearcher,
      categoricalChartProps: props,
      ref
    });
  });
  function TankLevelChart({ ts }) {
    var _a;
    const series = ((_a = ts == null ? void 0 : ts.level_percent) == null ? void 0 : _a.map((v, i) => {
      var _a2;
      return {
        ts: (_a2 = ts.timestamps[i]) == null ? void 0 : _a2.slice(11, 16),
        nivel: v
      };
    })) ?? [];
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "rounded-2xl", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { className: "pb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { className: "text-sm text-gray-500", children: "Nivel del tanque (24h)" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { className: "h-56", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(LineChart, { data: series, margin: { top: 5, right: 20, left: 0, bottom: 5 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "ts", tick: { fontSize: 10 } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, { tick: { fontSize: 10 }, domain: [0, 100] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { type: "monotone", dataKey: "nivel", dot: false })
      ] }) }) })
    ] });
  }
  function fmtHourKey(iso) {
    const d = new Date(iso);
    return `${d.toISOString().slice(0, 10)} ${String(d.getHours()).padStart(2, "0")}`;
  }
  function fmtHourLabelFromKey(key) {
    const hh = key.slice(11, 13);
    return `${hh}:00`;
  }
  function fmtDayKey(iso) {
    return iso.slice(0, 10);
  }
  function aggregateFleet(fleet, win) {
    const useDaily = win !== "24h";
    const totals = /* @__PURE__ */ new Map();
    Object.values(fleet).forEach((ts) => {
      var _a;
      const n = ((_a = ts.timestamps) == null ? void 0 : _a.length) ?? 0;
      const bucketsOn = /* @__PURE__ */ new Set();
      for (let i = 0; i < n; i++) {
        const iso = ts.timestamps[i];
        const on = ts.is_on && ts.is_on[i] === true || !!ts.power_kw && (ts.power_kw[i] ?? 0) > 0;
        if (!on) continue;
        const key = useDaily ? fmtDayKey(iso) : fmtHourKey(iso);
        bucketsOn.add(key);
      }
      bucketsOn.forEach((key) => {
        totals.set(key, (totals.get(key) ?? 0) + 1);
      });
    });
    const entries = Array.from(totals.entries()).sort((a2, b) => a2[0] < b[0] ? -1 : 1);
    return entries.map(([key, count2]) => ({
      label: useDaily ? key : fmtHourLabelFromKey(key),
      uso_bombas_un: count2
    }));
  }
  function aggregateSingle(ts, win) {
    return aggregateFleet({ single: ts }, win);
  }
  function PumpPowerChart({
    ts,
    fleet,
    windowSel = "24h",
    title = "Uso de bombas (un)"
  }) {
    const data = React.useMemo(() => {
      if (fleet && Object.keys(fleet).length) return aggregateFleet(fleet, windowSel);
      if (ts) return aggregateSingle(ts, windowSel);
      return [];
    }, [fleet, ts, windowSel]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-2xl border bg-white p-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-base font-semibold text-gray-700 mb-2", children: [
        title,
        " ",
        windowSel === "24h" ? "(por hora)" : "(por día)"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-56", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(BarChart, { data, margin: { top: 5, right: 20, left: 0, bottom: 5 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(XAxis, { dataKey: "label" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(YAxis, { allowDecimals: false, tickFormatter: (v) => `${v}` }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { formatter: (v) => [`${v} un`, "Uso de bombas"] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, { name: "Uso de bombas (un)", dataKey: "uso_bombas_un" })
      ] }) }) })
    ] });
  }
  const k$3 = (n) => new Intl.NumberFormat("es-AR").format(n);
  const pct1$2 = (n) => `${n.toFixed(1)}%`;
  function sliceByWindow$2(ts, win) {
    var _a;
    if (!ts || !((_a = ts.timestamps) == null ? void 0 : _a.length)) return ts;
    const end = new Date(ts.timestamps[ts.timestamps.length - 1]);
    const start = new Date(end);
    if (win === "24h") start.setHours(start.getHours() - 24);
    if (win === "7d") start.setDate(start.getDate() - 7);
    if (win === "30d") start.setDate(start.getDate() - 30);
    const startMs = start.getTime();
    const idxs = ts.timestamps.map((t, i) => ({ i, ms: new Date(t).getTime() })).filter(({ ms }) => ms >= startMs).map(({ i }) => i);
    if (!idxs.length) return ts;
    const pick2 = (arr) => arr ? idxs.map((i) => arr[i]) : void 0;
    return {
      ...ts,
      timestamps: idxs.map((i) => ts.timestamps[i]),
      level_percent: pick2(ts.level_percent),
      volume_l: pick2(ts.volume_l),
      temperature_c: pick2(ts.temperature_c),
      is_on: pick2(ts.is_on),
      power_kw: pick2(ts.power_kw)
    };
  }
  function computePumpHours(p, win) {
    var _a;
    if (!p || !((_a = p.timestamps) == null ? void 0 : _a.length)) return 0;
    const s2 = sliceByWindow$2(p, win);
    let hours = 0;
    for (let i = 1; i < s2.timestamps.length; i++) {
      const t02 = new Date(s2.timestamps[i - 1]).getTime();
      const t12 = new Date(s2.timestamps[i]).getTime();
      const dt = (t12 - t02) / 36e5;
      const on = s2.is_on && s2.is_on[i - 1] === true || (s2.power_kw && (s2.power_kw[i - 1] ?? 0) > 0 ? true : false);
      if (on) hours += dt;
    }
    return hours;
  }
  function avg(arr) {
    if (!arr || !arr.length) return 0;
    return arr.reduce((a2, b) => a2 + b, 0) / arr.length;
  }
  function computeTankAvgLevel(t, win) {
    if (!t) return 0;
    const s2 = sliceByWindow$2(t, win);
    return avg(s2.level_percent);
  }
  function OperacionView({ data }) {
    const {
      window: win,
      setWindow,
      locationId,
      pumpId,
      selectPump,
      tankId,
      selectTank
    } = useKpiFilters();
    const [tab, setTab] = React.useState("bombas");
    const inScopePump = (p) => locationId === "all" ? true : p.location_id === locationId;
    const inScopeTank = (t) => locationId === "all" ? true : t.location_id === locationId;
    const pumpsInScope = React.useMemo(
      () => data.assets.pumps.filter(inScopePump),
      [data, locationId]
    );
    const tanksInScope = React.useMemo(
      () => data.assets.tanks.filter(inScopeTank),
      [data, locationId]
    );
    const selectedPumpTs = React.useMemo(() => {
      var _a;
      if (!pumpId) return void 0;
      const ts = (_a = data.timeseries.pumps) == null ? void 0 : _a[String(pumpId)];
      return sliceByWindow$2(ts, win);
    }, [pumpId, data, win]);
    const fleetTs = React.useMemo(() => {
      const out = {};
      pumpsInScope.forEach((p) => {
        var _a;
        const ts = (_a = data.timeseries.pumps) == null ? void 0 : _a[String(p.id)];
        if (ts) out[p.id] = sliceByWindow$2(ts, win);
      });
      return out;
    }, [data, pumpsInScope, win]);
    const selectedTankTs = React.useMemo(() => {
      var _a;
      const tanksTs = data.timeseries.tanks;
      if (tankId) {
        const ts = tanksTs == null ? void 0 : tanksTs[String(tankId)];
        return sliceByWindow$2(ts, win);
      }
      for (const t of tanksInScope) {
        const ts = tanksTs == null ? void 0 : tanksTs[String(t.id)];
        if ((_a = ts == null ? void 0 : ts.timestamps) == null ? void 0 : _a.length) {
          return sliceByWindow$2(ts, win);
        }
      }
      return void 0;
    }, [tankId, data, tanksInScope, win]);
    const rowsBombas = React.useMemo(() => {
      return pumpsInScope.map((p) => {
        var _a;
        const ts = (_a = data.timeseries.pumps) == null ? void 0 : _a[String(p.id)];
        return {
          id: p.id,
          name: p.name ?? `Bomba ${p.id}`,
          h24: computePumpHours(ts, "24h"),
          h7d: computePumpHours(ts, "7d"),
          h30: computePumpHours(ts, "30d")
        };
      });
    }, [pumpsInScope, data]);
    const rowsTanques = React.useMemo(() => {
      return tanksInScope.map((t) => {
        var _a;
        const ts = (_a = data.timeseries.tanks) == null ? void 0 : _a[String(t.id)];
        return {
          id: t.id,
          name: t.name ?? `Tanque ${t.id}`,
          a24: computeTankAvgLevel(ts, "24h"),
          a7d: computeTankAvgLevel(ts, "7d"),
          a30: computeTankAvgLevel(ts, "30d")
        };
      });
    }, [tanksInScope, data]);
    const pumpCount = pumpsInScope.length;
    const tankCount = tanksInScope.length;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Activos", value: k$3(data.kpis.assets_total) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Tanques", value: k$3(data.kpis.tanks) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Bombas", value: k$3(data.kpis.pumps) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Valv.", value: k$3(data.kpis.valves) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Alarmas activas", value: k$3(data.kpis.alarms_active) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Nivel prom. (30d)", value: pct1$2(data.kpis.avg_level_pct_30d) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-8 my-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-500", children: "Ventana:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: win === "24h" ? "default" : "outline", onClick: () => setWindow("24h"), children: "24 hs" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: win === "7d" ? "default" : "outline", onClick: () => setWindow("7d"), children: "1 semana" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: win === "30d" ? "default" : "outline", onClick: () => setWindow("30d"), children: "30 días" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "grid grid-cols-1 lg:grid-cols-2 gap-4", children: [
        selectedTankTs ? /* @__PURE__ */ jsxRuntimeExports.jsx(TankLevelChart, { ts: selectedTankTs }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: "Sin datos de tanque" }) }),
        selectedPumpTs ? /* @__PURE__ */ jsxRuntimeExports.jsx(PumpPowerChart, { ts: selectedPumpTs, windowSel: win, title: "Uso de bombas", totalAvailable: 1 }) : Object.keys(fleetTs).length ? /* @__PURE__ */ jsxRuntimeExports.jsx(PumpPowerChart, { fleet: fleetTs, windowSel: win, title: "Uso de bombas", totalAvailable: pumpCount }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: "Sin datos de bomba" }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "rounded-2xl", style: { marginTop: 12 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { className: "pb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CardTitle, { className: "text-sm text-gray-500", children: [
            "Detalle · ",
            tab === "bombas" ? `Bombas: ${pumpCount}` : `Tanques: ${tankCount}`
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Tabs,
            {
              value: tab,
              onChange: (v) => setTab(v),
              tabs: [
                { id: "bombas", label: "Bombas" },
                { id: "tanques", label: "Tanques" }
              ]
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: tab === "bombas" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "min-w-full text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-left p-2", children: "Bomba" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-left p-2 " + (win === "24h" ? "font-semibold" : ""), children: "24 hs" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-left p-2 " + (win === "7d" ? "font-semibold" : ""), children: "1 semana" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-left p-2 " + (win === "30d" ? "font-semibold" : ""), children: "30 días" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: rowsBombas.map((r2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "tr",
            {
              className: `border-t cursor-pointer ${pumpId === r2.id ? "bg-gray-50" : ""}`,
              onClick: () => selectPump(pumpId === r2.id ? null : r2.id),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-2", children: r2.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "p-2", children: [
                  r2.h24.toFixed(1),
                  " h"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "p-2", children: [
                  r2.h7d.toFixed(1),
                  " h"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "p-2", children: [
                  r2.h30.toFixed(1),
                  " h"
                ] })
              ]
            },
            r2.id
          )) })
        ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "min-w-full text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-left p-2", children: "Tanque" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-left p-2 " + (win === "24h" ? "font-semibold" : ""), children: "24 hs" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-left p-2 " + (win === "7d" ? "font-semibold" : ""), children: "1 semana" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-left p-2 " + (win === "30d" ? "font-semibold" : ""), children: "30 días" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: rowsTanques.map((r2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "tr",
            {
              className: `border-t cursor-pointer ${tankId === r2.id ? "bg-gray-50" : ""}`,
              onClick: () => selectTank(tankId === r2.id ? null : r2.id),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-2", children: r2.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-2", children: pct1$2(r2.a24) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-2", children: pct1$2(r2.a7d) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-2", children: pct1$2(r2.a30) })
              ]
            },
            r2.id
          )) })
        ] }) }) })
      ] })
    ] });
  }
  const k$2 = (n) => new Intl.NumberFormat("es-AR").format(n);
  const pct = (n) => `${n.toFixed(1)}%`;
  const bandForHour = (h) => h < 7 ? "VALLE" : h < 19 ? "RESTO" : h < 23 ? "PICO" : "VALLE";
  const devAssert = (cond, msg = "Assertion failed") => {
    if (!cond) {
      console.warn("[devAssert]", msg);
    }
  };
  function buildPowerFromIsOn(data) {
    for (const p of data.assets.pumps) {
      const ts = data.timeseries.pumps[String(p.id)];
      if (!ts) continue;
      ts.power_kw = ts.is_on.map((on) => {
        const base = on ? p.rated_kw * 0.82 : 0.1;
        const jitter = on ? (Math.random() * 0.2 - 0.1) * p.rated_kw : 0;
        return Math.max(0, Number((base + jitter).toFixed(2)));
      });
    }
  }
  function kwhByBandForPump(pumpTs) {
    if (!(pumpTs == null ? void 0 : pumpTs.power_kw)) return { VALLE: 0, PICO: 0, RESTO: 0, total: 0 };
    const acc = { VALLE: 0, PICO: 0, RESTO: 0 };
    pumpTs.timestamps.forEach((t, i) => {
      const h = Number(t.slice(11, 13));
      const band2 = bandForHour(h);
      acc[band2] += pumpTs.power_kw[i] || 0;
    });
    const total = acc.VALLE + acc.PICO + acc.RESTO;
    return { ...acc, total };
  }
  const countStarts = (isOn) => isOn.slice(1).reduce((s2, v, i) => s2 + (!isOn[i] && v ? 1 : 0), 0);
  const availabilityPct = (isOn) => isOn.filter(Boolean).length / Math.max(1, isOn.length) * 100;
  function avgOnDurationHours(isOn) {
    let total = 0, runs = 0, cur = 0;
    for (let i = 0; i < isOn.length; i++) {
      if (isOn[i]) cur++;
      if ((!isOn[i] || i === isOn.length - 1) && cur > 0) {
        total += cur;
        runs++;
        cur = 0;
      }
    }
    return runs ? total / runs : 0;
  }
  function tankStats(ts) {
    const arr = (ts == null ? void 0 : ts.level_percent) ?? [];
    if (!arr.length) return { min: null, max: null, mean: null, range: null };
    const min2 = Math.min(...arr), max2 = Math.max(...arr);
    const mean2 = arr.reduce((a2, b) => a2 + b, 0) / arr.length;
    return { min: min2, max: max2, mean: mean2, range: max2 - min2 };
  }
  function tempStats(ts) {
    const arr = (ts == null ? void 0 : ts.temperature_c) ?? [];
    if (!arr.length) return { mean: null, min: null, max: null };
    const min2 = Math.min(...arr), max2 = Math.max(...arr);
    const mean2 = arr.reduce((a2, b) => a2 + b, 0) / arr.length;
    return { mean: mean2, min: min2, max: max2 };
  }
  const turnoverEstimatePerDay = (levelRangePct) => Math.max(0, Number(levelRangePct.toFixed(1)));
  function criticalResolvedUnder24h(alarms) {
    const crit = alarms.filter((a2) => a2.severity === "critical");
    if (!crit.length) return { pct: 100, total: 0 };
    const ok = crit.filter((a2) => a2.is_active === false).length;
    return { pct: ok / crit.length * 100, total: crit.length };
  }
  function topEnergyByLocation(data) {
    const map2 = /* @__PURE__ */ new Map();
    for (const p of data.assets.pumps) {
      const rec = data.analytics30d.pump_energy_kwh[String(p.id)];
      map2.set(p.location_id, (map2.get(p.location_id) || 0) + (rec ? rec.kwh_30d : 0));
    }
    const rows = data.locations.map((l) => ({
      location_id: l.location_id,
      location_name: l.location_name,
      code: l.location_code,
      kwh_30d: map2.get(l.location_id) || 0
    }));
    return rows.sort((a2, b) => b.kwh_30d - a2.kwh_30d).slice(0, 3);
  }
  const k$1 = (n) => new Intl.NumberFormat("es-AR").format(n);
  const pct1$1 = (n) => `${n.toFixed(1)}%`;
  function sliceByWindow$1(ts, win) {
    var _a;
    if (!ts || !((_a = ts.timestamps) == null ? void 0 : _a.length)) return ts;
    const end = new Date(ts.timestamps[ts.timestamps.length - 1]);
    const start = new Date(end);
    if (win === "24h") start.setHours(start.getHours() - 24);
    if (win === "7d") start.setDate(start.getDate() - 7);
    if (win === "30d") start.setDate(start.getDate() - 30);
    const startMs = start.getTime();
    const idxs = ts.timestamps.map((t, i) => ({ i, ms: new Date(t).getTime() })).filter(({ ms }) => ms >= startMs).map(({ i }) => i);
    if (!idxs.length) return ts;
    const pick2 = (arr) => arr ? idxs.map((i) => arr[i]) : void 0;
    return {
      ...ts,
      timestamps: idxs.map((i) => ts.timestamps[i]),
      is_on: pick2(ts.is_on),
      power_kw: pick2(ts.power_kw)
    };
  }
  function hoursByBandForPump(ts, onKwThreshold = 0.15) {
    var _a;
    let VALLE = 0, PICO = 0, RESTO = 0, total = 0;
    const n = ((_a = ts == null ? void 0 : ts.timestamps) == null ? void 0 : _a.length) ?? 0;
    if (!ts || n <= 1) return { VALLE, PICO, RESTO, total };
    for (let i = 1; i < n; i++) {
      const t02 = new Date(ts.timestamps[i - 1]).getTime();
      const t12 = new Date(ts.timestamps[i]).getTime();
      const dtH = (t12 - t02) / 36e5;
      const on = ts.is_on && ts.is_on[i - 1] === true || ts.power_kw && (ts.power_kw[i - 1] ?? 0) > onKwThreshold;
      if (!on || dtH <= 0) continue;
      const h = new Date(ts.timestamps[i - 1]).getHours();
      const band2 = bandForHour(h);
      if (band2 === "VALLE") VALLE += dtH;
      else if (band2 === "PICO") PICO += dtH;
      else RESTO += dtH;
      total += dtH;
    }
    return { VALLE, PICO, RESTO, total };
  }
  function EficienciaView({ data }) {
    var _a, _b;
    const { locationId, window: win, setWindow, pumpId, selectPump } = useKpiFilters();
    const pumpsInScope = React.useMemo(
      () => data.assets.pumps.filter(
        (p) => locationId === "all" ? true : p.location_id === locationId
      ),
      [data, locationId]
    );
    const selectedPumpId = React.useMemo(() => {
      const inScope = pumpId && pumpsInScope.some((p) => p.id === pumpId);
      if (inScope) return pumpId;
      const firstWithTs = pumpsInScope.find(
        (p) => {
          var _a2;
          return (_a2 = data.timeseries.pumps) == null ? void 0 : _a2[String(p.id)];
        }
      );
      return (firstWithTs == null ? void 0 : firstWithTs.id) ?? null;
    }, [pumpId, pumpsInScope, data]);
    const rawTs = selectedPumpId ? (_a = data.timeseries.pumps) == null ? void 0 : _a[String(selectedPumpId)] : void 0;
    const ts = React.useMemo(() => sliceByWindow$1(rawTs, win), [rawTs, win]);
    const bandsH = React.useMemo(() => hoursByBandForPump(ts), [ts]);
    const totalH = bandsH.total;
    const pct2 = (v) => totalH > 0 ? v / totalH * 100 : 0;
    const pctValle = pct2(bandsH.VALLE);
    const pctPico = pct2(bandsH.PICO);
    const pctResto = pct2(bandsH.RESTO);
    const titleByWin = win === "24h" ? "24h" : win === "7d" ? "últimos 7 días" : "últimos 30 días";
    const rowsBombas = React.useMemo(() => {
      return pumpsInScope.map((p) => {
        var _a2;
        const base = (_a2 = data.timeseries.pumps) == null ? void 0 : _a2[String(p.id)];
        const sliced = sliceByWindow$1(base, win);
        const b = hoursByBandForPump(sliced);
        const vallePct = b.total > 0 ? b.VALLE / b.total * 100 : 0;
        return {
          id: p.id,
          name: p.name ?? `Bomba ${p.id}`,
          horas: b.total,
          vallePct
        };
      });
    }, [pumpsInScope, data, win]);
    if (!((_b = ts == null ? void 0 : ts.timestamps) == null ? void 0 : _b.length)) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "rounded-2xl", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { className: "pb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { className: "text-sm text-gray-500", children: "Eficiencia energética" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { className: "text-sm text-gray-600", children: [
          "No hay datos para esta ubicación/ventana. Elegí otra bomba en ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "Operación" }),
          " o cambiá la ventana."
        ] })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Activos", value: k$1(data.kpis.assets_total) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Tanques", value: k$1(data.kpis.tanks) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Bombas", value: k$1(data.kpis.pumps) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Valv.", value: k$1(data.kpis.valves) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Alarmas activas", value: k$1(data.kpis.alarms_active) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Nivel prom. (30d)", value: pct1$1(data.kpis.avg_level_pct_30d) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-8", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-500", children: "Ventana:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: win === "24h" ? "default" : "outline", onClick: () => setWindow("24h"), children: "24 hs" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: win === "7d" ? "default" : "outline", onClick: () => setWindow("7d"), children: "1 semana" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: win === "30d" ? "default" : "outline", onClick: () => setWindow("30d"), children: "30 días" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "rounded-2xl", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { className: "pb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardTitle, { className: "text-sm text-gray-500", children: [
            "Distribución de uso (horas, ",
            titleByWin,
            ")"
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-72 pt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResponsiveContainer, { width: "100%", height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(PieChart, { margin: { top: 0, right: 8, bottom: 0, left: 8 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Pie,
                {
                  dataKey: "value",
                  data: [
                    { name: "VALLE", value: Number(bandsH.VALLE || 0) },
                    { name: "PICO", value: Number(bandsH.PICO || 0) },
                    { name: "RESTO", value: Number(bandsH.RESTO || 0) }
                  ],
                  nameKey: "name",
                  cx: "50%",
                  cy: "55%",
                  outerRadius: "70%",
                  label: false,
                  labelLine: false,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Cell, { fill: "#60a5fa" }),
                    " ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Cell, { fill: "#ef4444" }),
                    " ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Cell, { fill: "#a3a3a3" }),
                    " "
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { formatter: (v, n) => [`${Number(v).toFixed(1)} h`, n] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Legend, { verticalAlign: "bottom", align: "center" })
            ] }) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 grid grid-cols-1 sm:grid-cols-3 gap-2 text-center text-sm", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-2 rounded-xl bg-gray-50", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-500", children: "VALLE" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-medium", children: [
                  pctValle.toFixed(0),
                  "%"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-2 rounded-xl bg-gray-50", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-500", children: "PICO" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-medium", children: [
                  pctPico.toFixed(0),
                  "%"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-2 rounded-xl bg-gray-50", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-500", children: "RESTO" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-medium", children: [
                  pctResto.toFixed(0),
                  "%"
                ] })
              ] })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "rounded-2xl", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { className: "pb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { className: "text-sm text-gray-500", children: "Uso por bandas" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 md:grid-cols-4 gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: `Horas (${titleByWin})`, value: `${totalH.toFixed(1)} h` }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "VALLE", value: `${pctValle.toFixed(0)}%`, sub: "% sobre total" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "PICO", value: `${pctPico.toFixed(0)}%`, sub: "% sobre total" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "RESTO", value: `${pctResto.toFixed(0)}%`, sub: "% sobre total" })
          ] }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "rounded-2xl", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { className: "pb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardTitle, { className: "text-sm text-gray-500", children: [
          "Bombas en ámbito · ",
          pumpsInScope.length
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "min-w-full text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-left p-2", children: "Bomba" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("th", { className: "text-right p-2", children: [
              "Horas (",
              titleByWin,
              ")"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-right p-2", children: "% en VALLE" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: rowsBombas.map((r2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "tr",
            {
              className: `border-t cursor-pointer ${selectedPumpId === r2.id ? "bg-gray-50" : ""}`,
              onClick: () => selectPump(selectedPumpId === r2.id ? null : r2.id),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-2", children: r2.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "p-2 text-right", children: [
                  r2.horas.toFixed(1),
                  " h"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "p-2 text-right", children: [
                  r2.vallePct.toFixed(0),
                  "%"
                ] })
              ]
            },
            r2.id
          )) })
        ] }) }) })
      ] })
    ] });
  }
  const k = (n) => new Intl.NumberFormat("es-AR").format(n);
  const pct1 = (n) => `${n.toFixed(1)}%`;
  function sliceByWindow(ts, win) {
    var _a;
    if (!ts || !((_a = ts.timestamps) == null ? void 0 : _a.length)) return ts;
    const end = new Date(ts.timestamps[ts.timestamps.length - 1]);
    const start = new Date(end);
    if (win === "24h") start.setHours(start.getHours() - 24);
    if (win === "7d") start.setDate(start.getDate() - 7);
    if (win === "30d") start.setDate(start.getDate() - 30);
    const startMs = start.getTime();
    const idxs = ts.timestamps.map((t, i) => ({ i, ms: new Date(t).getTime() })).filter(({ ms }) => ms >= startMs).map(({ i }) => i);
    if (!idxs.length) return ts;
    const pick2 = (arr) => arr ? idxs.map((i) => arr[i]) : void 0;
    return {
      ...ts,
      timestamps: idxs.map((i) => ts.timestamps[i]),
      is_on: pick2(ts.is_on),
      power_kw: pick2(ts.power_kw)
    };
  }
  function mtbaHours(alarms = []) {
    if (alarms.length < 2) return null;
    const times2 = alarms.map((a2) => new Date(a2.ts_raised).getTime()).filter((n) => Number.isFinite(n)).sort((a2, b) => a2 - b);
    if (times2.length < 2) return null;
    let sum2 = 0;
    for (let i = 1; i < times2.length; i++) sum2 += times2[i] - times2[i - 1];
    return sum2 / (times2.length - 1) / 36e5;
  }
  function ConfiabilidadView({ data }) {
    var _a;
    const { locationId, window: win, setWindow, pumpId, selectPump } = useKpiFilters();
    const pumpsInScope = React.useMemo(
      () => data.assets.pumps.filter(
        (p) => locationId === "all" ? true : p.location_id === locationId
      ),
      [data, locationId]
    );
    const selectedPumpId = React.useMemo(() => {
      const inScope = pumpId && pumpsInScope.some((p) => p.id === pumpId);
      if (inScope) return pumpId;
      const firstWithTs = pumpsInScope.find(
        (p) => {
          var _a2;
          return (_a2 = data.timeseries.pumps) == null ? void 0 : _a2[String(p.id)];
        }
      );
      return (firstWithTs == null ? void 0 : firstWithTs.id) ?? null;
    }, [pumpId, pumpsInScope, data]);
    const rawTs = selectedPumpId ? (_a = data.timeseries.pumps) == null ? void 0 : _a[String(selectedPumpId)] : void 0;
    const ts = React.useMemo(() => sliceByWindow(rawTs, win), [rawTs, win]);
    const isOn = (ts == null ? void 0 : ts.is_on) ?? [];
    const starts = React.useMemo(() => countStarts(isOn), [isOn]);
    const avail = React.useMemo(() => availabilityPct(isOn), [isOn]);
    const avgRun = React.useMemo(() => avgOnDurationHours(isOn), [isOn]);
    const alarmsForWindow = React.useMemo(() => {
      var _a2;
      const all = (data.alarms ?? []).map((a2) => ({
        ts_raised: a2.ts ?? a2.ts_raised ?? ""
      }));
      const end = ((_a2 = ts == null ? void 0 : ts.timestamps) == null ? void 0 : _a2[ts.timestamps.length - 1]) ? new Date(ts.timestamps[ts.timestamps.length - 1]).getTime() : Date.now();
      const start = win === "24h" ? end - 24 * 36e5 : win === "7d" ? end - 7 * 24 * 36e5 : end - 30 * 24 * 36e5;
      return all.filter((a2) => {
        const t = new Date(a2.ts_raised).getTime();
        return Number.isFinite(t) && t >= start && t <= end;
      });
    }, [data, ts, win]);
    const mtba = React.useMemo(() => mtbaHours(alarmsForWindow), [alarmsForWindow]);
    const titleByWin = win === "24h" ? "24h" : win === "7d" ? "últimos 7 días" : "últimos 30 días";
    const rows = React.useMemo(() => {
      return pumpsInScope.map((p) => {
        var _a2;
        const base = (_a2 = data.timeseries.pumps) == null ? void 0 : _a2[String(p.id)];
        const sliced = sliceByWindow(base, win);
        const onArr = (sliced == null ? void 0 : sliced.is_on) ?? [];
        return {
          id: p.id,
          name: p.name ?? `Bomba ${p.id}`,
          starts: countStarts(onArr),
          avail: availabilityPct(onArr),
          avgRun: avgOnDurationHours(onArr)
        };
      });
    }, [pumpsInScope, data, win]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Activos", value: k(data.kpis.assets_total) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Tanques", value: k(data.kpis.tanks) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Bombas", value: k(data.kpis.pumps) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Valv.", value: k(data.kpis.valves) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Alarmas activas", value: k(data.kpis.alarms_active) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Nivel prom. (30d)", value: pct1(data.kpis.avg_level_pct_30d) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-8", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-500", children: "Ventana:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: win === "24h" ? "default" : "outline", onClick: () => setWindow("24h"), children: "24 hs" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: win === "7d" ? "default" : "outline", onClick: () => setWindow("7d"), children: "1 semana" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: win === "30d" ? "default" : "outline", onClick: () => setWindow("30d"), children: "30 días" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: `Disponibilidad (${titleByWin})`, value: `${avail.toFixed(0)}%` }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Arranques", value: starts, sub: `en ${titleByWin}` }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KPI, { label: "Tiempo medio por ciclo", value: `${avgRun.toFixed(1)} h` })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "rounded-2xl", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { className: "pb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { className: "text-sm text-gray-500", children: "MTBA (tiempo medio entre alarmas)" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl font-semibold", children: typeof mtba === "number" ? `${mtba.toFixed(1)} h` : "—" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-500 mt-1", children: "Calculado sobre alarmas del período seleccionado." })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "rounded-2xl", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { className: "pb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardTitle, { className: "text-sm text-gray-500", children: [
          "Bombas en ámbito · ",
          pumpsInScope.length
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "min-w-full text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-left p-2", children: "Bomba" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-right p-2", children: "Disponibilidad" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-right p-2", children: "Arranques" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-right p-2", children: "Tiempo medio ciclo" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: rows.map((r2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "tr",
            {
              className: `border-t cursor-pointer ${selectedPumpId === r2.id ? "bg-gray-50" : ""}`,
              onClick: () => selectPump(selectedPumpId === r2.id ? null : r2.id),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-2", children: r2.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "p-2 text-right", children: [
                  r2.avail.toFixed(0),
                  "%"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-2 text-right", children: r2.starts }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "p-2 text-right", children: [
                  r2.avgRun.toFixed(1),
                  " h"
                ] })
              ]
            },
            r2.id
          )) })
        ] }) }) })
      ] })
    ] });
  }
  function KpiContent() {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(KpiFiltersProvider, { initialLocation: "all", children: /* @__PURE__ */ jsxRuntimeExports.jsx(KpiContentInner, {}) });
  }
  function KpiContentInner() {
    const [tab, setTab] = React.useState("operacion");
    const { locationId, setLocationId, clearSelections } = useKpiFilters();
    const locations = mock.locations ?? [];
    function handleChangeLocation(e) {
      const v = e.target.value;
      const newLoc = v === "all" ? "all" : Number(v);
      setLocationId(newLoc);
      clearSelections();
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-600", children: "Ubicación:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              className: "border rounded-md px-2 py-1 text-sm",
              value: locationId === "all" ? "all" : String(locationId),
              onChange: handleChangeLocation,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all", children: "Todas" }),
                locations.map((loc) => /* @__PURE__ */ jsxRuntimeExports.jsxs("option", { value: String(loc.location_id), children: [
                  loc.location_name,
                  " (",
                  loc.location_code,
                  ")"
                ] }, loc.location_id))
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            className: "border rounded-md px-3 py-1 text-sm hover:bg-gray-50",
            onClick: () => console.log("[KPI] payload actual:", mock),
            children: "Loggear DATA"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "flex items-center gap-6 text-sm", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TopTabLink, { id: "operacion", tab, setTab, children: "Operación" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TopTabLink, { id: "eficiencia", tab, setTab, children: "Eficiencia energética" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TopTabLink, { id: "confiabilidad", tab, setTab, children: "Operación y confiabilidad" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TopTabLink, { id: "proceso", tab, setTab, children: "Proceso y calidad del agua" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TopTabLink, { id: "gestion", tab, setTab, children: "Gestión global" })
      ] }),
      tab === "operacion" && /* @__PURE__ */ jsxRuntimeExports.jsx(OperacionView, { data: mock }),
      tab === "eficiencia" && /* @__PURE__ */ jsxRuntimeExports.jsx(EficienciaView, { data: mock }),
      tab === "confiabilidad" && /* @__PURE__ */ jsxRuntimeExports.jsx(ConfiabilidadView, { data: mock }),
      tab === "proceso" && /* @__PURE__ */ jsxRuntimeExports.jsx(Placeholder, { children: "Próximamente: Proceso y calidad del agua (usar useKpiFilters)" }),
      tab === "gestion" && /* @__PURE__ */ jsxRuntimeExports.jsx(Placeholder, { children: "Próximamente: Gestión global (usar useKpiFilters)" })
    ] });
  }
  function TopTabLink({
    id,
    tab,
    setTab,
    children
  }) {
    const active = tab === id;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        type: "button",
        className: `border-b-2 pb-1 ${active ? "border-black text-black" : "border-transparent text-gray-500 hover:text-gray-800"}`,
        onClick: () => setTab(id),
        children
      }
    );
  }
  function Placeholder({ children }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-xl border p-6 text-sm text-gray-600 bg-white", children });
  }
  const KPI_WIDGET_VERSION = "0.1.7";
  function getHostBg(fallback = "#f6f7f9") {
    try {
      const c2 = getComputedStyle(document.body).backgroundColor;
      return c2 && c2 !== "rgba(0, 0, 0, 0)" ? c2 : fallback;
    } catch {
      return fallback;
    }
  }
  function KpiWidget(props) {
    const { title, chrome = "panel", pageBg = "auto", ...rest2 } = props;
    const body = /* @__PURE__ */ jsxRuntimeExports.jsx(KpiContent, { ...rest2 });
    const resolvedBg = pageBg === "auto" ? getHostBg() : pageBg;
    const rootStyle = {
      fontFamily: "ui-sans-serif, system-ui",
      width: "100%",
      height: "100%",
      background: resolvedBg
      // 👈 toma el mismo color que el host
    };
    if (chrome === "none") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "kpi-root", style: rootStyle, children: body });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "kpi-root", style: rootStyle, children: [
      title && /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { margin: 0, marginBottom: 12 }, children: title }),
      body
    ] });
  }
  function mountKpiWidget(el, props = {}) {
    const root = ReactDOM.createRoot(el);
    root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(KpiWidget, { ...props }));
    return () => root.unmount();
  }
  class KpiWidgetElement extends HTMLElement {
    constructor() {
      super(...arguments);
      __publicField(this, "root");
    }
    static get observedAttributes() {
      return ["title", "compact", "data", "chrome", "page-bg"];
    }
    connectedCallback() {
      this.root = ReactDOM.createRoot(this);
      this.render();
    }
    attributeChangedCallback() {
      this.render();
    }
    disconnectedCallback() {
      var _a;
      (_a = this.root) == null ? void 0 : _a.unmount();
    }
    render() {
      var _a;
      const title = this.getAttribute("title") || void 0;
      const compact2 = this.getAttribute("compact") === "true";
      const chromeAttr = (this.getAttribute("chrome") || "panel").toLowerCase();
      const chrome = chromeAttr === "none" ? "none" : "panel";
      const pageBgAttr = this.getAttribute("page-bg") || "auto";
      let data;
      const dataAttr = this.getAttribute("data");
      if (dataAttr) {
        try {
          data = JSON.parse(dataAttr);
        } catch {
          data = void 0;
        }
      }
      (_a = this.root) == null ? void 0 : _a.render(
        /* @__PURE__ */ jsxRuntimeExports.jsx(KpiWidget, { title, compact: compact2, data, chrome, pageBg: pageBgAttr })
      );
    }
  }
  __publicField(KpiWidgetElement, "version", KPI_WIDGET_VERSION);
  function defineKpiWidgetElement(tagName = "kpi-widget") {
    if (typeof window !== "undefined") {
      const defined2 = customElements.get(tagName);
      if (!defined2) {
        customElements.define(tagName, KpiWidgetElement);
      }
    }
  }
  const api = {
    version: KPI_WIDGET_VERSION,
    KpiWidget,
    mount: mountKpiWidget,
    defineElement: defineKpiWidgetElement
  };
  exports2.KPI_WIDGET_VERSION = KPI_WIDGET_VERSION;
  exports2.KpiWidget = KpiWidget;
  exports2.default = api;
  exports2.defineKpiWidgetElement = defineKpiWidgetElement;
  exports2.mountKpiWidget = mountKpiWidget;
  Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
});
//# sourceMappingURL=kpi-widget.dev.umd.js.map
